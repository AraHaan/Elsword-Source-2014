#include "StdAfx.h"
#include ".\X2GuEve.h"

// dmlee 2009-05-23, 이브의 소환 몬스터의 stat은 cx2game::createnpc()함수 안에서 따로 이브의 stat의 기준으로 다시 설정해주게 되어 있음.


// 대시 점프, 점프 대시 속도를 정하는 parameter
static const float s_fDashJumpSpeedScale		= 1.85f;
static const float s_fDashJumpSpeedLowerBound	= 1.f;
static const float s_fMaxDashJumpTime			= 0.65f;

#ifdef BALANCE_PATCH_20120329
static const float s_fEveDefaultInvisibilityTime = 3.f;
#else
static const float s_fEveDefaultInvisibilityTime = 5.f;
#endif


#ifdef SERV_APRIL_FOOLS_DAY
static const CX2GUUser::SkillCutIn s_SkillCutInSetFoolsDay = CX2GUUser::SkillCutIn( L"HQ_CutIn_Eve_Gura.dds");
#endif //APRIL_FOOLS_DAY

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어

namespace _CONST_EVE_
{
	//	기동 코어 상태 유지 시간 상수, BEFORE_ATTACK -> ATTACK -> AFTER_ATTACK 순의 숫자 입니다.
	const float MANEUVER_CORE_BEFORE_ATTACK_TIME = 0.2f;							
	const float MANEUVER_CORE_ATTACK_TIME = 1.0f;									
	const float MANEUVER_CORE_AFTER_ATTACK_TIME = 1.0f;								
	
	const float MANEUVER_CORE_PARRYING_TIME = 1.1f;									// Parrying State 의 유지 시간	( 변경 필요 )
	const float MANEUVER_CORE_3RD_WAKE_UP_DAMAGE_EFFECT_MAKE_COOL_TIME = 0.1f;		// 3각성 공격의 데미지 이펙트 생성 쿨타임 ( 삭제? )
	
	const float MANEUVER_CORE_ATTACK_TIME_USING_MANEUVER_GAUGE = 1.133f;			// 각성 소모 공격의 유지 시간
	const float MANEUVER_CORE_COEFF_INCREASE_DAMAGE_EFFECT_SIZE = 1.f;				// 각성 소모 공격의 데미지 이펙트 사이즈가 증가하는 계수
	
	const int	MANEUVER_CORE_MAX_LEVEL	= 3;
	const D3DXVECTOR3 MANEUVER_CORE_WAIT_STATE_POSITION_OFFSET				= D3DXVECTOR3 ( 90.f, 189.f, 0.f );
	const D3DXVECTOR3 MANEUVER_CORE_ATTACK_STATE_POSITION_OFFSET			= D3DXVECTOR3 ( 200.f, 100.f, 0.f );

	const float	MANEUVER_CORE_LASER_ATTACK_HIT_VALUE						= 5.f;

}
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어

// 필살기 쓸 때 cut in image 
static const CX2GUUser::SkillCutInSet s_SkillCutInSet[] = 
{
	// 이브, 엑조, 아키
	{
		CX2GUUser::SkillCutIn( L"HQ_CutIn_Eve_1.dds"),// D3DXVECTOR2( 590.f, 590.f ), D3DXVECTOR3( 230.f, 482.f, 0.0f ) ),
		CX2GUUser::SkillCutIn( L"HQ_CutIn_Eve_2.dds"),// D3DXVECTOR2( 778.f, 778.f ), D3DXVECTOR3( 256.f, 577.f, 0.0f ) ),
		CX2GUUser::SkillCutIn( L"HQ_CutIn_Eve_3.dds"),// D3DXVECTOR2( 820.f, 820.f ), D3DXVECTOR3( 135.f, 582.f, 0.0f ) ),
	},

	//{{ kimhc // 2010.2.17 //	이브 2차 전직 스킬 컷인
#ifdef	EVE_SECOND_CLASS_CHANGE
	// 네메시스
	{
		CX2GUUser::SkillCutIn( L"HQ_CutIn_Eve_NM_1.dds"),// D3DXVECTOR2( 667.f, 667.f ), D3DXVECTOR3( 326.f, 446.f, 0.0f ) ),
		CX2GUUser::SkillCutIn( L"HQ_CutIn_Eve_NM_1.dds"),// D3DXVECTOR2( 667.f, 667.f ), D3DXVECTOR3( 326.f, 446.f, 0.0f ) ),
		CX2GUUser::SkillCutIn( L"HQ_CutIn_Eve_NM_1.dds"),// D3DXVECTOR2( 667.f, 667.f ), D3DXVECTOR3( 326.f, 446.f, 0.0f ) ),
	},

	// 엠프레스
	{
		CX2GUUser::SkillCutIn( L"HQ_CutIn_Eve_EP_1.dds"),// D3DXVECTOR2( 668.f, 668.f ), D3DXVECTOR3( 328.f, 432.f, 0.0f ) ),
		CX2GUUser::SkillCutIn( L"HQ_CutIn_Eve_EP_1.dds"),// D3DXVECTOR2( 668.f, 668.f ), D3DXVECTOR3( 328.f, 432.f, 0.0f ) ),
		CX2GUUser::SkillCutIn( L"HQ_CutIn_Eve_EP_1.dds"),// D3DXVECTOR2( 668.f, 668.f ), D3DXVECTOR3( 328.f, 432.f, 0.0f ) ),
	},

#endif	EVE_SECOND_CLASS_CHANGE
		//}} kimhc // 2010.2.17 //	이브 2차 전직 스킬 컷인

#ifdef SERV_EVE_BATTLE_SERAPH
		// 배틀 세라프
	{
		CX2GUUser::SkillCutIn( L"HQ_CutIn_Eve_BS_1.dds"),// D3DXVECTOR2( 668.f, 668.f ), D3DXVECTOR3( 328.f, 432.f, 0.0f ) ),
		CX2GUUser::SkillCutIn( L"HQ_CutIn_Eve_BS_1.dds"),// D3DXVECTOR2( 668.f, 668.f ), D3DXVECTOR3( 328.f, 432.f, 0.0f ) ),
		CX2GUUser::SkillCutIn( L"HQ_CutIn_Eve_BS_1.dds"),// D3DXVECTOR2( 668.f, 668.f ), D3DXVECTOR3( 328.f, 432.f, 0.0f ) ),
	},

#endif
};

CX2GUEve::CX2GUEve( int unitIndex, int teamNum, 
#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	lua_State*   pScriptLuaState,
#else	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	const WCHAR* pScriptFileName, 
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD 
	int frameBufferNum, CX2Unit* pUnit )
	:CX2GUUser( unitIndex, teamNum, 
#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	pScriptLuaState,
#else	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	pScriptFileName, 
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD 
	frameBufferNum, pUnit )
	, m_bIsWinMotion2( false )
	, m_bIsLoseMotion2( false )
#ifdef EVE_ELECTRA
	, m_EveElectraSystem( this )
#endif EVE_ELECTRA
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	, m_fEffectStartTime( 0.f )
	, m_fAddSpectrumTime( 0.f )
	, m_fAddEnergeticHeartTime( 0.f )
#endif //UPGRADE_SKILL_SYSTEM_2013
#ifdef FINALITY_SKILL_SYSTEM //김창한
	, m_bStartLinkOverChargeIllusion( false )
	, m_fFerdinandLifeTime( -1.f )
	, m_iFerdinandNPCUID( -1 )
#endif //FINALITY_SKILL_SYSTEM
#ifdef FIX_EVE_ELCRYSTAL_BUG
	, m_eReserveEndElCrystalBuffID( BTI_NONE )
	, m_bIsCheckEndElCrystal ( false )
#endif // FIX_EVE_ELCRYSTAL_BUG
#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
	, m_fDecraseInvisibilityMP ( -4.f )		
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	, m_pManeuverCore ( NULL )
	, m_iManeuverCoreLv ( 0 )
	, m_fManeuverGauge ( 0.f )
	, m_bManeuverCoreAttackLockOnNpc ( false )
	, m_iManeuverCoreAttackLockOnUid ( 0 )		
	, m_bCanParrying  ( false )		
	, m_fManeuverCoreStateTime ( 0.f )
	, m_bHyperState ( false )
	, m_hSeqHyperBall ( INVALID_PARTICLE_SEQUENCE_HANDLE )
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	, m_pManeuverCoreParryingEffect ( NULL )
#else // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	, m_hManeuverCoreParryingEffect ( INVALID_EFFECTSET_HANDLE )
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	, m_pManeuverCoreAttackDamageEffect ( NULL )
	, m_fManeuverCoreAttackParticleCreateCoolTime ( 0.f )
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	, m_wstrManeuverCoreTargetBoneName (L"")
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항

#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
{
	m_bReAttackZ1Right		= false;
	m_fReAttackZ1Time		= 0.0f;
	m_fReDashJumpXTime		= 0.0f;

	m_iJumpFlyCount			= 0;
	m_iDashJumpCount		= 0;
#ifdef EVE_ELECTRA
	m_iDashJumpUpCount		= 0;
#endif EVE_ELECTRA

	m_fCurrDashJumpTime		= 0.f;
	m_fInvisibilityTime		= s_fEveDefaultInvisibilityTime;	
	m_fSummonedLifeTime		= 0.f;	

	//{{ kimhc // 2010.2.10 //	이브 2차 전직 네메시스
#ifdef	EVE_SECOND_CLASS_CHANGE
	m_bDoneSpearBurst = false;	// 스피어 버스트가 시전 됬는지 식별 값
#endif	EVE_SECOND_CLASS_CHANGE
	//}} kimhc // 2010.2.10 //	이브 2차 전직 네메시스

	for( int i=0; i<MajorMID_END; i++ )
	{
		m_ahMajorMeshInstance[i] = INVALID_MESH_INSTANCE_HANDLE;
	}

	for( int i=0; i<MinorMID_END; i++ )
	{
		m_ahMinorMeshInstance[i] = INVALID_MESH_INSTANCE_HANDLE;
	}

	InitializeEveMajorParticleArray();
	InitializeEveMinorParticleArray();

#ifdef SKILL_BALANCE_PATCH
	m_hOberonGuard = INVALID_EFFECTSET_HANDLE;
#endif

	m_iSuccessiveHit_OneZ	= 0;
	m_vSummonedUnitBonePos = D3DXVECTOR3(0.f, 0.f, 0.f);

	for( int i = 0; i < EASI_END; ++i )
	{
		m_fEquippedActiveSkill[i] = -1;
	}
	m_fElectronBallRangeRate		= 1.f;
	m_fMPConsumeRateElectronBall	= 1.f;
	//#ifdef EVE_SECOND_CLASS_CHANGE
	// oasis907 : 김상윤 [2010.1.29] // 
	m_fAttackPowerRateElectronBall = 1.f;
	m_fForceDownValueRateElectronBall = 1.f;
	//#endif EVE_SECOND_CLASS_CHANGE

#ifdef SPECIAL_USE_ITEM
	m_fThrowStartTime		= 0.8f;
	m_vThrowStartPosOffset	= D3DXVECTOR3(40.f, 130.f, 0.f);
	m_vThrowStartVelocity	= D3DXVECTOR3(1400.f, 400.f, 0.f);
#endif SPECIAL_USE_ITEM

#ifdef EVE_ELECTRA
	m_fPlaneZAngle			= 0.f;

	m_bBlinkInvisibility	= false;
	m_fBlinkInvisibilityAlpha	= 0.f;

	m_iPhotonBoosterAdditionalDashJumpCount	= 0;
	m_fPhotonBlinkBackSpeedX				= 0.f;
	m_fPhotonBlinkDummyLifeTime				= 0.f;


#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_hEffectSweepParadeTriangle	= INVALID_DAMAGE_EFFECT_HANDLE;
	m_hEffectSweepParadeLight		= INVALID_DAMAGE_EFFECT_HANDLE;
	m_hEffectSweepParadeElectric	= INVALID_DAMAGE_EFFECT_HANDLE;
	m_hEffectElectraDashComboZ		= INVALID_DAMAGE_EFFECT_HANDLE;
	m_hEffectElectraDashComboZZ		= INVALID_DAMAGE_EFFECT_HANDLE;
	m_hEffectElectraLaserZZZfrontZ	= INVALID_DAMAGE_EFFECT_HANDLE;
	m_hEffectElectraLaserXXZ		= INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectSweepParadeTriangle		= NULL;
	m_EffectSweepParadeLight		= NULL;
	m_EffectSweepParadeElectric		= NULL;
	m_EffectElectraDashComboZ		= NULL;
	m_EffectElectraDashComboZZ		= NULL;
	m_EffectElectraLaserZZZfrontZ	= NULL;
	m_EffectElectraLaserXXZ			= NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_fSweepParadeTriangleLIfeTime	= 0.f;
	m_fInitDamageSweepParade		= 0.f;

	m_hElectraDashComboZMesh		= INVALID_MESH_INSTANCE_HANDLE;
	//m_hElectraDashComboZMeshZZ	= INVALID_MESH_INSTANCE_HANDLE;

	m_bXXZLaserEnd			= false;
	m_bNotEnoughMPZZZfrontZLaser	= false;
	m_bNotEnoughMPXXZLaser			= false;
	m_bNotEnoughMPDashZZZ			= false;
	m_bLockOnNpc			= false;
	m_iLockOnUid			= -1;

#ifdef BALANCE_PATCH_20120329
	m_hCountDownThousandStar	= INVALID_PARTICLE_SEQUENCE_HANDLE;
#endif BALANCE_PATCH_20120329
	m_bDelayAttackThousandStar	= false;
	m_fDelayAttackTime			= 0.f;
	m_fThousandStarAttackTime	= 0.f;
	m_fElapsedTimeThousandStartCreated	= 0.f;
	m_fThousandStarPowerRate	= 0.f;

	m_bEntireFireMode			= false;

	m_fDelayAttackTimeEntireFire	= 0.f;

	m_iThousandStarCount			=  0;

	m_pThousandStar				= NULL;
#endif EVE_ELECTRA

#ifdef SERV_EVE_BATTLE_SERAPH
	m_bAfterJumpDash		= false;
	m_bEnableBoostDash		= false;
	m_eBoostDashState		= BDS_NONE;

	m_bHighPoweredElectrics			= false;
	m_fHighPoweredElectricsSpeed	= 0.f;
	m_iAccumulateAccel				= 0;

	m_bDashJumpXXLaserEnd			= false;
	m_bNotEnoughMPDashJumpXZLaser	= false;
	m_bExceptionPlane				= false;
	m_fExceptioncPlaneZAngle		= 0.f;
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectElectraLaserDashJumpXZ	= INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectElectraLaserDashJumpXZ	= NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

	m_hBoostDashParticle	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	//m_hBoostDashMesh		= INVALID_MESH_INSTANCE_HANDLE;

	m_bNotEnoughMPDashJumpZX	= false;
	m_iBoostAttackCount			= 0;
	m_bBoostUpAttack			= false;
	m_iAddBoostAttack			= 0;
	m_hEffectEnergeticHeart		= INVALID_EFFECTSET_HANDLE;
#endif

#ifdef FIX_SPECTRO_EL_CRYSTAL_ACTIVE_BUG
	m_bStartSpectroElCrystal = false;		/// 분광결정이 스킬을 눌러 시작 되었는지, 버프로 시작 되었는지에 대한 여부
#endif FIX_SPECTRO_EL_CRYSTAL_ACTIVE_BUG

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	INIT_VECTOR3( m_vSonicGunRotate, 0.f, 0.f, 0.f );
#endif //UPGRADE_SKILL_SYSTEM_2013
}

CX2GUEve::~CX2GUEve(void)
{
#ifdef EVE_ELECTRA
	ClearThousandStar();
#endif EVE_ELECTRA

#ifdef EVE_FIRST_CHANGE_JOB
	m_sEGQueensThrone.Reset();
#endif EVE_FIRST_CHANGE_JOB

	for( int i=0; i<MajorMID_END; i++ )
	{
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle( m_ahMajorMeshInstance[i] );
	}

	for( int i=0; i<MinorMID_END; i++ )
	{
		g_pX2Game->GetMinorXMeshPlayer()->DestroyInstanceHandle( m_ahMinorMeshInstance[i] );
	}

	DeleteEveMajorParticle();
	DeleteEveMinorParticle();

#ifdef SKILL_BALANCE_PATCH
	g_pX2Game->GetEffectSet()->StopEffectSet( m_hOberonGuard );
#endif

	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE );
#ifdef SERV_SKILL_NOTE
	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE_MEMO );
#endif

	//{{ JHKang / 강정훈 / 2010/11/23 / 아토믹 쉴드
#ifdef NEW_SKILL_2010_11
	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_ATOMIC_SHIELD_EVE );	/// 아토믹 쉴드 소환 해제
#endif NEW_SKILL_2010_11
	//}} JHKang / 강정훈 / 2010/11/23 / 아토믹 쉴드
#ifdef FINALITY_SKILL_SYSTEM //김창한
	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_SI_HA_FERDINAND );
#endif //FINALITY_SKILL_SYSTEM

	g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_Condense_power.ogg" );
	g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_FullCharge.ogg" );	

#ifdef SERV_EVE_BATTLE_SERAPH
	if ( INVALID_EFFECTSET_HANDLE != m_hEffectEnergeticHeart  )
	{
		g_pX2Game->GetEffectSet()->StopEffectSet( m_hEffectEnergeticHeart );
	}

	m_EveElectraSystem.m_fFormationSetElapsedTime = 0.f;

	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticlePlane );

	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleFormationMark[0] );
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleFormationMark[1] );
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleFormationMark[2] );

	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleFormationMsg[0] );
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleFormationMsg[1] );
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleFormationMsg[2] );

	m_EveElectraSystem.SetSystemOperationTime( 0.f );
	m_EveElectraSystem.SetExceptionSystemTime( 0.f );
	m_EveElectraSystem.SetPlaneFormation( PFT_NONE );
	m_EveElectraSystem.SetEnableSystem( false );
#endif

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	ClearManeuverCore( true );
	// SetFullHyperMode( false );
	if( m_hSeqHyperBall != INVALID_PARTICLE_SEQUENCE_HANDLE )
	{
		g_pX2Game->GetMajorParticle()->DestroyInstanceHandle(m_hSeqHyperBall);
	}

#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	if ( NULL != g_pX2Game->GetDamageEffect() && NULL != m_pManeuverCoreParryingEffect )
	{
		g_pX2Game->GetDamageEffect()->DestroyInstance( m_pManeuverCoreParryingEffect );
	}
#else  FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	if ( m_hManeuverCoreParryingEffect != INVALID_EFFECTSET_HANDLE )
	{
		g_pX2Game->GetEffectSet()->DestroyInstanceHandle( m_hManeuverCoreParryingEffect );
	}
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항

	if ( m_pManeuverCoreAttackDamageEffect != NULL )
	{
		g_pX2Game->GetDamageEffect()->DestroyInstance( m_pManeuverCoreAttackDamageEffect );
	}

#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
}

void CX2GUEve::ReInit( bool bRandom, int startPosIndex )
{
	CX2GUUser::ReInit( bRandom, startPosIndex );
	m_fReDashJumpXTime		= 0.0f;

	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE );
#ifdef SERV_SKILL_NOTE
	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE_MEMO );
#endif

	//{{ JHKang / 강정훈 / 2010/11/23 / 아토믹 쉴드
#ifdef NEW_SKILL_2010_11
	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_ATOMIC_SHIELD_EVE );	/// 아토믹 쉴드 소환 해제
#endif NEW_SKILL_2010_11
	//}} JHKang / 강정훈 / 2010/11/23 / 아토믹 쉴드
#ifdef FINALITY_SKILL_SYSTEM //김창한
	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_SI_HA_FERDINAND );
#endif //FINALITY_SKILL_SYSTEM

#ifdef EVE_ELECTRA
	ClearThousandStar();
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( m_hEffectSweepParadeTriangle != INVALID_DAMAGE_EFFECT_HANDLE )
        g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_hEffectSweepParadeTriangle );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	if( m_EffectSweepParadeTriangle != NULL )
		g_pX2Game->GetDamageEffect()->DestroyInstance( m_EffectSweepParadeTriangle );
    m_EffectSweepParadeTriangle = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
#endif EVE_ELECTRA

#ifdef SERV_EVE_BATTLE_SERAPH
	if ( INVALID_EFFECTSET_HANDLE != m_hEffectEnergeticHeart  )
	{
		g_pX2Game->GetEffectSet()->StopEffectSet( m_hEffectEnergeticHeart );
	}

	m_EveElectraSystem.m_fFormationSetElapsedTime = 0.f;

	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticlePlane );

	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleFormationMark[0] );
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleFormationMark[1] );
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleFormationMark[2] );

	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleFormationMsg[0] );
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleFormationMsg[1] );
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleFormationMsg[2] );

	m_EveElectraSystem.SetSystemOperationTime( 0.f );
	m_EveElectraSystem.SetExceptionSystemTime( 0.f );

	m_EveElectraSystem.SetPlaneFormation( PFT_NONE );

	if ( IsMyUnit() )
		g_pX2Game->UpdateSkillSlotUI();

	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet(CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL);
	if( NULL != pSkillTemplet )
		const_cast<CX2SkillTree::SkillTemplet*>(pSkillTemplet)->m_eActiveSkillUseCondtion = CX2SkillTree::ASUT_GROUND;

	m_EveElectraSystem.SetEnableSystem( false );
#endif

#ifdef FIX_SPECTRO_EL_CRYSTAL_ACTIVE_BUG
	m_bStartSpectroElCrystal = false;		/// 분광결정이 스킬을 눌러 시작 되었는지, 버프로 시작 되었는지에 대한 여부
#endif FIX_SPECTRO_EL_CRYSTAL_ACTIVE_BUG


#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	m_pManeuverCore = NULL;
	m_iManeuverCoreLv = 0;
	m_fManeuverGauge = 0.f;
	m_bManeuverCoreAttackLockOnNpc = false;
	m_iManeuverCoreAttackLockOnUid = 0;		
	m_bCanParrying  = false;		
	m_fManeuverCoreStateTime = 0.f;
	m_bHyperState = false;

#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	if ( m_pManeuverCoreParryingEffect != NULL )
	{
		g_pX2Game->GetDamageEffect()->DestroyInstance( m_pManeuverCoreParryingEffect );
	}
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항	
	if ( m_hManeuverCoreParryingEffect != INVALID_EFFECTSET_HANDLE )
	{
		g_pX2Game->GetEffectSet()->DestroyInstanceHandle( m_hManeuverCoreParryingEffect );
	}
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항	

#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
}


#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
/*static*/
void	CX2GUEve::AppendDeviceToDeviceList( CKTDXDeviceDataList& listInOut_ )
{
}
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD

void CX2GUEve::DamageReact( CX2DamageManager::DamageData* pDamageData )
{
	KTDXPROFILE();
	CX2GUUser::DamageReact( pDamageData );
	CX2GUUser::DamageReactStateChange( pDamageData );

#ifdef FINALITY_SKILL_SYSTEM //김창한
	if( -1 < m_iFerdinandNPCUID )
	{
		CX2GUNPC* pFerdinand = g_pX2Game->GetNPCUnitByUID( m_iFerdinandNPCUID );
		if( NULL != pFerdinand && pFerdinand->GetDyingStart() != true )
		{
			D3DXVECTOR3 vecMyDir = GetDirVector();
			D3DXVECTOR3 vecMyPos = GetPos();
			bool bMyIsRight = GetIsRight();

			vecMyPos.x += ( vecMyDir.x * 20.f );

			pFerdinand->SetPosition(vecMyPos, bMyIsRight);
			pFerdinand->StateChange( "FERDINAND_ATTACK_A_EMERGENCY", true );
		}
	}
#endif //FINALITY_SKILL_SYSTEM

#ifdef BALANCE_PATCH_20120329
	m_fInvisibilityTime = 0.f;
#endif
}

/*virtual*/ void CX2GUEve::AttackResultPlayEffect()
{
	CX2GUUser::AttackResultPlayEffect();

	//{{ kimhc // 2010.02.10 //	네메시스 패시브 나소드 기어 강화
#ifdef	EVE_SECOND_CLASS_CHANGE
	if ( DidHitNasodWeapon() == true &&
		g_pX2Game != NULL &&
		g_pX2Game->GetEffectSet() != NULL )
	{
		g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Eve_NasodWeapon", static_cast< CX2GameUnit* >( this ),
			NULL, false, -1.f, -1.f, D3DXVECTOR3( 1, 1, 1 ), true, m_DamageData.impactPoint );
		SetHitNasodWeapon( false );
	}

#endif	EVE_SECOND_CLASS_CHANGE
	//}} kimhc // 2010.1.28 //	네메시스 패시브 나소드 기어 강화
}


void CX2GUEve::Win()
{
	CX2GUUser::Win();

#ifdef RIDING_SYSTEM
	if ( true == GetRidingOn() && NULL != m_ptrRidingPet )
		StateChange( USI_RIDING_WAIT_HABIT );
	else
		StateChange( USI_WIN );
#else
	StateChange( USI_WIN );
#endif //RIDING_SYSTEM
}

void CX2GUEve::Lose()
{
	CX2GUUser::Lose();

	if( IsMyUnit() == true && 
		GetNowHp() > 0.0f )
	{
#ifdef RIDING_SYSTEM
		if ( true == GetRidingOn() && NULL != m_ptrRidingPet )
			StateChange( USI_RIDING_WAIT );
		else
			StateChange( USI_LOSE );
#else
		StateChange( USI_LOSE );
#endif //RIDING_SYSTEM
	}
}

void CX2GUEve::Draw()
{
	CX2GUUser::Draw();

#ifdef RIDING_SYSTEM
	if ( true == GetRidingOn() && NULL != m_ptrRidingPet )
		StateChange( USI_RIDING_WAIT_HABIT );
	else
		StateChange( USI_WIN );
#else
	StateChange( USI_WIN );
#endif //RIDING_SYSTEM
}


void CX2GUEve::ParseCommonRandomState()
{
	if( true == m_LuaManager.BeginTable( "INIT_COMMON_RANDOM_STATE" ) )
	{

		const char* tableName = "";
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_NASOD:
			{
				tableName = "EVE_NASOD";
			} break;

		case CX2Unit::UC_EVE_EXOTIC_GEAR:
			{
				tableName = "EVE_EXOTIC_GEAR";
			} break;


		case CX2Unit::UC_EVE_ARCHITECTURE:
			{
				tableName = "EVE_ARCHITECTURE";
			} break;

		case CX2Unit::UC_EVE_CODE_NEMESIS:
			{
				tableName = "UC_EVE_CODE_NEMESIS";
			} break;


		case CX2Unit::UC_EVE_CODE_EMPRESS:
			{
				tableName = "UC_EVE_CODE_EMPRESS";
			} break;
#ifdef EVE_ELECTRA
		case CX2Unit::UC_EVE_ELECTRA:
			{
				tableName = "UC_EVE_ELECTRA";
			} break;
#endif EVE_ELECTRA
#ifdef SERV_EVE_BATTLE_SERAPH
		case CX2Unit::UC_EVE_BATTLE_SERAPH:
			{
				tableName = "UC_EVE_BATTLE_SERAPH";
			} break;
#endif
		default:
			{
				ASSERT( !"NO" );
			} break;
		}

		CX2GUUser::ParseCommonRandomState(tableName);

		m_LuaManager.EndTable(); // INIT_COMMON_RANDOM_STATE
	}
}



void CX2GUEve::InitStateID()
{
	m_CommonState.m_Wait	= USI_WAIT;
	m_ChargeMpState			= USI_WAIT;

//#ifdef PVP_BOSS_COMBAT_TEST
//
//	m_FrozenState = ENSI_FROZEN;
//
//#endif PVP_BOSS_COMBAT_TEST


//#ifdef TRANSFORMER_TEST
//	m_CommonState.m_Transformed			= ENSI_TRANSFORMED;
//#endif TRANSFORMER_TEST

}

void CX2GUEve::InitStateCommon()
{
	UserUnitStateData stateData;

	stateData.Init();
	stateData.stateID			= USI_DIE_FRONT;
	m_LuaManager.MakeTableReference( "ENSI_DIE_FRONT", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_DIE_FRONT_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DIE_FRONT_Start );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DIE_FRONT_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DIE_FRONT_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DIE_BACK;
	m_LuaManager.MakeTableReference( "ENSI_DIE_BACK", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_DIE_BACK_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DIE_BACK_Start );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DIE_BACK_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DIE_BACK_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_START_INTRUDE;
	m_LuaManager.MakeTableReference( "ENSI_START_INTRUDE", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, StartIntrudeStart );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUUser, StartIntrudeFrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, StartIntrudeEventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_WAIT;
	m_LuaManager.MakeTableReference( "ENSI_WAIT", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_WAIT_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_WAIT_Start );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_WAIT_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_WALK;
	m_LuaManager.MakeTableReference( "ENSI_WALK", stateData.stateID );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, WalkFrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_WALK_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_JUMP_READY;
	m_LuaManager.MakeTableReference( "ENSI_JUMP_READY", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_READY_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_JUMP_UP;
	m_LuaManager.MakeTableReference( "ENSI_JUMP_UP", stateData.stateID );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, JumpFrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_UP_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_JUMP_DOWN;
	m_LuaManager.MakeTableReference( "ENSI_JUMP_DOWN", stateData.stateID );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, JumpFrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_DOWN_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_JUMP_LANDING;
	m_LuaManager.MakeTableReference( "ENSI_JUMP_LANDING", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_LANDING_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, JumpLandingStart );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_LANDING_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DASH;
	m_LuaManager.MakeTableReference( "ENSI_DASH", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, DashStartFuture );	// Override
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, DashStart );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, DashFrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DASH_END;
	m_LuaManager.MakeTableReference( "ENSI_DASH_END", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_END_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_END_Start );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_END_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_END_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DASH_JUMP;
	m_LuaManager.MakeTableReference( "ENSI_DASH_JUMP", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_Start );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_FrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_EventProcess );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_EndFuture );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DASH_JUMP_LANDING;
	m_LuaManager.MakeTableReference( "ENSI_DASH_JUMP_LANDING", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, DashJumpLandingStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, JumpLandingStart );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_LANDING_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_DASH_JUMP_POWER_LANDING;
	m_LuaManager.MakeTableReference( "ENSI_DASH_JUMP_POWER_LANDING", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_POWER_LANDING_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_POWER_LANDING_Start );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_POWER_LANDING_EventProcess );
	m_StateList[stateData.stateID] = stateData;




	stateData.Init();
	stateData.stateID			= ENSI_JUMP_FLY_UP;
	m_LuaManager.MakeTableReference( "ENSI_JUMP_FLY_UP", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_FLY_UP_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_FLY_UP_Start );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_FLY_UP_FrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_FLY_UP_EventProcess );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_FLY_UP_EndFuture );
	m_StateList[stateData.stateID] = stateData;



	stateData.Init();
	stateData.stateID			= ENSI_JUMP_FLY_DOWN;
	m_LuaManager.MakeTableReference( "ENSI_JUMP_FLY_DOWN", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_FLY_DOWN_StartFuture );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_FLY_DOWN_FrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_FLY_DOWN_EventProcess );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_FLY_DOWN_EndFuture );
	m_StateList[stateData.stateID] = stateData;





	stateData.Init();
	stateData.stateID			= ENSI_JUMP_DASH;
	m_LuaManager.MakeTableReference( "ENSI_JUMP_DASH", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_DASH_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_DASH_Start );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_DASH_FrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_DASH_EventProcess );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_DASH_EndFuture );
	m_StateList[stateData.stateID] = stateData;



	stateData.Init();
	stateData.stateID			= USI_HYPER_MODE;
	m_LuaManager.MakeTableReference( "ENSI_HYPER_MODE", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, HyperModeStart );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, HyperModeFrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, HyperModeEventProcess );
#ifdef HYPER_MODE_FIX
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, HyperModeStartFuture );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUUser, HyperModeEnd );
#endif HYPER_MODE_FIX
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_GROGGY;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_GROGGY", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, DAMAGE_GROGGY_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_SMALL_FRONT;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_SMALL_FRONT", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DAMAGE_SMALL_FRONT_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_SMALL_BACK;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_SMALL_BACK", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DAMAGE_SMALL_BACK_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_BIG_FRONT;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_BIG_FRONT", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DAMAGE_BIG_FRONT_Start );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DAMAGE_BIG_FRONT_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_BIG_BACK;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_BIG_BACK", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DAMAGE_BIG_BACK_Start );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DAMAGE_BIG_BACK_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_DOWN_FRONT;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_DOWN_FRONT", stateData.stateID );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DAMAGE_DOWN_FRONT_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DAMAGE_DOWN_FRONT_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_DOWN_BACK;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_DOWN_BACK", stateData.stateID );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DAMAGE_DOWN_BACK_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DAMAGE_DOWN_BACK_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_STANDUP_FRONT;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_STANDUP_FRONT", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, DamageStandUpEventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUUser, DamageStandUpEnd );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_STANDUP_BACK;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_STANDUP_BACK", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, DamageStandUpEventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUUser, DamageStandUpEnd );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_AIR_SMALL;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_AIR_SMALL", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, DamageAirSmallStartFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, DamageAirSmallEventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_AIR_DOWN;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_AIR_DOWN", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, DamageAirDownEventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_AIR_DOWN_INVINCIBLE;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_AIR_DOWN_INVINCIBLE", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, DamageAirDownInvincibleEventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_AIR_DOWN_LANDING;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_AIR_DOWN_LANDING", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, DamageAirDownLandingStart );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUUser, DamageAirDownLandingFrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DAMAGE_AIR_DOWN_LANDING_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_AIR_FALL;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_AIR_FALL", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, DamageAirFallEventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_AIR_UP;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_AIR_UP", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, DamageAirUpEventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_AIR_FLY_FRONT;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_AIR_FLY_FRONT", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, DamageAirFlyEventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_AIR_FLY_BACK;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_AIR_FLY_BACK", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, DamageAirFlyEventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_DAMAGE_REVENGE;
	m_LuaManager.MakeTableReference( "ENSI_DAMAGE_REVENGE", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, DamageRevengeStart );
	stateData.OnCameraMove		= SET_CB_FUNC( CX2GUUser, DamageRevengeCameraMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, DamageRevengeEventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_STANDUP_ROLLING_FRONT_FRONT;
	m_LuaManager.MakeTableReference( "ENSI_STANDUP_ROLLING_FRONT_FRONT", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ROLLING_FRONT_FRONT_EventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ROLLING_FRONT_FRONT_End );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_STANDUP_ROLLING_FRONT_BACK;
	m_LuaManager.MakeTableReference( "ENSI_STANDUP_ROLLING_FRONT_BACK", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ROLLING_FRONT_BACK_EventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ROLLING_FRONT_BACK_End );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_STANDUP_ROLLING_BACK_FRONT;
	m_LuaManager.MakeTableReference( "ENSI_STANDUP_ROLLING_BACK_FRONT", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ROLLING_BACK_FRONT_EventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ROLLING_BACK_FRONT_End );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_STANDUP_ROLLING_BACK_BACK;
	m_LuaManager.MakeTableReference( "ENSI_STANDUP_ROLLING_BACK_BACK", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ROLLING_BACK_BACK_EventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ROLLING_BACK_BACK_End );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_STANDUP_ATTACK_FRONT;
	m_LuaManager.MakeTableReference( "ENSI_STANDUP_ATTACK_FRONT", stateData.stateID );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ATTACK_FRONT_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ATTACK_FRONT_EventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ATTACK_FRONT_End );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_STANDUP_ATTACK_BACK;
	m_LuaManager.MakeTableReference( "ENSI_STANDUP_ATTACK_BACK", stateData.stateID );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ATTACK_BACK_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ATTACK_BACK_EventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_STANDUP_ATTACK_BACK_End );
	m_StateList[stateData.stateID] = stateData;


	stateData.Init();
	stateData.stateID			= ENSI_COMBO_Z;
	m_LuaManager.MakeTableReference( "ENSI_COMBO_Z", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_Z_Start );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_Z_End );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_Z_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_Z_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_COMBO_ZZ;
	m_LuaManager.MakeTableReference( "ENSI_COMBO_ZZ", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZ_Start );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZ_End );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZ_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZ_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_COMBO_ZZZ;
	m_LuaManager.MakeTableReference( "ENSI_COMBO_ZZZ", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZ_Start );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZ_End );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZ_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZ_EventProcess );
	m_StateList[stateData.stateID] = stateData;


	stateData.Init();
	stateData.stateID			= ENSI_COMBO_ZZZZ;
	m_LuaManager.MakeTableReference( "ENSI_COMBO_ZZZZ", stateData.stateID );
	//stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZZ_FrameMoveFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZZ_Start );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZZ_End );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZZ_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZZ_EventProcess );
	m_StateList[stateData.stateID] = stateData;


	stateData.Init();
	stateData.stateID			= ENSI_COMBO_ZZZX;
	m_LuaManager.MakeTableReference( "ENSI_COMBO_ZZZX", stateData.stateID );
	//stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZX_Start );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZX_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZX_EventProcess );
	m_StateList[stateData.stateID] = stateData;



	stateData.Init();
	stateData.stateID			= ENSI_COMBO_ZZZdownZ;
	m_LuaManager.MakeTableReference( "ENSI_COMBO_ZZZdownZ", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZdownZ_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZdownZ_Start );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZdownZ_End );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZdownZ_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZdownZ_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_COMBO_X;
	m_LuaManager.MakeTableReference( "ENSI_COMBO_X", stateData.stateID );
#ifdef EVE_ELECTRA
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_X_Start );
#endif EVE_ELECTRA
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_X_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_X_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_COMBO_XX;
	m_LuaManager.MakeTableReference( "ENSI_COMBO_XX", stateData.stateID );
#ifdef EVE_ELECTRA
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XX_Start );
#endif EVE_ELECTRA
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XX_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XX_EventProcess );
	m_StateList[stateData.stateID] = stateData;


	stateData.Init();
	stateData.stateID			= ENSI_COMBO_XXX;
	m_LuaManager.MakeTableReference( "ENSI_COMBO_XXX", stateData.stateID );
#ifdef EVE_ELECTRA
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXX_Start );
#endif EVE_ELECTRA
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXX_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXX_EventProcess );
	m_StateList[stateData.stateID] = stateData;

#ifdef EVE_ELECTRA
	stateData.Init();
	stateData.stateID			= ENSI_COMBO_XXfrontX;
	m_LuaManager.MakeTableReference( "ENSI_COMBO_XXfrontX", stateData.stateID );
	//stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXfrontX_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXfrontX_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_COMBO_XXdownX;
	m_LuaManager.MakeTableReference( "ENSI_COMBO_XXdownX", stateData.stateID );
	//stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXdownX_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXdownX_EventProcess );
	m_StateList[stateData.stateID] = stateData;
#endif

	stateData.Init();
	stateData.stateID			= ENSI_DASH_COMBO_Z;
	m_LuaManager.MakeTableReference( "ENSI_DASH_COMBO_Z", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_Z_Start );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_Z_End );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_Z_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_Z_EventProcess );
	m_StateList[stateData.stateID] = stateData;


	stateData.Init();
	stateData.stateID			= ENSI_DASH_COMBO_X;
	m_LuaManager.MakeTableReference( "ENSI_DASH_COMBO_X", stateData.stateID );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_X_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_X_EventProcess );
	m_StateList[stateData.stateID] = stateData;


	stateData.Init();
	stateData.stateID			= ENSI_JUMP_COMBO_Z;
	m_LuaManager.MakeTableReference( "ENSI_JUMP_COMBO_Z", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_COMBO_Z_Start );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_COMBO_Z_End );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_COMBO_Z_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_COMBO_Z_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_JUMP_COMBO_X;
	m_LuaManager.MakeTableReference( "ENSI_JUMP_COMBO_X", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_COMBO_X_Start );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_COMBO_X_End );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_COMBO_X_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_COMBO_X_EventProcess );
	m_StateList[stateData.stateID] = stateData;


	stateData.Init();
	stateData.stateID			= ENSI_JUMP_COMBO_X_LANDING;
	m_LuaManager.MakeTableReference( "ENSI_JUMP_COMBO_X_LANDING", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_COMBO_X_LANDING_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_COMBO_X_LANDING_Start );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_JUMP_COMBO_X_LANDING_EventProcess );
	m_StateList[stateData.stateID] = stateData;


	stateData.Init();
	stateData.stateID			= ENSI_DASH_JUMP_COMBO_Z;
	m_LuaManager.MakeTableReference( "ENSI_DASH_JUMP_COMBO_Z", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_Z_Start );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_Z_End );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_Z_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_Z_EventProcess );
	m_StateList[stateData.stateID] = stateData;


	stateData.Init();
	stateData.stateID			= ENSI_DASH_JUMP_COMBO_ZZ;
	m_LuaManager.MakeTableReference( "ENSI_DASH_JUMP_COMBO_ZZ", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_ZZ_Start );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_ZZ_End );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_ZZ_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_ZZ_EventProcess );
	m_StateList[stateData.stateID] = stateData;



	stateData.Init();
	stateData.stateID			= ENSI_DASH_JUMP_COMBO_ZZZ;
	m_LuaManager.MakeTableReference( "ENSI_DASH_JUMP_COMBO_ZZZ", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_ZZZ_Start );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_ZZZ_End );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_ZZZ_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_ZZZ_EventProcess );
	m_StateList[stateData.stateID] = stateData;


	stateData.Init();
	stateData.stateID			= ENSI_DASH_JUMP_COMBO_X;
	m_LuaManager.MakeTableReference( "ENSI_DASH_JUMP_COMBO_X", stateData.stateID );
	//stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_X_Init );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_X_Start );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_X_End );
	//stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_X_FrameMoveFuture );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_X_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_X_EventProcess );
	m_StateList[stateData.stateID] = stateData;

#ifdef WALL_JUMP_TEST
	stateData.Init();
	stateData.stateID			= ENSI_WALL_LANDING;
	m_LuaManager.MakeTableReference( "ENSI_WALL_LANDING", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, WallLandingEventProcess );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUUser, WallLandingEndFuture );
	m_StateList[stateData.stateID] = stateData;
#endif WALL_JUMP_TEST


	stateData.Init();
	stateData.stateID			= USI_PEPPER_RUN_READY;
	m_LuaManager.MakeTableReference( "ENSI_PEPPER_RUN_READY", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, PEPPER_RUN_READY_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_PEPPER_RUN;
	m_LuaManager.MakeTableReference( "ENSI_PEPPER_RUN", stateData.stateID );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, PEPPER_RUN_FrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, PEPPER_RUN_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_PEPPER_RUN_END;
	m_LuaManager.MakeTableReference( "ENSI_PEPPER_RUN_END", stateData.stateID );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUUser, PEPPER_RUN_END_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, PEPPER_RUN_END_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_PEPPER_RUN_JUMP_UP;
	m_LuaManager.MakeTableReference( "ENSI_PEPPER_RUN_JUMP_UP", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, PEPPER_RUN_JUMP_UP_StateStartFuture );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, PEPPER_RUN_JUMP_UP_FrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, PEPPER_RUN_JUMP_UP_EventProcess );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= USI_PEPPER_RUN_JUMP_DOWN;
	m_LuaManager.MakeTableReference( "ENSI_PEPPER_RUN_JUMP_DOWN", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, PEPPER_RUN_JUMP_DOWN_StateStartFuture );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, PEPPER_RUN_JUMP_DOWN_FrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, PEPPER_RUN_JUMP_DOWN_EventProcess );
	m_StateList[stateData.stateID] = stateData;

#ifdef SPECIAL_USE_ITEM
	stateData.Init();
	stateData.stateID			= USI_THROW_ITEM;
	m_LuaManager.MakeTableReference( "ENSI_THROW_ITEM", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, THROW_ITEM_StateStart );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, THROW_ITEM_FrameMoveFuture );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUUser, THROW_ITEM_FrameMove );
	stateData.OnCameraMove		= SET_CB_FUNC( CX2GUUser, THROW_ITEM_CameraMove );		
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, THROW_ITEM_EventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUUser, THROW_ITEM_StateEnd );
	m_StateList[stateData.stateID] = stateData;
#endif SPECIAL_USE_ITEM

#ifdef RIDING_SYSTEM
	#pragma region ENSI_RIDING_START
	stateData.Init();
	stateData.stateID			= GetRidingStartStateID();
	m_LuaManager.MakeTableReference( "ENSI_RIDING_START", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingStartStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingStartStart );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingStartEventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUUser, StartEnd );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_ON
	stateData.Init();
	stateData.stateID			= USI_RIDING_ON;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_ON", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingOnStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingOnStart );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingOnEventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUUser, RidingOnEnd );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_OFF
	stateData.Init();
	stateData.stateID			= USI_RIDING_OFF;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_OFF", stateData.stateID );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingOffEventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUUser, RidingOffEnd );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_WAIT_HABIT
	stateData.Init();
	stateData.stateID			= USI_RIDING_WAIT_HABIT;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_WAIT_HABIT", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingWaitHabitStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingWaitHabitStart );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingWaitHabitEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_WAIT
	stateData.Init();
	stateData.stateID			= USI_RIDING_WAIT;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_WAIT", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingWaitStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingWaitStart );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingWaitEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_WALK
	stateData.Init();
	stateData.stateID			= USI_RIDING_WALK;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_WALK", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingWalkStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingWalkStart );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, WalkFrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingWalkEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion
	
	#pragma region ENSI_RIDING_JUMP_UP
	stateData.Init();
	stateData.stateID			= USI_RIDING_JUMP_UP;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_JUMP_UP", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingJumpUpStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingJumpUpStart );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, JumpFrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingJumpUpEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_JUMP_DOWN
	stateData.Init();
	stateData.stateID			= USI_RIDING_JUMP_DOWN;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_JUMP_DOWN", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingJumpDownStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingJumpDownStart );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, JumpFrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingJumpDownEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_JUMP_LANDING
	stateData.Init();
	stateData.stateID			= USI_RIDING_JUMP_LANDING;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_JUMP_LANDING", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingJumpLandingStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingJumpLandingStart );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingJumpLandingEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_DASH
	stateData.Init();
	stateData.stateID			= USI_RIDING_DASH;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_DASH", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, DashStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingDashStart );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, DashFrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingDashEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_DASH_END
	stateData.Init();
	stateData.stateID			= USI_RIDING_DASH_END;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_DASH_END", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingDashEndStart );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingDashEndStartFuture );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUUser, RidingDashEndFrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingDashEndEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_DASH_JUMP
	stateData.Init();
	stateData.stateID			= USI_RIDING_DASH_JUMP;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_DASH_JUMP", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingDashJumpStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingDashJumpStart );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, RidingDashJumpFrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingDashJumpEventProcess );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUUser, RidingDashJumpEndFuture );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_DASH_JUMP_LANDING
	stateData.Init();
	stateData.stateID			= USI_RIDING_DASH_JUMP_LANDING;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_DASH_JUMP_LANDING", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, DashJumpLandingStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingDashJumpLandingStart );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingDashJumpLandingEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_DAMAGE_FRONT
	stateData.Init();
	stateData.stateID			= USI_RIDING_DAMAGE_FRONT;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_DAMAGE_FRONT", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingDamageFrontStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingDamageFrontStart );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingDamageFrontEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_DAMAGE_BACK
	stateData.Init();
	stateData.stateID			= USI_RIDING_DAMAGE_BACK;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_DAMAGE_BACK", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingDamageBackStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingDamageBackStart );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingDamageBackEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_DIE
	stateData.Init();
	stateData.stateID			= USI_RIDING_DIE;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_DIE", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_DIE_FRONT_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DIE_FRONT_Start );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DIE_FRONT_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DIE_FRONT_EventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_ATTACK_Z
	stateData.Init();
	stateData.stateID			= USI_RIDING_ATTACK_Z;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_ATTACK_Z", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingAttackZStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingAttackZStart );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingAttackZEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_JUMP_ATTACK_Z
	stateData.Init();
	stateData.stateID			= USI_RIDING_JUMP_ATTACK_Z;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_JUMP_ATTACK_Z", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingJumpAttackZStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingJumpAttackZStart );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, RidingJumpAttackZFrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingJumpAttackZEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_ATTACK_X
	stateData.Init();
	stateData.stateID			= USI_RIDING_ATTACK_X;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_ATTACK_X", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingAttackXStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingAttackXStart );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingAttackXEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_SPECIAL_ATTACK
	stateData.Init();
	stateData.stateID			= USI_RIDING_SPECIAL_ATTACK;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_ATTACK_SPECIAL", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingSpecialAttackStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingSpecialAttackStart );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUUser, RidingSpecialAttackFrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingSpecialAttackEventProcess );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion

	#pragma region ENSI_RIDING_SPECIAL_MOVE
	stateData.Init();
	stateData.stateID			= USI_RIDING_SPECIAL_MOVE;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_SPECIAL_MOVE", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingSpecialMoveStartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingSpecialMoveStart );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUUser, RidingSpecialMoveFrameMoveFuture );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUUser, RidingSpecialMoveFrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingSpecialMoveEventProcess );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUUser, RidingSpecialMoveEndFutrue );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUUser, RidingSpecialMoveEnd );
	m_StateList[stateData.stateID] = stateData;
	#pragma endregion
#endif //RIDING_SYSTEM

#ifdef MODIFY_RIDING_PET_AWAKE
	stateData.Init();
	stateData.stateID			= USI_RIDING_HYPER_MODE;
	m_LuaManager.MakeTableReference( "ENSI_RIDING_HYPER_MODE", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, RidingHyperModeStart );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, RidingHyperModeFrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, RidingHyperModeEventProcess );
#ifdef HYPER_MODE_FIX
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, RidingHyperModeStartFuture );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUUser, RidingHyperModeEnd );
#endif HYPER_MODE_FIX
	m_StateList[stateData.stateID] = stateData;
#endif // MODIFY_RIDING_PET_AWAKE

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	// Small 데미지에 반응하는 Parrying State
	stateData.Init();
	stateData.stateID			= ENSI_PARRYING_SMALL;
	m_LuaManager.MakeTableReference( "ENSI_PARRYING_SMALL", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_Start );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_EventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_StateEnd ); 
	m_StateList[stateData.stateID] = stateData;

	// Small 이 아닌 데미지에 반응하는 Parrying State
	stateData.Init();
	stateData.stateID			= ENSI_PARRYING;
	m_LuaManager.MakeTableReference( "ENSI_PARRYING", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_Start );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_EventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_StateEnd );	
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_PARRYING_BLINK;
	m_LuaManager.MakeTableReference( "ENSI_PARRYING_BLINK", stateData.stateID );

	// Parrying 중 Z 혹은 X 키로 변경되는 점멸 State
	stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_BLINK_Init );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_BLINK_Start );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_BLINK_StartFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_BLINK_EventProcess );
	stateData.OnFrameMoveFuture = SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_BLINK_FrameMoveFuture );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_BLINK_FrameMove );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_BLINK_EndFuture );	
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_PARRYING_BLINK_End );

	m_StateList[stateData.stateID] = stateData;
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어

#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	stateData.Init();
	stateData.stateID			= ENSI_BERSERK_MODE;
	m_LuaManager.MakeTableReference( "ENSI_BERSERK_MODE", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, HyperModeStart );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, HyperModeFrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, HyperModeEventProcess );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUUser, HyperModeStartFuture );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUUser, HyperModeEnd );
	m_StateList[stateData.stateID] = stateData;
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항




//#ifdef PVP_BOSS_COMBAT_TEST
//
//	stateData.Init();
//	stateData.stateID			= ENSI_FROZEN;
//	m_LuaManager.MakeTableReference( "ENSI_FROZEN", stateData.stateID );
//	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, Frozen_StateStart ); 
//	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, Frozen_EventProcess );
//	stateData.StateEnd			= SET_CB_FUNC( CX2GUUser, Frozen_StateEnd ); 
//	m_StateList[stateData.stateID] = stateData;
//
//	m_FrozenState = ENSI_FROZEN;
//
//#endif PVP_BOSS_COMBAT_TEST






//#ifdef TRANSFORMER_TEST
//
//	stateData.Init();
//	stateData.stateID			= ENSI_TRANSFORMED;
//	m_LuaManager.MakeTableReference( "ENSI_TRANSFORMED", stateData.stateID );
//	m_StateList[stateData.stateID] = stateData;
//	m_CommonState.m_Transformed = ENSI_TRANSFORMED;
//
//
//#endif TRANSFORMER_TEST

	//stateData.Init();
	//stateData.stateID			= ENSI_SUPER_DASH_READY;
	//m_LuaManager.MakeTableReference( "ENSI_SUPER_DASH_READY", stateData.stateID );
	//stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SUPER_DASH_READY_EventProcess );
	//m_StateList[stateData.stateID] = stateData;

	//stateData.Init();
	//stateData.stateID			= ENSI_SUPER_DASH;
	//m_LuaManager.MakeTableReference( "ENSI_SUPER_DASH", stateData.stateID );
	//stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SUPER_DASH_FrameMoveFuture );
	//stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SUPER_DASH_EventProcess );
	//m_StateList[stateData.stateID] = stateData;

	//stateData.Init();
	//stateData.stateID			= ENSI_SUPER_DASH_END;
	//m_LuaManager.MakeTableReference( "ENSI_SUPER_DASH_END", stateData.stateID );
	//stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SUPER_DASH_END_FrameMove );
	//stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SUPER_DASH_END_EventProcess );
	//m_StateList[stateData.stateID] = stateData;
}


void CX2GUEve::InitState()
{
	ASSERT( NULL != GetUnit() );


	const CX2Unit::UnitData* pUnitData = &GetUnit()->GetUnitData();

	switch( pUnitData->m_UnitClass )
	{
	case CX2Unit::UC_EVE_NASOD:
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_ARCHITECTURE:
		{
			m_iSkillCutInSetIndex = 0;
		} break;

		//{{ kimhc // 2010.2.17 //	이브 2차 전직 스킬 컷인
#ifdef	EVE_SECOND_CLASS_CHANGE
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
			m_iSkillCutInSetIndex = 1;
		} break;

	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
			m_iSkillCutInSetIndex = 2;
		} break;
#endif	EVE_SECOND_CLASS_CHANGE
#ifdef SERV_EVE_BATTLE_SERAPH
	case CX2Unit::UC_EVE_BATTLE_SERAPH:
		{
			m_iSkillCutInSetIndex = 3;
		} break;
#endif
		//}} kimhc // 2010.2.17 //	이브 2차 전직 스킬 컷인		
	}

	switch( pUnitData->m_UnitClass )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
		{
			m_iSkillCutInSetSubIndex = 1;
		} break;
	case CX2Unit::UC_EVE_ARCHITECTURE:
		{
			m_iSkillCutInSetSubIndex = 2;
		} break;
	default:
		{
			m_iSkillCutInSetSubIndex = 0;
		}
		break;
	}

	InitStateID();

	// 공통으로 쓰는 상태
	InitStateCommon();

	// 공통으로 쓰는 랜덤한 상태 start, win, lose 상태 초기화
	std::string tableNameStartUTF8;
	std::string tableNameWinUTF8;
	std::string tableNameLoseUTF8;
	InitStateCommonRandom( tableNameStartUTF8, tableNameWinUTF8, tableNameLoseUTF8 );


	UserUnitStateData stateData;


	stateData.Init();
	stateData.stateID			= USI_START;
	m_LuaManager.MakeTableReference( tableNameStartUTF8.c_str(), stateData.stateID );
	//{{ kimhc // 2010-03-09 // start 모션의 effect들을 effectset으로 바꿈
	//stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, StartFrameMove );
	//}} kimhc // 2010-03-09 // start 모션의 effect들을 effectset으로 바꿈

	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, StartEventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUUser, StartEnd );
	m_StateList[stateData.stateID] = stateData;


	stateData.Init();
	stateData.stateID			= USI_WIN;
	m_LuaManager.MakeTableReference( tableNameWinUTF8.c_str(), stateData.stateID );
#ifdef SERV_PET_SYSTEM
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, WinStateStart );	
#endif
	//{{ kimhc // 2010-03-09 // Win 모션의 effect들을 effectset으로 바꿈
	//stateData.StateStart		= SET_CB_FUNC( CX2GUEve, WinStart );
	//stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, WinFrameMove );
	//stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, WinEnd );
	//}} kimhc // 2010-03-09 // Win 모션의 effect들을 effectset으로 바꿈
	m_StateList[stateData.stateID] = stateData;


	stateData.Init();
	stateData.stateID			= USI_LOSE;
	m_LuaManager.MakeTableReference( tableNameLoseUTF8.c_str(), stateData.stateID );
#ifdef SERV_PET_SYSTEM
	stateData.StateStart		= SET_CB_FUNC( CX2GUUser, LoseStateStart );	
#endif
	//{{ kimhc // 2010-03-09 // start 모션의 effect들을 effectset으로 바꿈
	//stateData.StateStart		= SET_CB_FUNC( CX2GUEve, LoseStart );
	//stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, LoseFrameMove );
	//}} kimhc // 2010-03-09 // start 모션의 effect들을 effectset으로 바꿈
	m_StateList[stateData.stateID] = stateData;

	if( 0 == tableNameWinUTF8.compare( "ENSI_WIN2" ) || 0 == tableNameWinUTF8.compare( "ENSI_AT_WIN2" ) || 0 == tableNameWinUTF8.compare( "ENSI_EG_WIN2" ))
	{
		m_bIsWinMotion2 = true;
	}

	if( 0 == tableNameLoseUTF8.compare( "ENSI_LOSE2" ) || 0 == tableNameLoseUTF8.compare( "ENSI_AT_LOSE2" ) || 0 == tableNameLoseUTF8.compare( "ENSI_EG_LOSE2" ))
	{
		m_bIsLoseMotion2 = true;
	}





	switch( pUnitData->m_UnitClass )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_ARCHITECTURE:
	case CX2Unit::UC_EVE_CODE_NEMESIS:
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
			stateData.Init();
			stateData.stateID			= ENSI_COMBO_ZZZdownZZ;
			m_LuaManager.MakeTableReference( "ENSI_COMBO_ZZZdownZZ", stateData.stateID );
			stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZdownZZ_Init );			
			stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZdownZZ_StartFuture );
			stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZdownZZ_Start );
			stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZdownZZ_End );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZdownZZ_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZZdownZZ_EventProcess );
			m_StateList[stateData.stateID] = stateData;
		} break;
	}

	switch( pUnitData->m_UnitClass )
	{
	case CX2Unit::UC_EVE_ARCHITECTURE:
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
#ifdef EVE_FIRST_CHANGE_JOB
			stateData.Init();
			stateData.stateID			= ENSI_COMBO_XXZ4;
			m_LuaManager.MakeTableReference( "ENSI_COMBO_XXZ4", stateData.stateID );
			stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXZ4_Init );			
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXZ4_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXZ4_EventProcess );
			m_StateList[stateData.stateID] = stateData;			
#endif EVE_FIRST_CHANGE_JOB


		} break;
	}

#ifdef EVE_ELECTRA
	switch( pUnitData->m_UnitClass )
	{
	case CX2Unit::UC_EVE_ELECTRA:
#ifdef SERV_EVE_BATTLE_SERAPH
	case CX2Unit::UC_EVE_BATTLE_SERAPH:
#endif
		{
			stateData.Init();
			stateData.stateID			= ENSI_EPR_COMBO_ZZZfrontZ;
			m_LuaManager.MakeTableReference( "ENSI_EPR_COMBO_ZZZfrontZ", stateData.stateID );
			stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EPR_COMBO_ZZZfrontZ_Start );
			stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_EPR_COMBO_ZZZfrontZ_End );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EPR_COMBO_ZZZfrontZ_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EPR_COMBO_ZZZfrontZ_EventProcess );
			m_StateList[stateData.stateID] = stateData;	

			stateData.Init();
			stateData.stateID			= ENSI_EPR_COMBO_XXZ;
			m_LuaManager.MakeTableReference( "ENSI_EPR_COMBO_XXZ", stateData.stateID );
			stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EPR_COMBO_XXZ_Start );
			stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_EPR_COMBO_XXZ_End );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EPR_COMBO_XXZ_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EPR_COMBO_XXZ_EventProcess );
			m_StateList[stateData.stateID] = stateData;	
		} break;
	}
#endif EVE_ELECTRA


#ifdef EVE_ELECTRA
	stateData.Init();
	stateData.stateID			= ENSI_COMBO_XXfrontXX;
	m_LuaManager.MakeTableReference( "ENSI_COMBO_XXfrontXX", stateData.stateID );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXfrontXX_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXfrontXX_EventProcess );
	m_StateList[stateData.stateID] = stateData;



	stateData.Init();
	stateData.stateID			= ENSI_COMBO_XXdownXX;
	m_LuaManager.MakeTableReference( "ENSI_COMBO_XXdownXX", stateData.stateID );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXdownXX_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_XXdownXX_EventProcess );
	m_StateList[stateData.stateID] = stateData;
#endif EVE_ELECTRA

	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_EventProcess );

#ifdef SERV_EVE_BATTLE_SERAPH
#pragma region 부스트 대쉬 스타트
	stateData.Init();
	stateData.stateID			= ENSI_EBS_BOOST_DASH_START;
	m_LuaManager.MakeTableReference( "ENSI_EBS_BOOST_DASH_START", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_START_StartFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_START_EventProcess );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_START_EndFuture );
	m_StateList[stateData.stateID] = stateData;
#pragma endregion

#pragma region 부스트 대쉬
	stateData.Init();
	stateData.stateID			= ENSI_EBS_BOOST_DASH;
	m_LuaManager.MakeTableReference( "ENSI_EBS_BOOST_DASH", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_Start );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_FrameMove );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_FrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_EventProcess );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_End );
	m_StateList[stateData.stateID] = stateData;
#pragma endregion

#pragma region 부스트 대쉬 스타트
	stateData.Init();
	stateData.stateID			= ENSI_EBS_BOOST_DASH_AIR_START;
	m_LuaManager.MakeTableReference( "ENSI_EBS_BOOST_DASH_AIR_START", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_AIR_START_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_AIR_START_Start );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_AIR_START_FrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_AIR_START_EventProcess );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_AIR_START_EndFuture );
	m_StateList[stateData.stateID] = stateData;
#pragma endregion

#pragma region 부스트 대쉬 에어
	stateData.Init();
	stateData.stateID			= ENSI_EBS_BOOST_DASH_AIR;
	m_LuaManager.MakeTableReference( "ENSI_EBS_BOOST_DASH_AIR", stateData.stateID );
	stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_AIR_StartFuture );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_AIR_Start );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_AIR_FrameMove );
	stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_AIR_FrameMoveFuture );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_AIR_EventProcess );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_AIR_EndFuture );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_EBS_BOOST_DASH_AIR_End );
	m_StateList[stateData.stateID] = stateData;
#pragma endregion

#pragma region 대쉬 점프 콤보 X(Push)Z
	stateData.Init();
	stateData.stateID			= ENSI_EBS_DASH_JUMP_COMBO_XZ;
	m_LuaManager.MakeTableReference( "ENSI_EBS_DASH_JUMP_COMBO_XZ", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_XZ_Start );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_XZ_EndFuture );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_XZ_End );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_XZ_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_XZ_EventProcess );
	m_StateList[stateData.stateID] = stateData;
#pragma endregion

#pragma region 이브 부스트 점프 공격
	stateData.Init();
	stateData.stateID			= ENSI_EBS_DASH_JUMP_COMBO_ZFrontX;
	m_LuaManager.MakeTableReference( "ENSI_EBS_DASH_JUMP_COMBO_ZFrontX", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZFrontX_Start );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZFrontX_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZFrontX_EventProcess );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZFrontX_EndFuture );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZFrontX_End );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_EBS_DASH_JUMP_COMBO_ZUpX;
	m_LuaManager.MakeTableReference( "ENSI_EBS_DASH_JUMP_COMBO_ZUpX", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZUpX_Start );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZUpX_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZUpX_EventProcess );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZUpX_EndFuture );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZUpX_End );
	m_StateList[stateData.stateID] = stateData;

	stateData.Init();
	stateData.stateID			= ENSI_EBS_DASH_JUMP_COMBO_ZDownX;
	m_LuaManager.MakeTableReference( "ENSI_EBS_DASH_JUMP_COMBO_ZDownX", stateData.stateID );
	stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZDownX_Start );
	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZDownX_FrameMove );
	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZDownX_EventProcess );
	stateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZDownX_EndFuture );
	stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_EBS_DASH_JUMP_COMBO_ZDownX_End );
	m_StateList[stateData.stateID] = stateData;
#pragma endregion
#endif


	/////////////////////// 대시 콤보 //////////////////////////////////////////////////
#ifdef EVE_FIRST_CHANGE_JOB
	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
			stateData.Init();
			stateData.stateID			= ENSI_DASH_COMBO_ZZ;
			m_LuaManager.MakeTableReference( "ENSI_DASH_COMBO_ZZ", stateData.stateID );
			stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_ZZ_Init );
			stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_ZZ_StartFuture );
			stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_ZZ_Start );					
			stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_ZZ_End );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_ZZ_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_ZZ_EventProcess );
			m_StateList[stateData.stateID] = stateData;

			stateData.Init();
			stateData.stateID			= ENSI_DASH_COMBO_ZZZ;										
			m_LuaManager.MakeTableReference( "ENSI_DASH_COMBO_ZZZ", stateData.stateID );
			stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_ZZZ_StartFuture );
			stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_ZZZ_Start );
			stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_ZZZ_End );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_ZZZ_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_ZZZ_EventProcess );
			m_StateList[stateData.stateID] = stateData;

			stateData.Init();
			stateData.stateID			= ENSI_DASH_COMBO_XZ;
			m_LuaManager.MakeTableReference( "ENSI_DASH_COMBO_XZ", stateData.stateID );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_XZ_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_XZ_EventProcess );
			m_StateList[stateData.stateID] = stateData;
		}
		break;

		//{{ kimhc // 2010.1.27 //	이브 2차 전직 엠프레스 대시 콤보
#ifdef EVE_SECOND_CLASS_CHANGE
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
			stateData.Init();
			stateData.stateID			= ENSI_EP_DASH_COMBO_ZZ;
			m_LuaManager.MakeTableReference( "ENSI_EP_DASH_COMBO_ZZ", stateData.stateID );
			stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_EP_DASH_COMBO_ZZ_Init );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EP_DASH_COMBO_ZZ_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EP_DASH_COMBO_ZZ_EventProcess );
			m_StateList[stateData.stateID] = stateData;

			stateData.Init();
			stateData.stateID			= ENSI_EP_DASH_COMBO_ZZZ;
			m_LuaManager.MakeTableReference( "ENSI_EP_DASH_COMBO_ZZZ", stateData.stateID );
			stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_EP_DASH_COMBO_ZZZ_Init );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EP_DASH_COMBO_ZZZ_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EP_DASH_COMBO_ZZZ_EventProcess );
			m_StateList[stateData.stateID] = stateData;

		}
		break;
#endif EVE_SECOND_CLASS_CHANGE
		//}} kimhc // 2010.1.27 //	이브 2차 전직 엠프레스 대시 콤보
#ifdef EVE_ELECTRA
	case CX2Unit::UC_EVE_ELECTRA:
#ifdef SERV_EVE_BATTLE_SERAPH
	case CX2Unit::UC_EVE_BATTLE_SERAPH:
#endif
		{
			stateData.Init();
			stateData.stateID			= ENSI_EPR_DASH_COMBO_ZZ;										
			m_LuaManager.MakeTableReference( "ENSI_EPR_DASH_COMBO_ZZ", stateData.stateID );
			stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_EPR_DASH_COMBO_ZZ_Init );
			stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EPR_DASH_COMBO_ZZ_StartFuture );
			stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EPR_DASH_COMBO_ZZ_Start );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EPR_DASH_COMBO_ZZ_EventProcess );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EPR_DASH_COMBO_ZZ_FrameMove );
			stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_EPR_DASH_COMBO_ZZ_End );
			m_StateList[stateData.stateID] = stateData;

			stateData.Init();
			stateData.stateID			= ENSI_EPR_DASH_COMBO_ZZZ;										
			m_LuaManager.MakeTableReference( "ENSI_EPR_DASH_COMBO_ZZZ", stateData.stateID );
			stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_EPR_DASH_COMBO_ZZZ_Init );
			stateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EPR_DASH_COMBO_ZZZ_StartFuture );
			stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EPR_DASH_COMBO_ZZZ_Start );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EPR_DASH_COMBO_ZZZ_EventProcess );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EPR_DASH_COMBO_ZZZ_FrameMove );
			stateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_EPR_DASH_COMBO_ZZZ_EndFuture );
			stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_EPR_DASH_COMBO_ZZZ_End );
			m_StateList[stateData.stateID] = stateData;

		}
		break;
#endif EVE_ELECTRA
	}
#endif EVE_FIRST_CHANGE_JOB

	//{{ kimhc // 2010.1.25 // 이브 2차 콤보
#ifdef	EVE_SECOND_CLASS_CHANGE
	switch ( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
			stateData.Init();
			stateData.stateID			= ENSI_NS_DASH_COMBO_ZX;
			m_LuaManager.MakeTableReference( "ENSI_NS_DASH_COMBO_ZX", stateData.stateID );		
			stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_NS_DASH_COMBO_ZX_Init );
			stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_NS_DASH_COMBO_ZX_Start );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_NS_DASH_COMBO_ZX_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_NS_DASH_COMBO_ZX_EventProcess );
			m_StateList[stateData.stateID] = stateData;

			stateData.Init();
			stateData.stateID			= ENSI_NS_DASH_COMBO_ZXX;							
			m_LuaManager.MakeTableReference( "ENSI_NS_DASH_COMBO_ZXX", stateData.stateID );
			stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_NS_DASH_COMBO_ZXX_Init );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_NS_DASH_COMBO_ZXX_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_NS_DASH_COMBO_ZXX_EventProcess );
			m_StateList[stateData.stateID] = stateData;


			stateData.Init();
			stateData.stateID			= ENSI_NS_COMBO_XXZ;
			m_LuaManager.MakeTableReference( "ENSI_NS_COMBO_XXZ", stateData.stateID );			
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_NS_COMBO_XXZ_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_NS_COMBO_XXZ_EventProcess );
			m_StateList[stateData.stateID] = stateData;

			stateData.Init();
			stateData.stateID			= ENSI_NS_COMBO_XXZZ8;										
			m_LuaManager.MakeTableReference( "ENSI_NS_COMBO_XXZZ8", stateData.stateID );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_NS_COMBO_XXZZ8_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_NS_COMBO_XXZZ8_EventProcess );

			m_StateList[stateData.stateID] = stateData;

			stateData.Init();
			stateData.stateID			= ENSI_NS_COMBO_XXZZ8Z;
			m_LuaManager.MakeTableReference( "ENSI_NS_COMBO_XXZZ8Z", stateData.stateID );			
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_NS_COMBO_XXZZ8Z_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_NS_COMBO_XXZZ8Z_EventProcess );
			m_StateList[stateData.stateID] = stateData;

		}
		break;

	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
			stateData.Init();
			stateData.stateID			= ENSI_EP_JUMP_COMBO_ZX;
			m_LuaManager.MakeTableReference( "ENSI_EP_JUMP_COMBO_ZX", stateData.stateID );		
			stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_EP_JUMP_COMBO_ZX_Init );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EP_JUMP_COMBO_ZX_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EP_JUMP_COMBO_ZX_EventProcess );
			m_StateList[stateData.stateID] = stateData;

			stateData.Init();
			stateData.stateID			= ENSI_EP_COMBO_XXdownX;										
			m_LuaManager.MakeTableReference( "ENSI_EP_COMBO_XXdownX", stateData.stateID );
			stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_EP_COMBO_XXdownX_Init );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EP_COMBO_XXdownX_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EP_COMBO_XXdownX_EventProcess );
			m_StateList[stateData.stateID] = stateData;
		}
		break;
	}
#endif	EVE_SECOND_CLASS_CHANGE
	//}} kimhc // 2010.1.25 // 이브 2차 콤보

	//#ifdef EVE_COMBO_TEST_TEST
	//	stateData.Init();
	//	stateData.stateID			= ENSI_DASH_COMBO_ZX;
	//	m_LuaManager.MakeTableReference( "ENSI_DASH_COMBO_ZX", stateData.stateID );
	//	stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_ZX_FrameMove );
	//	stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_COMBO_ZX_EventProcess );
	//	m_StateList[stateData.stateID] = stateData;
	//#endif EVE_COMBO_TEST_TEST



	//
	//
	//#ifdef EVE_FIRST_CHANGE_JOB
	//	//{{ 09.01.21.hoons. 이콤보는 키조합은 [엑조틱기어]만 사용.
	//	if( GetUnit()->GetClass() == CX2Unit::UC_EVE_EXOTIC_GEAR )
	//	{
	//		stateData.Init();
	//		stateData.stateID			= ENSI_DASH_JUMP_COMBO_ZX;
	//		m_LuaManager.MakeTableReference( "ENSI_DASH_JUMP_COMBO_ZX", stateData.stateID );
	//		stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_ZX_FrameMove );
	//		stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_ZX_EventProcess );
	//		stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_ZX_End );
	//		m_StateList[stateData.stateID] = stateData;
	//	}
	//	//}} hoons.
	//#endif EVE_FIRST_CHANGE_JOB


#ifdef EVE_FIRST_CHANGE_JOB
	// {{ 09.02.02 wonpok
	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_ARCHITECTURE:
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
			stateData.Init();
			stateData.stateID			= ENSI_DASH_JUMP_COMBO_XZ;
			m_LuaManager.MakeTableReference( "ENSI_DASH_JUMP_COMBO_XZ", stateData.stateID );	
			stateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_XZ_Init );
			stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_XZ_FrameMove );
			stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_XZ_EventProcess );
			stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_DASH_JUMP_COMBO_XZ_End );
			m_StateList[stateData.stateID] = stateData;
		} break;
	}
#endif EVE_FIRST_CHANGE_JOB





	//stateData.Init();
	//stateData.stateID			= ENSI_COMBO_ZZX;
	//m_LuaManager.MakeTableReference( "ENSI_COMBO_ZZX", stateData.stateID );
	//stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZX_EventProcess );
	//m_StateList[stateData.stateID] = stateData;

	//stateData.Init();
	//stateData.stateID			= ENSI_COMBO_ZZXX;
	//m_LuaManager.MakeTableReference( "ENSI_COMBO_ZZXX", stateData.stateID );
	//stateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZXX_FrameMoveFuture );
	//stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_COMBO_ZZXX_EventProcess );
	//m_StateList[stateData.stateID] = stateData;



	InitPassiveSkillState();
	InitEquippedActiveSkillState();

	CX2GUUser::InitState();

}

/*virtual*/ void CX2GUEve::SetEquippedSkillFuncBySkillSlotIndex( const CX2SkillTree::SKILL_ID eSkillID_, const int iSlotIndex_, const bool bSlotB_ )
{
	if ( iSlotIndex_ < 0 || iSlotIndex_ >= ARRAY_SIZE( _CONST_GUUSER_::aNormalSkillStateID ) )
		return;

	int iNormalStateID = ( bSlotB_ == false ? _CONST_GUUSER_::aNormalSkillStateID[iSlotIndex_] : _CONST_GUUSER_::aNormalSkillStateIDSlotB[iSlotIndex_] );
	UserUnitStateData& normalStateData = m_StateList[ iNormalStateID ];
	normalStateData.Init();
	normalStateData.stateID = iNormalStateID;

	int iHyperStateID = ( bSlotB_ == false ? _CONST_GUUSER_::aHyperSkillStateID[iSlotIndex_] : _CONST_GUUSER_::aHyperSkillStateIDSlotB[iSlotIndex_] );
	UserUnitStateData& hyperStateData = m_StateList[ iHyperStateID ];
	hyperStateData.Init();	
	hyperStateData.m_bHyperState = true;
	hyperStateData.stateID = iHyperStateID;

	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( eSkillID_ );
	if( NULL == pSkillTemplet )
		return;

	switch( pSkillTemplet->m_eType )
	{	
	case CX2SkillTree::ST_BUFF:
		{	// 버프 필살기
			m_LuaManager.MakeTableReference( "ENSI_SI1_COMMON_BUFF", normalStateData.stateID );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, COMMON_BUFF_FrameMove );	
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, COMMON_BUFF_EventProcess );	

			m_LuaManager.MakeTableReference( "ENSI_SI1_COMMON_BUFF_HYPER", hyperStateData.stateID );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, COMMON_BUFF_FrameMove );	
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, COMMON_BUFF_EventProcess );

			return;
		} break;
	case CX2SkillTree::ST_ACTIVE:
	case CX2SkillTree::ST_SPECIAL_ACTIVE:
#ifdef FINALITY_SKILL_SYSTEM //JHKang
	case CX2SkillTree::ST_HYPER_ACTIVE_SKILL:
#endif //FINALITY_SKILL_SYSTEM
		{
			// ST_ACTIVE, ST_SPECIAL_ACTIVE는 아래 구문에서 수행
		} break;
#ifdef ADDED_RELATIONSHIP_SYSTEM
	case CX2SkillTree::ST_RELATIONSHIP_SKILL:
		{
			switch( eSkillID_ )
			{
			case CX2SkillTree::SI_ETC_WS_COMMON_LOVE:
				{
					m_LuaManager.MakeTableReference( "ENSI_THROW_ITEM", normalStateData.stateID );
					normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUUser, COMMON_RELATIONSHIP_SKILL_FrameMove );	
					normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUUser, COMMON_RELATIONSHIP_SKILL_EventProcess );	

					m_LuaManager.MakeTableReference( "ENSI_THROW_ITEM", hyperStateData.stateID );
					hyperStateData.OnFrameMove		= normalStateData.OnFrameMove;
					hyperStateData.OnEventProcess	= normalStateData.OnEventProcess;
				} break;
			}
			return;
		} break;
#endif // ADDED_RELATIONSHIP_SYSTEM
	default:
		{
			return;
		} break;
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////// 여기서 부터 ACTIVE, SPECIAL ACTIVE 스킬//////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	switch( eSkillID_ )
	{
	default:
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_A_EN_ILLUSION_STRIKE:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_EN_ILLUSION_STRIKE:
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
			m_LuaManager.MakeTableReference( "ENSI_SI1_ILLUSION_STRIKE", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SI1_ILLUSION_STRIKE_Init );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI1_ILLUSION_STRIKE_FrameMove );
			//normalStateData.OnCameraMove		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_ILLUSION_STRIKE_CameraMove );		
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_ILLUSION_STRIKE_EventProcess );	

			m_LuaManager.MakeTableReference( "ENSI_SI1_ILLUSION_STRIKE_HYPER", hyperStateData.stateID );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI1_ILLUSION_STRIKE_HYPER_FrameMove );
			//hyperStateData.OnCameraMove		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_MAXIMUM_CANNON_HYPER_CameraMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_ILLUSION_STRIKE_HYPER_EventProcess );
		} break;

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_A_EN_DIMENSION_LINK:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_EN_DIMENSION_LINK:
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
			m_LuaManager.MakeTableReference( "ENSI_SI1_DIMENSION_LINK", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SI1_DIMENSION_LINK_Init );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI1_DIMENSION_LINK_FrameMove );
			//normalStateData.OnCameraMove		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_DIMENSION_LINK_CameraMove );		
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_DIMENSION_LINK_EventProcess );	

			m_LuaManager.MakeTableReference( "ENSI_SI1_DIMENSION_LINK_HYPER", hyperStateData.stateID );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI1_DIMENSION_LINK_HYPER_FrameMove );
			//hyperStateData.OnCameraMove		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_DIMENSION_LINK_HYPER_CameraMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_DIMENSION_LINK_HYPER_EventProcess );

		} break;


	case CX2SkillTree::SI_SA_EN_ILLUSION_STINGER:
		{
			const char* pszStateName = "ENSI_SI2_ILLUSION_STINGER";
			const char* pszHyperStateName = "ENSI_SI2_ILLUSION_STINGER_HYPER";

			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO8 ) == true )
			{
				pszStateName = "ENSI_SI2_ILLUSION_STINGER_MEMO";
				pszHyperStateName = "ENSI_SI2_ILLUSION_STINGER_HYPER_MEMO";
			}

			m_LuaManager.MakeTableReference( pszStateName, normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_ILLUSION_STINGER_Init );
			normalStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_ILLUSION_STINGER_Start );
			normalStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_ILLUSION_STINGER_End );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_ILLUSION_STINGER_FrameMove );
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI2_ILLUSION_STINGER_EventProcess );	

			m_LuaManager.MakeTableReference( pszHyperStateName, hyperStateData.stateID );
			hyperStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_ILLUSION_STINGER_HYPER_Start );
			hyperStateData.StateEnd				= SET_CB_FUNC( CX2GUEve, ENSI_SI2_ILLUSION_STINGER_HYPER_End );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_ILLUSION_STINGER_HYPER_FrameMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI2_ILLUSION_STINGER_HYPER_EventProcess );
		} break;

	case CX2SkillTree::SI_SA_EN_DIMENSION_LINK_BLADER:
		{
			m_LuaManager.MakeTableReference( "ENSI_SI2_DIMENSION_LINK_BLADER", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_DIMENSION_LINK_BLADER_Init );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_DIMENSION_LINK_BLADER_FrameMove );	
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI2_DIMENSION_LINK_BLADER_EventProcess );	

			m_LuaManager.MakeTableReference( "ENSI_SI2_DIMENSION_LINK_BLADER_HYPER", hyperStateData.stateID );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_DIMENSION_LINK_BLADER_HYPER_FrameMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI2_DIMENSION_LINK_BLADER_HYPER_EventProcess );

		} break;

	case CX2SkillTree::SI_SA_EN_GENERATE_BLACKHOLE:
		{
			m_LuaManager.MakeTableReference( "ENSI_SI3_GENERATE_BLACKHOLE", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_GENERATE_BLACKHOLE_Init );
			//normalStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SI3_GENERATE_BLACKHOLE_FrameMoveFuture );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_GENERATE_BLACKHOLE_FrameMove );
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI3_GENERATE_BLACKHOLE_EventProcess );
			//normalStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_GENERATE_BLACKHOLE_End );

			m_LuaManager.MakeTableReference( "ENSI_SI3_GENERATE_BLACKHOLE_HYPER", hyperStateData.stateID );
			//hyperStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SI3_GENERATE_BLACKHOLE_HYPER_FrameMoveFuture );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_GENERATE_BLACKHOLE_HYPER_FrameMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI3_GENERATE_BLACKHOLE_HYPER_EventProcess );
			//hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_GENERATE_BLACKHOLE_HYPER_End );

		} break;

	case CX2SkillTree::SI_SA_EN_DIMENSION_LINK_GUARDIAN:
		{

			m_LuaManager.MakeTableReference( "ENSI_SI3_DIMENSION_LINK_GUARDIAN", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_DIMENSION_LINK_GUARDIAN_Init );
			//normalStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SI3_DIMENSION_LINK_GUARDIAN_FrameMoveFuture );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_DIMENSION_LINK_GUARDIAN_FrameMove );
			//normalStateData.OnCameraMove		= SET_CB_FUNC( CX2GUEve, ENSI_SI2_DIMENSION_LINK_GUARDIAN_CameraMove );		
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI3_DIMENSION_LINK_GUARDIAN_EventProcess );	

			m_LuaManager.MakeTableReference( "ENSI_SI3_DIMENSION_LINK_GUARDIAN_HYPER", hyperStateData.stateID );
			//hyperStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SI3_DIMENSION_LINK_GUARDIAN_HYPER_FrameMoveFuture );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_DIMENSION_LINK_GUARDIAN_HYPER_FrameMove );
			//hyperStateData.OnCameraMove		= SET_CB_FUNC( CX2GUEve, ENSI_SI2_DIMENSION_LINK_GUARDIAN_HYPER_CameraMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI3_DIMENSION_LINK_GUARDIAN_HYPER_EventProcess );
		} break;

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_A_EEG_HORNET_STING_EXPLOSION:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_EEG_HORNET_STING:
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
			m_LuaManager.MakeTableReference( "ENSI_SI1_EG_HORNET_STING", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SI1_EG_HORNET_STING_Init );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI1_EG_HORNET_STING_FrameMove );
			//normalStateData.OnCameraMove		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_EG_HORNET_STING_CameraMove );		
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_EG_HORNET_STING_EventProcess );	

			m_LuaManager.MakeTableReference( "ENSI_SI1_EG_HORNET_STING_HYPER", hyperStateData.stateID );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI1_EG_HORNET_STING_HYPER_FrameMove );
			//hyperStateData.OnCameraMove		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_MAXIMUM_CANNON_HYPER_CameraMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_EG_HORNET_STING_HYPER_EventProcess );

		} break;

	case CX2SkillTree::SI_SA_EEG_EXPLOSION_IMPACT:
		{
			m_LuaManager.MakeTableReference( "ENSI_SI2_EG_EXPLOSION_IMPACT", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_EG_EXPLOSION_IMPACT_Init );
			normalStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_EG_EXPLOSION_IMPACT_Start );
			normalStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_EG_EXPLOSION_IMPACT_End );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_EG_EXPLOSION_IMPACT_FrameMove );		
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI2_EG_EXPLOSION_IMPACT_EventProcess );	

			m_LuaManager.MakeTableReference( "ENSI_SI2_EG_EXPLOSION_IMPACT_HYPER", hyperStateData.stateID );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_EG_EXPLOSION_IMPACT_HYPER_FrameMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI2_EG_EXPLOSION_IMPACT_HYPER_EventProcess );

		} break;

	case CX2SkillTree::SI_SA_EEG_QUEENS_THRONE:
		{
			m_LuaManager.MakeTableReference( "ENSI_SI3_EG_QUEENS_THRONE", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_EG_QUEENS_THRONE_Init );
			normalStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_EG_QUEENS_THRONE_Start );
			normalStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_EG_QUEENS_THRONE_End );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_EG_QUEENS_THRONE_FrameMove );		
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI3_EG_QUEENS_THRONE_EventProcess );	

			m_LuaManager.MakeTableReference( "ENSI_SI3_EG_QUEENS_THRONE_HYPER", hyperStateData.stateID );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_EG_QUEENS_THRONE_HYPER_FrameMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI3_EG_QUEENS_THRONE_HYPER_EventProcess );
		} break;

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_A_EAT_SURFACE_CUTING:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_EAT_SURFACE_CUTING:
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
			m_LuaManager.MakeTableReference( "ENSI_SI1_AT_SURFACE_CUTING", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SI1_AT_SURFACE_CUTING_Init );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI1_AT_SURFACE_CUTING_FrameMove );
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_AT_SURFACE_CUTING_EventProcess );	

			m_LuaManager.MakeTableReference( "ENSI_SI1_AT_SURFACE_CUTING_HYPER", hyperStateData.stateID );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI1_AT_SURFACE_CUTING_HYPER_FrameMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI1_AT_SURFACE_CUTING_HYPER_EventProcess );

		} break;

	case CX2SkillTree::SI_SA_EAT_SONIC_WAVE:
		{
			m_LuaManager.MakeTableReference( "ENSI_SI2_AT_SONIC_WAVE", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_AT_SONIC_WAVE_Init );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_AT_SONIC_WAVE_FrameMove );	
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI2_AT_SONIC_WAVE_EventProcess );	

			m_LuaManager.MakeTableReference( "ENSI_SI2_AT_SONIC_WAVE_HYPER", hyperStateData.stateID );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI2_AT_SONIC_WAVE_HYPER_FrameMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI2_AT_SONIC_WAVE_HYPER_EventProcess );

		} break;

	case CX2SkillTree::SI_SA_EAT_GENOCIDE_RIPPER:
		{
			m_LuaManager.MakeTableReference( "ENSI_SI3_AT_GENOCIDE_RIPPER", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_AT_GENOCIDE_RIPPER_Init );
			normalStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_AT_GENOCIDE_RIPPER_Start );
			//normalStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SI3_AT_GENOCIDE_RIPPER_FrameMoveFuture );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_AT_GENOCIDE_RIPPER_FrameMove );
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI3_AT_GENOCIDE_RIPPER_EventProcess );
			//normalStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_AT_GENOCIDE_RIPPER_End );

			m_LuaManager.MakeTableReference( "ENSI_SI3_AT_GENOCIDE_RIPPER_HYPER", hyperStateData.stateID );
			//hyperStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SI3_AT_GENOCIDE_RIPPER_HYPER_FrameMoveFuture );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_AT_GENOCIDE_RIPPER_HYPER_FrameMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SI3_AT_GENOCIDE_RIPPER_HYPER_EventProcess );
			//hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SI3_AT_GENOCIDE_RIPPER_HYPER_End );

		} break;


	case CX2SkillTree::SI_A_EN_CLOAKING:
		{
			m_LuaManager.MakeTableReference( "ENSI_INVISIBILITY_ON", normalStateData.stateID );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_INVISIBILITY_ON_Start );
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_INVISIBILITY_ON_End );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_INVISIBILITY_ON_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_INVISIBILITY_ON_EventProcess );


			m_LuaManager.MakeTableReference( "ENSI_INVISIBILITY_ON", hyperStateData.stateID );
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_INVISIBILITY_ON_Start );
			hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_INVISIBILITY_ON_End );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_INVISIBILITY_ON_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_INVISIBILITY_ON_EventProcess );

		} break;
		// 마력전환
	case CX2SkillTree::SI_A_EN_CONVERSION:
		{
			m_LuaManager.MakeTableReference( "ENSI_SI_A_EN_CONVERSION", normalStateData.stateID ); 
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_CONVERSION_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_CONVERSION_Start );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_CONVERSION_EventProcess );

			m_LuaManager.MakeTableReference( "ENSI_SI_A_EN_CONVERSION_HYPER", hyperStateData.stateID );
			hyperStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_CONVERSION_Init );
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_CONVERSION_Start );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_CONVERSION_EventProcess );
		} break;
		// 메가일랙트론볼
	case CX2SkillTree::SI_A_EN_MEGA_ELECTRONBALL:
		{
			m_LuaManager.MakeTableReference( "ENSI_SI_A_EN_MEGA_ELECTRONBALL", normalStateData.stateID ); 
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_Init );
			normalStateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_StartFuture );
			normalStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_Start );
			normalStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_FrameMoveFuture );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_FrameMove );
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_EventProcess );
			normalStateData.StateEndFuture		= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_EndFuture );

			m_LuaManager.MakeTableReference( "ENSI_SI_A_EN_MEGA_ELECTRONBALL_HYPER", hyperStateData.stateID );
			hyperStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_Init );
			hyperStateData.StateStartFuture		= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_StartFuture );
			hyperStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_Start );
			hyperStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_FrameMoveFuture );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_FrameMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_EventProcess );
			hyperStateData.StateEndFuture		= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_MEGA_ELECTRONBALL_EndFuture );
		} break;




#ifdef SKILL_30_TEST

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_SA_ENS_IRONSCRAPS:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_EEG_IRONSCRAPS:
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_EEG_IRONSCRAPS", normalStateData.stateID );
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_IRONSCRAPS_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_IRONSCRAPS_StateStart );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_IRONSCRAPS_FrameMove );				
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_IRONSCRAPS_EventProcess );				
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_IRONSCRAPS_StateEnd );


			m_LuaManager.MakeTableReference( "ENSI_SA_EEG_IRONSCRAPS_HYPER", hyperStateData.stateID ); 
			hyperStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_IRONSCRAPS_HYPER_Init );
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_IRONSCRAPS_HYPER_StateStart );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_IRONSCRAPS_HYPER_FrameMove );		
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_IRONSCRAPS_HYPER_EventProcess );	
			hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_IRONSCRAPS_HYPER_StateEnd );

		} break;

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_SA_EEP_SPACE_WRENCH:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_EAT_SPACE_WRENCH:
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_EAT_SPACE_WRENCH", normalStateData.stateID ); 				
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_SPACE_WRENCH_StateStart );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_SPACE_WRENCH_FrameMove );				
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_SPACE_WRENCH_EventProcess );				
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_SPACE_WRENCH_StateEnd );


			m_LuaManager.MakeTableReference( "ENSI_SA_EAT_SPACE_WRENCH_HYPER", hyperStateData.stateID ); 
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_SPACE_WRENCH_HYPER_StateStart );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_SPACE_WRENCH_HYPER_FrameMove );		
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_SPACE_WRENCH_HYPER_EventProcess );	
			hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_SPACE_WRENCH_HYPER_StateEnd );

		} break;

	case CX2SkillTree::SI_A_EEG_METAL_DUST_AURA:
		{
			m_LuaManager.MakeTableReference( "ENSI_A_EEG_METAL_DUST_AURA", normalStateData.stateID ); 			
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_METAL_DUST_AURA_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_METAL_DUST_AURA_StateStart );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_METAL_DUST_AURA_FrameMove );				
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_METAL_DUST_AURA_EventProcess );				
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_METAL_DUST_AURA_StateEnd );


			m_LuaManager.MakeTableReference( "ENSI_A_EEG_METAL_DUST_AURA_HYPER", hyperStateData.stateID ); 
			hyperStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_METAL_DUST_AURA_HYPER_Init );
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_METAL_DUST_AURA_HYPER_StateStart );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_METAL_DUST_AURA_HYPER_FrameMove );		
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_METAL_DUST_AURA_HYPER_EventProcess );	
			hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_METAL_DUST_AURA_HYPER_StateEnd );

		} break;

	case CX2SkillTree::SI_A_EAT_OBERON_GUARD:
		{
			m_LuaManager.MakeTableReference( "ENSI_A_EAT_OBERON_GUARD", normalStateData.stateID );
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_OBERON_GUARD_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_OBERON_GUARD_StateStart );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_OBERON_GUARD_FrameMove );				
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_OBERON_GUARD_EventProcess );				
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_OBERON_GUARD_StateEnd );


			m_LuaManager.MakeTableReference( "ENSI_A_EAT_OBERON_GUARD_HYPER", hyperStateData.stateID ); 
			hyperStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_OBERON_GUARD_HYPER_Init );
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_OBERON_GUARD_HYPER_StateStart );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_OBERON_GUARD_HYPER_FrameMove );		
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_OBERON_GUARD_HYPER_EventProcess );	
			hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_OBERON_GUARD_HYPER_StateEnd );

		} break;
#endif SKILL_30_TEST

#ifdef SKILL_CASH_10_TEST
	case CX2SkillTree::SI_SA_EEG_JUNK_BREAK:
		{
			m_LuaManager.MakeTableReference( "ENSI_A_EEG_JUNK_BREAK", normalStateData.stateID ); 			
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_JUNK_BREAK_Init );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_JUNK_BREAK_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_JUNK_BREAK_EventProcess );


			m_LuaManager.MakeTableReference( "ENSI_A_EEG_JUNK_BREAK_HYPER", hyperStateData.stateID ); 
			hyperStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_JUNK_BREAK_Init );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_JUNK_BREAK_Hyper_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EEG_JUNK_BREAK_Hyper_EventProcess );
		} break;

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_SA_EAT_HEAVENS_FIST_PRESSURE:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_EAT_HEAVENS_FIST:
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
			m_LuaManager.MakeTableReference( "ENSI_A_EAT_HEAVENS_FIST", normalStateData.stateID ); 			
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_HEAVENS_FIST_Init );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_HEAVENS_FIST_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_HEAVENS_FIST_EventProcess );


			m_LuaManager.MakeTableReference( "ENSI_A_EAT_HEAVENS_FIST_HYPER", hyperStateData.stateID ); 
			hyperStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_HEAVENS_FIST_Init );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_HEAVENS_FIST_Hyper_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EAT_HEAVENS_FIST_Hyper_EventProcess );
		} break;
#endif

		//{{ kimhc // 2010.1.27 //	이브 2차 전직 스킬
#ifdef	EVE_SECOND_CLASS_CHANGE
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_A_ENS_ATOMIC_BLASTER_PLASMAGUN:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_ENS_ATOMIC_BLASTER:
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_ENS_ATOMIC_BLASTER", normalStateData.stateID ); 			
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_ATOMIC_BLASTER_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_ATOMIC_BLASTER_Start );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_ATOMIC_BLASTER_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_ATOMIC_BLASTER_EventProcess );
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_ATOMIC_BLASTER_End );

			m_LuaManager.MakeTableReference( "ENSI_SA_ENS_ATOMIC_BLASTER_HYPER", hyperStateData.stateID ); 
			hyperStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_ATOMIC_BLASTER_Init );
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_ATOMIC_BLASTER_Start );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_ATOMIC_BLASTER_Hyper_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_ATOMIC_BLASTER_Hyper_EventProcess );
			hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_ATOMIC_BLASTER_End );
		} break;

	case CX2SkillTree::SI_A_ENS_SPEAR_BURST:
		{
			m_LuaManager.MakeTableReference( "ENSI_A_ENS_BURST_SPEAR", normalStateData.stateID ); 			
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_A_ENS_BURST_SPEAR_Start );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_ENS_BURST_SPEAR_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_ENS_BURST_SPEAR_EventProcess );
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_A_ENS_BURST_SPEAR_End );

			m_LuaManager.MakeTableReference( "ENSI_A_ENS_BURST_SPEAR_HYPER", hyperStateData.stateID ); 
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_A_ENS_BURST_SPEAR_Hyper_Start );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_ENS_BURST_SPEAR_Hyper_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_ENS_BURST_SPEAR_Hyper_EventProcess );
			hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_A_ENS_BURST_SPEAR_Hyper_End );

			{
				UserUnitStateData	stateData;

				stateData.Init();
				stateData.stateID				= ENSI_A_ENS_BURST_SPEAR_Landing;
				m_LuaManager.MakeTableReference( "ENSI_A_ENS_BURST_SPEAR_Landing", stateData.stateID ); 			
				stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_ENS_BURST_SPEAR_Landing_FrameMove );
				stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_ENS_BURST_SPEAR_Landing_EventProcess );
				m_StateList[stateData.stateID] = stateData;

				stateData.Init();
				stateData.stateID				= ENSI_A_ENS_BURST_SPEAR_Landing_HYPER;
				m_LuaManager.MakeTableReference( "ENSI_A_ENS_BURST_SPEAR_Landing_HYPER", stateData.stateID ); 
				stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_ENS_BURST_SPEAR_Landing_Hyper_FrameMove );
				stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_ENS_BURST_SPEAR_Landing_Hyper_EventProcess );
				m_StateList[stateData.stateID] = stateData;
			}

		} break;

		// oasis907 : 김상윤 [2010.1.28] //  엠프레스 스킬
	case CX2SkillTree::SI_A_EEP_ELECTRONIC_FIELD:
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_EEP_ELECTRONIC_FIELD", normalStateData.stateID ); 			
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEP_ELECTRONIC_FIELD_Init );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEP_ELECTRONIC_FIELD_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEP_ELECTRONIC_FIELD_EventProcess );

			m_LuaManager.MakeTableReference( "ENSI_SA_EEP_ELECTRONIC_FIELD_HYPER", hyperStateData.stateID ); 
			hyperStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEP_ELECTRONIC_FIELD_Hyper_Init );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEP_ELECTRONIC_FIELD_Hyper_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEP_ELECTRONIC_FIELD_Hyper_EventProcess );
		} break;

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_A_EEP_SPIT_FIRE_FLUSH:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_A_EEP_SPIT_FIRE:
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
			m_LuaManager.MakeTableReference( "ENSI_A_EEP_SPIT_FIRE", normalStateData.stateID );
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEP_SPIT_FIRE_Init );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEP_SPIT_FIRE_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EEP_SPIT_FIRE_EventProcess );

			m_LuaManager.MakeTableReference( "ENSI_A_EEP_SPIT_FIRE_HYPER", hyperStateData.stateID ); 
			hyperStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEP_SPIT_FIRE_Hyper_Init );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEP_SPIT_FIRE_Hyper_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EEP_SPIT_FIRE_Hyper_EventProcess );

		} break;




#endif	EVE_SECOND_CLASS_CHANGE
		//}} kimhc // 2010.1.27 //	이브 2차 전직 스킬

#ifdef NEW_SKILL_2010_11
		//{{ JHKang / 강정훈 / 2010/11/08 / 어설트 스피어
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_SA_EEP_ASSUALT_SPEAR_BURST:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_EEP_ASSUALT_SPEAR:
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_EPP_ASSUALT_SPEAR", normalStateData.stateID );
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_ASSUALT_SPEAR_Init );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_ASSUALT_SPEAR_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_ASSUALT_SPEAR_EventProcess );

			m_LuaManager.MakeTableReference( "ENSI_SA_EPP_ASSUALT_SPEAR_HYPER", hyperStateData.stateID );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_ASSUALT_SPEAR_HYPER_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_ASSUALT_SPEAR_HYPER_EventProcess );
		} break;
		//}} JHKang / 강정훈 / 2010/11/08 / 어설트 스피어
		//{{ JHKang / 강정훈 / 2010/11/12 / 아토믹 쉴드
	case CX2SkillTree::SI_SA_ENS_ATOMIC_SHIELD:
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_EEG_ATOMIC_SHIELD", normalStateData.stateID );
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_ATOMIC_SHIELD_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_ATOMIC_SHIELD_StateStart );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_ATOMIC_SHIELD_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_ATOMIC_SHIELD_EventProcess );

			m_LuaManager.MakeTableReference( "ENSI_SA_EEG_ATOMIC_SHIELD_HYPER", hyperStateData.stateID );
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_ATOMIC_SHIELD_HYPER_StateStart );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_ATOMIC_SHIELD_HYPER_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_ATOMIC_SHIELD_HYPER_EventProcess );

		} break;
		//{{ JHKang / 강정훈 / 2010/11/12 / 아토믹 쉴드
#ifdef EVE_ELECTRA
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_A_EN_PHOTON_BLINK:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_A_EVE_PHOTON_BLINK:
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
			m_LuaManager.MakeTableReference( "ENSI_A_EVE_PHOTON_BLINK", normalStateData.stateID );
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_Start );
			normalStateData.StateStartFuture = SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_StartFuture );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_EventProcess );
			normalStateData.OnFrameMoveFuture = SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_FrameMoveFuture );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_FrameMove );
			normalStateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_EndFuture );
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_End );

			m_LuaManager.MakeTableReference( "ENSI_A_EVE_PHOTON_BLINK", hyperStateData.stateID );
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_Start );
			hyperStateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_StartFuture );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_EventProcess );
			hyperStateData.OnFrameMoveFuture = SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_FrameMoveFuture );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_FrameMove );
			hyperStateData.StateEndFuture	= SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_EndFuture );
			hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_A_EVE_PHOTON_BLINK_End );

		} break;

	case CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL:
		{
			m_LuaManager.MakeTableReference( "ENSI_A_EPR_SPECTRO_EL_CRYSTAL", normalStateData.stateID );
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EPR_SPECTRO_EL_CRYSTAL_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_A_EPR_SPECTRO_EL_CRYSTAL_Start );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EPR_SPECTRO_EL_CRYSTAL_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EPR_SPECTRO_EL_CRYSTAL_EventProcess );

			m_LuaManager.MakeTableReference( "ENSI_A_EPR_SPECTRO_EL_CRYSTAL", hyperStateData.stateID ); 
			hyperStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EPR_SPECTRO_EL_CRYSTAL_Init );
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_A_EPR_SPECTRO_EL_CRYSTAL_Start );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EPR_SPECTRO_EL_CRYSTAL_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EPR_SPECTRO_EL_CRYSTAL_EventProcess );

		} break;

	case CX2SkillTree::SI_SA_EEL_PARTICLE_RAY:
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_EPR_PARTICLE_RAY", normalStateData.stateID ); 			
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PARTICLE_RAY_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PARTICLE_RAY_Start );
			normalStateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PARTICLE_RAY_StartFuture );
			normalStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PARTICLE_RAY_FrameMoveFuture );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PARTICLE_RAY_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PARTICLE_RAY_EventProcess );
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PARTICLE_RAY_End );

			m_LuaManager.MakeTableReference( "ENSI_SA_EPR_PARTICLE_RAY", hyperStateData.stateID ); 
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PARTICLE_RAY_Start );
			hyperStateData.StateStartFuture		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PARTICLE_RAY_StartFuture );
			hyperStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PARTICLE_RAY_FrameMoveFuture );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PARTICLE_RAY_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PARTICLE_RAY_EventProcess );
			hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PARTICLE_RAY_End );
		} break;

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		case CX2SkillTree::SI_SA_EEL_SWEEP_ROLLING_OVER_CHARGE:
#else //UPGRADE_SKILL_SYSTEM_2013
		case CX2SkillTree::SI_SA_EEL_SWEEP_ROLLING:
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_EPR_SWEEP_ROLLING_READY", normalStateData.stateID );				
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_READY_Init );
			normalStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_READY_Start );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_READY_FrameMove );
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_READY_EventProcess );
			normalStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_READY_End );				

			m_LuaManager.MakeTableReference( "ENSI_SA_EPR_SWEEP_ROLLING_READY", hyperStateData.stateID );
			hyperStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_READY_Start );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_READY_FrameMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_READY_EventProcess );
			hyperStateData.StateEnd				= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_READY_End );			

			{
				UserUnitStateData stateData;

				stateData.Init();
				stateData.stateID			= ENSI_SA_EPR_SWEEP_ROLLING_CHARGE;
				m_LuaManager.MakeTableReference( "ENSI_SA_EPR_SWEEP_ROLLING_CHARGE", stateData.stateID );
				stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_CHARGE_Start );
				stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_CHARGE_FrameMove );	
				stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_CHARGE_EventProcess );	
				stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_CHARGE_End );					
				m_StateList[stateData.stateID] = stateData;

				stateData.Init();
				stateData.stateID			= ENSI_SA_EPR_SWEEP_ROLLING_FIRE;
				m_LuaManager.MakeTableReference( "ENSI_SA_EPR_SWEEP_ROLLING_FIRE", stateData.stateID );
				stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_FIRE_Start );
				stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_FIRE_FrameMove );	
				stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_FIRE_EventProcess );	
				stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_FIRE_End );					
				m_StateList[stateData.stateID] = stateData;

				stateData.Init();
				stateData.stateID			= ENSI_SA_EPR_SWEEP_ROLLING_END;
				m_LuaManager.MakeTableReference( "ENSI_SA_EPR_SWEEP_ROLLING_END", stateData.stateID );
				stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_END_Start );
				stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_END_FrameMove );	
				stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_END_EventProcess );	
				stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_SWEEP_ROLLING_END_End );					
				m_StateList[stateData.stateID] = stateData;
			}
		} break;

	case CX2SkillTree::SI_SA_EEL_PHOTON_FLARE:
		{

			m_LuaManager.MakeTableReference( "ENSI_SA_EPR_PHOTON_FLARE", normalStateData.stateID );
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PHOTON_FLARE_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PHOTON_FLARE_StateStart );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PHOTON_FLARE_FrameMove );				
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PHOTON_FLARE_EventProcess );				
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PHOTON_FLARE_StateEnd );

			m_LuaManager.MakeTableReference( "ENSI_SA_EPR_PHOTON_FLARE", hyperStateData.stateID ); 
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PHOTON_FLARE_StateStart );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PHOTON_FLARE_FrameMove );		
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PHOTON_FLARE_EventProcess );	
			hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_PHOTON_FLARE_StateEnd );
		} break;

	case CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS:
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_EPR_THOUSANDS_OF_STARS", normalStateData.stateID );
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_THOUSANDS_OF_STARS_Init );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_THOUSANDS_OF_STARS_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_THOUSANDS_OF_STARS_EventProcess );

			m_LuaManager.MakeTableReference( "ENSI_SA_EPR_THOUSANDS_OF_STARS", hyperStateData.stateID );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_THOUSANDS_OF_STARS_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_THOUSANDS_OF_STARS_EventProcess );
		} break;

	case CX2SkillTree::SI_SA_EEL_GIGA_STREAM:
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_GIGA_STREAM", normalStateData.stateID ); 			
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_GIGA_STREAM_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_GIGA_STREAM_Start );
			normalStateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_GIGA_STREAM_StartFuture );
			normalStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_GIGA_STREAM_FrameMoveFuture );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_GIGA_STREAM_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_GIGA_STREAM_EventProcess );
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_GIGA_STREAM_End );

			m_LuaManager.MakeTableReference( "ENSI_SA_GIGA_STREAM", hyperStateData.stateID ); 
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_GIGA_STREAM_Start );
			hyperStateData.StateStartFuture		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_GIGA_STREAM_StartFuture );
			hyperStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_GIGA_STREAM_FrameMoveFuture );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_GIGA_STREAM_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_GIGA_STREAM_EventProcess );
			hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EPR_GIGA_STREAM_End );
		} break;

#endif EVE_ELECTRA
#endif NEW_SKILL_2010_11

#ifdef SERV_EVE_BATTLE_SERAPH
#pragma region 테이저 필라
	case CX2SkillTree::SI_A_EBS_TASER_PILUM:
		{
			m_LuaManager.MakeTableReference( "ENSI_SI_A_EBS_TASER_PILUM", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_Init );
			normalStateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_StartFuture );
			normalStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_Start );
			normalStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_FrameMoveFuture );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_FrameMove );
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_EventProcess );
			normalStateData.StateEndFuture		= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_EndFuture );

			m_LuaManager.MakeTableReference( "ENSI_SI_A_EBS_TASER_PILUM", hyperStateData.stateID );
			hyperStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_Init );
			hyperStateData.StateStartFuture		= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_StartFuture );
			hyperStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_Start );
			hyperStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_FrameMoveFuture );
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_FrameMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_EventProcess );
			hyperStateData.StateEndFuture		= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_TASER_PILUM_EndFuture );
		} break;
#pragma endregion

#pragma region 에너지 니들스
	case CX2SkillTree::SI_SA_EBS_ENERGY_NEEDLES:
		{
			m_LuaManager.MakeTableReference( "ENSI_EBS_ENERGY_NEEDLES", normalStateData.stateID );
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGY_NEEDLES_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGY_NEEDLES_Start );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGY_NEEDLES_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGY_NEEDLES_EventProcess );
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGY_NEEDLES_End );

			m_LuaManager.MakeTableReference( "ENSI_EBS_ENERGY_NEEDLES", hyperStateData.stateID );
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGY_NEEDLES_Init );
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGY_NEEDLES_Start );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGY_NEEDLES_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGY_NEEDLES_EventProcess );
			hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGY_NEEDLES_End );
		} break;
#pragma endregion

#pragma region 에네제틱 하트
	case CX2SkillTree::SI_SA_EBS_ENERGETIC_HEART:
		{
			m_LuaManager.MakeTableReference( "ENSI_EBS_ENERGETIC_HEART", normalStateData.stateID );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGETIC_HEART_Start );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGETIC_HEART_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGETIC_HEART_EventProcess );
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGETIC_HEART_End );

			m_LuaManager.MakeTableReference( "ENSI_EBS_ENERGETIC_HEART", hyperStateData.stateID );
			hyperStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGETIC_HEART_Start );
			hyperStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGETIC_HEART_FrameMove );
			hyperStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGETIC_HEART_EventProcess );
			hyperStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_EBS_ENERGETIC_HEART_End );
		} break;
#pragma endregion

#endif

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	#pragma region SI_SA_EN_ILLUSION_RAY
	case CX2SkillTree::SI_A_EN_ILLUSION_RAY:
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_EN_ILLUSION_RAY", normalStateData.stateID ); 			
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_Illusion_Ray_Init );
			normalStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_Illusion_Ray_Start );
			normalStateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_Illusion_Ray_StartFuture );
			normalStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_Illusion_Ray_FrameMoveFuture );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_Illusion_Ray_FrameMove );
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_Illusion_Ray_EventProcess );
			normalStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_Illusion_Ray_End );

			m_LuaManager.MakeTableReference( "ENSI_SA_EN_ILLUSION_RAY", hyperStateData.stateID );
			hyperStateData.m_bHyperState		= true;
			hyperStateData.StateStart			= normalStateData.StateStart;
			hyperStateData.StateStartFuture		= normalStateData.StateStartFuture;
			hyperStateData.OnFrameMoveFuture	= normalStateData.OnFrameMoveFuture;
			hyperStateData.OnFrameMove			= normalStateData.OnFrameMove;
			hyperStateData.OnEventProcess		= normalStateData.OnEventProcess;
			hyperStateData.StateEnd				= normalStateData.StateEnd;
		} break;
	#pragma endregion 일루전 레이

	#pragma region SI_A_EN_TESLA_SHOCK
	case CX2SkillTree::SI_A_EN_TESLA_SHOCK:
		{
			m_LuaManager.MakeTableReference( "ENSI_A_EN_TESLA_SHOCK", normalStateData.stateID ); 			
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_Tesla_Shock_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_Tesla_Shock_StateStart );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_Tesla_Shock_EventProcess );		
			normalStateData.StateEnd		= SET_CB_FUNC( CX2GUEve, ENSI_A_EN_Tesla_Shock_StateEnd );
			
			m_LuaManager.MakeTableReference( "ENSI_A_EN_TESLA_SHOCK", hyperStateData.stateID );
			hyperStateData.m_bHyperState	= true;
			hyperStateData.StateStart		= normalStateData.StateStart;
			hyperStateData.OnEventProcess	= normalStateData.OnEventProcess;
			hyperStateData.StateEnd			= normalStateData.StateEnd;
		} break;
	#pragma endregion 테슬라 쇼크

	#pragma region SI_SA_EEG_HORNET_STING_SHAPED_CHARGE
	case CX2SkillTree::SI_A_EEG_HORNET_STING_SHAPED_CHARGE:
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_EEG_HORNET_STING_SHAPED_CHARGE", normalStateData.stateID );
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_Hornet_Sting_Shaped_Charge_Init );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_Hornet_Sting_Shaped_Charge_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEG_Hornet_Sting_Shaped_Charge_EventProcess );	

			m_LuaManager.MakeTableReference( "ENSI_SA_EEG_HORNET_STING_SHAPED_CHARGE", hyperStateData.stateID );
			hyperStateData.m_bHyperState	= true;
			hyperStateData.OnFrameMove		= normalStateData.OnFrameMove;
			hyperStateData.OnEventProcess	= normalStateData.OnEventProcess;

		} break;
	#pragma endregion 호넷 스팅 - 쉐이프트 차지

	#pragma region SI_SA_ENS_ATOMIC_BLASTER_SONICGUN
	case CX2SkillTree::SI_A_ENS_ATOMIC_BLASTER_SONICGUN:
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_ENS_ATOMIC_BLASTER_SONICGUN", normalStateData.stateID ); 			
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_Atomic_Blaster_SonicGun_Init );
			normalStateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_Atomic_Blaster_SonicGun_Start );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_Atomic_Blaster_SonicGun_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_Atomic_Blaster_SonicGun_EventProcess );

			m_LuaManager.MakeTableReference( "ENSI_SA_ENS_ATOMIC_BLASTER_SONICGUN", hyperStateData.stateID ); 
			hyperStateData.m_bHyperState	= true;
			hyperStateData.StateStart		= normalStateData.StateStart;
			hyperStateData.OnFrameMove		= normalStateData.OnFrameMove;
			hyperStateData.OnEventProcess	= normalStateData.OnEventProcess;
		} break;
	#pragma endregion 아토믹 블래스터 - 소닉건

	#pragma region SI_SA_EEL_SWEEP_ROLLING_TRI_VULCAN
	case CX2SkillTree::SI_SA_EEL_SWEEP_ROLLING_TRI_VULCAN:
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_EEL_SWEEP_ROLLING_TRI_VULCAN_READY", normalStateData.stateID );				
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Ready_Init );
			normalStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Ready_Start );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Ready_FrameMove );
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Ready_EventProcess );

			m_LuaManager.MakeTableReference( "ENSI_SA_EEL_SWEEP_ROLLING_TRI_VULCAN_READY", hyperStateData.stateID );
			hyperStateData.m_bHyperState	= true;
			hyperStateData.StateStart		= normalStateData.StateStart;
			hyperStateData.OnFrameMove		= normalStateData.OnFrameMove;
			hyperStateData.OnEventProcess	= normalStateData.OnEventProcess;

			{
				UserUnitStateData stateData;
				
				stateData.Init();
				stateData.stateID			= ENSI_SA_EEN_SWEEP_ROLLING_TRI_VULCAN_FIRE;
				m_LuaManager.MakeTableReference( "ENSI_SA_EEL_SWEEP_ROLLING_TRI_VULCAN_FIRE", stateData.stateID );
				stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Fire_Start );
				stateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Fire_FrameMove );
				stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Fire_EventProcess );
				stateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Fire_End );
				m_StateList[stateData.stateID] = stateData;

				stateData.Init();
				stateData.stateID			= ENSI_SA_EEN_SWEEP_ROLLING_TRI_VULCAN_END;
				m_LuaManager.MakeTableReference( "ENSI_SA_EEL_SWEEP_ROLLING_TRI_VULCAN_END", stateData.stateID );
				stateData.StateStart		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_End_Start );
				stateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_End_EventProcess );
				m_StateList[stateData.stateID] = stateData;
			}
		} break;
	#pragma endregion 스위프 롤링 - 트라이 발칸

	#pragma region SI_SA_EAT_HEAVENS_FIST_SWEEPER
	case CX2SkillTree::SI_SA_EAT_HEAVENS_FIST_SWEEPER:
		{
			m_LuaManager.MakeTableReference( "ENSI_A_EAT_HEAVENS_FIST_SWEEPER", normalStateData.stateID ); 			
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_Heavens_Fist_Sweeper_Init );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_Heavens_Fist_Sweeper_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EAT_Heavens_Fist_Sweeper_EventProcess );


			m_LuaManager.MakeTableReference( "ENSI_A_EAT_HEAVENS_FIST_SWEEPER", hyperStateData.stateID ); 
			hyperStateData.m_bHyperState	= true;
			hyperStateData.OnFrameMove		= normalStateData.OnFrameMove;
			hyperStateData.OnEventProcess	= normalStateData.OnEventProcess;
		} break;
	#pragma endregion 헤븐즈 피스트 - 스위퍼

	#pragma region SI_SA_ENS_ASSUALT_SPEAR
	case CX2SkillTree::SI_SA_ENS_ASSUALT_SPEAR_ANNIHILATOR:
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_ENS_ASSUALT_SPEAR", normalStateData.stateID ); 			
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_Assualt_Spear_Init );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_Assualt_Spear_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_SA_ENS_Assualt_Spear_EventProcess );


			m_LuaManager.MakeTableReference( "ENSI_SA_ENS_ASSUALT_SPEAR", hyperStateData.stateID ); 
			hyperStateData.m_bHyperState	= true;
			hyperStateData.OnFrameMove		= normalStateData.OnFrameMove;
			hyperStateData.OnEventProcess	= normalStateData.OnEventProcess;
		} break;
	#pragma endregion 어설트 스피어 - 네메시스

	#pragma region SI_A_EEP_SPIT_FIRE_GRENADE
	case CX2SkillTree::SI_A_EEP_SPIT_FIRE_GRENADE:
		{
			m_LuaManager.MakeTableReference( "ENSI_A_EEP_SPIT_FIRE_GRENADE", normalStateData.stateID );
			normalStateData.StateInit		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEP_Spit_Fire_Grenade_Init );
			normalStateData.OnFrameMove		= SET_CB_FUNC( CX2GUEve, ENSI_A_EEP_Spit_Fire_Grenade_FrameMove );
			normalStateData.OnEventProcess	= SET_CB_FUNC( CX2GUEve, ENSI_A_EEP_Spit_Fire_Grenade_EventProcess );

			m_LuaManager.MakeTableReference( "ENSI_A_EEP_SPIT_FIRE_GRENADE", hyperStateData.stateID );
			hyperStateData.m_bHyperState	= true;
			hyperStateData.OnFrameMove		= normalStateData.OnFrameMove;
			hyperStateData.OnEventProcess	= normalStateData.OnEventProcess;

		} break;
	#pragma endregion 스핏 파이어 - 그레네이드

	#pragma region SI_A_EBS_KUGELBLITZ
	case CX2SkillTree::SI_A_EBS_KUGELBLITZ:
		{
			m_LuaManager.MakeTableReference( "ENSI_A_EBS_KUGELBLITZ", normalStateData.stateID );
			normalStateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_Kugelblitz_StartFuture );
			normalStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_Kugelblitz_Start );
			normalStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_Kugelblitz_FrameMoveFuture );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_Kugelblitz_FrameMove );
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_Kugelblitz_EventProcess );
			normalStateData.StateEndFuture		= SET_CB_FUNC( CX2GUEve, ENSI_A_EBS_Kugelblitz_EndFuture );

			m_LuaManager.MakeTableReference( "ENSI_A_EBS_KUGELBLITZ", hyperStateData.stateID );
			hyperStateData.m_bHyperState		= true;
			hyperStateData.StateStartFuture		= normalStateData.StateStartFuture;
			hyperStateData.StateStart			= normalStateData.StateStart;
			hyperStateData.OnFrameMoveFuture	= normalStateData.OnFrameMoveFuture;
			hyperStateData.OnFrameMove			= normalStateData.OnFrameMove;
			hyperStateData.OnEventProcess		= normalStateData.OnEventProcess;
			hyperStateData.StateEndFuture		= normalStateData.StateEndFuture;
		} break;
	#pragma endregion 쿠글블릿츠

	#pragma region SI_SA_EEL_LINEAR_DIVIDER
	case CX2SkillTree::SI_SA_EEL_LINEAR_DIVIDER:
		{
			m_LuaManager.MakeTableReference( "ENSI_SA_EEL_LINEAR_DIVIDER", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_LINEAR_DIVIDER_Init );
			normalStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_LINEAR_DIVIDER_Start );
			normalStateData.StateStartFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_LINEAR_DIVIDER_StartFuture );
			normalStateData.OnFrameMoveFuture	= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_LINEAR_DIVIDER_FrameMoveFuture );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_LINEAR_DIVIDER_FrameMove );
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_LINEAR_DIVIDER_EventProcess );
			normalStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_SA_EEL_LINEAR_DIVIDER_End );

			m_LuaManager.MakeTableReference( "ENSI_SA_EEL_LINEAR_DIVIDER", hyperStateData.stateID );
			hyperStateData.m_bHyperState		= true;
			hyperStateData.StateStart			= normalStateData.StateStart;
			hyperStateData.StateStartFuture		= normalStateData.StateStartFuture;
			hyperStateData.OnFrameMoveFuture	= normalStateData.OnFrameMoveFuture;
			hyperStateData.OnFrameMove			= normalStateData.OnFrameMove;
			hyperStateData.OnEventProcess		= normalStateData.OnEventProcess;
			hyperStateData.StateEnd				= normalStateData.StateEnd;
		} break;
	#pragma endregion 드레드 쇼크

#endif //UPGRADE_SKILL_SYSTEM_2013

#ifdef FINALITY_SKILL_SYSTEM //김창한
	case CX2SkillTree::SI_HA_EEP_LINK_OVERCHARGE_ILLUSION:
		{
			m_LuaManager.MakeTableReference( "ENSI_HA_EEP_LINK_OVERCHARGE_ILLUSION", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_HA_EEP_LINK_OVERCHARGE_ILLUSION_Init );
			normalStateData.StateStart			= SET_CB_FUNC( CX2GUEve, ENSI_HA_EEP_LINK_OVERCHARGE_ILLUSION_Start );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_HA_EEP_LINK_OVERCHARGE_ILLUSION_FrameMove );	
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_HA_EEP_LINK_OVERCHARGE_ILLUSION_EventProcess );
			normalStateData.StateEnd			= SET_CB_FUNC( CX2GUEve, ENSI_HA_EEP_LINK_OVERCHARGE_ILLUSION_End );

			m_LuaManager.MakeTableReference( "ENSI_HA_EEP_LINK_OVERCHARGE_ILLUSION", hyperStateData.stateID );
			hyperStateData.StateStart			= normalStateData.StateStart;
			hyperStateData.OnFrameMove			= normalStateData.OnFrameMove;
			hyperStateData.OnEventProcess		= normalStateData.OnEventProcess;
			hyperStateData.StateEnd				= normalStateData.StateEnd;
		} break;

	case CX2SkillTree::SI_HA_ENS_LUNATIC_SCUD:
		{
			m_LuaManager.MakeTableReference( "ENSI_HA_ENS_LUNATIC_SCUD", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_HA_ENS_LUNATIC_SCUD_Init );
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_HA_ENS_LUNATIC_SCUD_EventProcess );

			m_LuaManager.MakeTableReference( "ENSI_HA_ENS_LUNATIC_SCUD", hyperStateData.stateID );
			hyperStateData.OnEventProcess		= normalStateData.OnEventProcess;
		} break;

	case CX2SkillTree::SI_HA_EBS_PSYCHIC_ARTILLERRY :
		{
			m_LuaManager.MakeTableReference( "ENSI_HA_EBS_PSYCHIC_ARTILLERY", normalStateData.stateID );
			normalStateData.StateInit			= SET_CB_FUNC( CX2GUEve, ENSI_HA_EBS_PSYCHIC_ARTILLERY_Init );
			normalStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_HA_EBS_PSYCHIC_ARTILLERY_FrameMove );
			normalStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_HA_EBS_PSYCHIC_ARTILLERY_EventProcess );	

			m_LuaManager.MakeTableReference( "ENSI_HA_EBS_PSYCHIC_ARTILLERY", hyperStateData.stateID );
			hyperStateData.m_bHyperState		= true;
			hyperStateData.OnFrameMove			= SET_CB_FUNC( CX2GUEve, ENSI_HA_EBS_PSYCHIC_ARTILLERY_FrameMove );
			hyperStateData.OnEventProcess		= SET_CB_FUNC( CX2GUEve, ENSI_HA_EBS_PSYCHIC_ARTILLERY_EventProcess );	
		} break;
#endif //FINALITY_SKILL_SYSTEM

	}
}

/*virtual*/ void CX2GUEve::SetEquippedSkillLevel( const CX2SkillTree::SKILL_ID eSkillID_, const bool bChangeAll_ )
{
#ifdef EVE_ELECTRA
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	if ( true == bChangeAll_ || CX2SkillTree::SI_SA_EEL_SWEEP_ROLLING_OVER_CHARGE == eSkillID_ )
#else //UPGRADE_SKILL_SYSTEM_2013
	if ( true == bChangeAll_ || CX2SkillTree::SI_SA_EEL_SWEEP_ROLLING == eSkillID_ )
#endif //UPGRADE_SKILL_SYSTEM_2013
	{
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_SA_EEL_SWEEP_ROLLING_OVER_CHARGE );
#else //UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_SA_EEL_SWEEP_ROLLING );
#endif //UPGRADE_SKILL_SYSTEM_2013
		if( NULL != pSkillTemplet )
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			if ( NULL == GetUnit() )
				return;
	
			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	
			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨

			{
				UserUnitStateData& normalStateData = m_StateList[ ENSI_SA_EPR_SWEEP_ROLLING_CHARGE ];
				normalStateData.m_SPLevel = iSkillTempletLevel;
				normalStateData.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel );
				normalStateData.m_eSkillID = pSkillTemplet->m_eID;

				UserUnitStateData& hyperStateData = m_StateList[ ENSI_SA_EPR_SWEEP_ROLLING_CHARGE ];
				hyperStateData.m_SPLevel = iSkillTempletLevel;
				hyperStateData.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel );
				hyperStateData.m_eSkillID = pSkillTemplet->m_eID;

			}

			{
				UserUnitStateData& normalStateData = m_StateList[ ENSI_SA_EPR_SWEEP_ROLLING_FIRE ];
				normalStateData.m_SPLevel = iSkillTempletLevel;
				normalStateData.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel );
				normalStateData.m_eSkillID = pSkillTemplet->m_eID;

				UserUnitStateData& hyperStateData = m_StateList[ ENSI_SA_EPR_SWEEP_ROLLING_FIRE ];
				hyperStateData.m_SPLevel = iSkillTempletLevel;
				hyperStateData.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel );
				hyperStateData.m_eSkillID = pSkillTemplet->m_eID;
			}

			{
				UserUnitStateData& normalStateData = m_StateList[ ENSI_SA_EPR_SWEEP_ROLLING_END ];
				normalStateData.m_SPLevel = iSkillTempletLevel;
				normalStateData.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel );
				normalStateData.m_eSkillID = pSkillTemplet->m_eID;

				UserUnitStateData& hyperStateData = m_StateList[ ENSI_SA_EPR_SWEEP_ROLLING_END ];
				hyperStateData.m_SPLevel = iSkillTempletLevel;
				hyperStateData.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel );
				hyperStateData.m_eSkillID = pSkillTemplet->m_eID;
			}
	#else // UPGRADE_SKILL_SYSTEM_2013
			{
				UserUnitStateData& normalStateData = m_StateList[ ENSI_SA_EPR_SWEEP_ROLLING_CHARGE ];
				normalStateData.m_SPLevel = pSkillTemplet->m_iSkillLevel;
				normalStateData.m_fPowerRate = pSkillTemplet->m_fPowerRate;
				normalStateData.m_eSkillID = pSkillTemplet->m_eID;

				UserUnitStateData& hyperStateData = m_StateList[ ENSI_SA_EPR_SWEEP_ROLLING_CHARGE ];
				hyperStateData.m_SPLevel = pSkillTemplet->m_iSkillLevel;
				hyperStateData.m_fPowerRate = pSkillTemplet->m_fPowerRate;
				hyperStateData.m_eSkillID = pSkillTemplet->m_eID;

			}

			{
				UserUnitStateData& normalStateData = m_StateList[ ENSI_SA_EPR_SWEEP_ROLLING_FIRE ];
				normalStateData.m_SPLevel = pSkillTemplet->m_iSkillLevel;
				normalStateData.m_fPowerRate = pSkillTemplet->m_fPowerRate;
				normalStateData.m_eSkillID = pSkillTemplet->m_eID;

				UserUnitStateData& hyperStateData = m_StateList[ ENSI_SA_EPR_SWEEP_ROLLING_FIRE ];
				hyperStateData.m_SPLevel = pSkillTemplet->m_iSkillLevel;
				hyperStateData.m_fPowerRate = pSkillTemplet->m_fPowerRate;
				hyperStateData.m_eSkillID = pSkillTemplet->m_eID;
			}

			{
				UserUnitStateData& normalStateData = m_StateList[ ENSI_SA_EPR_SWEEP_ROLLING_END ];
				normalStateData.m_SPLevel = pSkillTemplet->m_iSkillLevel;
				normalStateData.m_fPowerRate = pSkillTemplet->m_fPowerRate;
				normalStateData.m_eSkillID = pSkillTemplet->m_eID;

				UserUnitStateData& hyperStateData = m_StateList[ ENSI_SA_EPR_SWEEP_ROLLING_END ];
				hyperStateData.m_SPLevel = pSkillTemplet->m_iSkillLevel;
				hyperStateData.m_fPowerRate = pSkillTemplet->m_fPowerRate;
				hyperStateData.m_eSkillID = pSkillTemplet->m_eID;
			}
	#endif // UPGRADE_SKILL_SYSTEM_2013
		}
	}
#endif EVE_ELECTRA

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	if ( true == bChangeAll_ || CX2SkillTree::SI_SA_EEL_SWEEP_ROLLING_TRI_VULCAN == eSkillID_ )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_SA_EEL_SWEEP_ROLLING_TRI_VULCAN );
		if( NULL != pSkillTemplet )
		{
			if ( NULL == GetUnit() )
				return;
	
			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	
			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
			{
				UserUnitStateData& normalStateData = m_StateList[ ENSI_SA_EEN_SWEEP_ROLLING_TRI_VULCAN_FIRE ];
				normalStateData.m_SPLevel = iSkillTempletLevel;
				normalStateData.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel );
				normalStateData.m_eSkillID = pSkillTemplet->m_eID;

				UserUnitStateData& hyperStateData = m_StateList[ ENSI_SA_EEN_SWEEP_ROLLING_TRI_VULCAN_FIRE ];
				hyperStateData.m_SPLevel = iSkillTempletLevel;
				hyperStateData.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel );
				hyperStateData.m_eSkillID = pSkillTemplet->m_eID;
			}

			{
				UserUnitStateData& normalStateData = m_StateList[ ENSI_SA_EEN_SWEEP_ROLLING_TRI_VULCAN_END ];
				normalStateData.m_SPLevel = iSkillTempletLevel;
				normalStateData.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel );
				normalStateData.m_eSkillID = pSkillTemplet->m_eID;

				UserUnitStateData& hyperStateData = m_StateList[ ENSI_SA_EEN_SWEEP_ROLLING_TRI_VULCAN_END ];
				hyperStateData.m_SPLevel = iSkillTempletLevel;
				hyperStateData.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel );
				hyperStateData.m_eSkillID = pSkillTemplet->m_eID;
			}
		}
	}
#endif //UPGRADE_SKILL_SYSTEM_2013
}

#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
/*static*/
void	CX2GUEve::AppendComponentToDeviceList( CKTDXDeviceDataList& listInOut_ )
{
}
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD



void CX2GUEve::InitComponent()
{
	CX2GUUser::InitComponent();

	if( m_LuaManager.BeginTable( "INIT_COMPONENT" ) == true )
	{
#ifdef UNIT_SLASH_TRACE_MANAGER_TEST
		AddUnitSlashData( CX2UnitSlashTraceManager::STC_NONE );
#endif UNIT_SLASH_TRACE_MANAGER_TEST

		m_LuaManager.EndTable();
	}
}




void CX2GUEve::InitEquippedActiveSkillState(bool bOnlySkillLevel /* = false  */)
{
	CX2GUUser::InitEquippedActiveSkillState(bOnlySkillLevel);

	// 메가일랙트론볼 슬롯아이디를 검색.
	if( GetUnit() != NULL )
	{
		m_sMegaElectronBallData.SetSlotID( -1 );
		for( int iSlot = 0; iSlot < EQUIPPED_SKILL_SLOT_COUNT*2; ++iSlot )	// 슬롯 인덱스.
		{
			const bool bSlotB = (iSlot > 3) ? true : false;
			const int iSlotIndex = (iSlot > 3) ? iSlot - 4 : iSlot;
			//슬롯 B가 활성화 되지 않으면 슬롯 A만 확인하도록 break;
			if( false == g_pData->GetMyUser()->GetSelectUnit()->GetUnitData().m_UserSkillTree.GetEnabledSkillSlotB() 
				&& bSlotB == true)
			{
				break;
			}
			const CX2UserSkillTree::SkillSlotData* pSlotData = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillSlot( iSlotIndex, bSlotB );

			if( pSlotData != NULL )
			{
				if( pSlotData->m_eID == CX2SkillTree::SI_A_EN_MEGA_ELECTRONBALL )
				{
					m_sMegaElectronBallData.SetSlotID( iSlot );
					break;
				}
			}
		}

#ifdef SERV_EVE_BATTLE_SERAPH
		// 테이저 필라 슬롯아이디를 검색.
		m_sTaserPilumData.SetSlotID( TASER_PILUM_Data::ST_A, -1 );
		m_sTaserPilumData.SetSlotID( TASER_PILUM_Data::ST_B, -1 );

		for( int iBool = 0; iBool < static_cast<int>(TASER_PILUM_Data::ST_END); ++iBool )	// 슬롯 A,B
		{
			for( int iSlot = 0; iSlot < EQUIPPED_SKILL_SLOT_COUNT * 2; ++iSlot )	// 슬롯 인덱스.
			{
				const bool bSlotB = (iSlot > 3) ? true : false;
				const int iSlotIndex = (iSlot > 3) ? iSlot - 4 : iSlot;
				//슬롯 B가 활성화 되지 않으면 슬롯 A만 확인하도록 break;
				if( false == g_pData->GetMyUser()->GetSelectUnit()->GetUnitData().m_UserSkillTree.GetEnabledSkillSlotB() 
					&& bSlotB == true)
				{
					break;
				}
				const CX2UserSkillTree::SkillSlotData* pSlotData = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillSlot( iSlotIndex, bSlotB );

				if( pSlotData != NULL )
				{
					if( pSlotData->m_eID == CX2SkillTree::SI_A_EBS_TASER_PILUM )
					{
						m_sTaserPilumData.SetSlotID( static_cast<TASER_PILUM_Data::SLOT_TYPE>(iBool), iSlot );
						break;
					}
				}
			}
		}
#endif	SERV_EVE_BATTLE_SERAPH
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet(CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL);
		if( NULL != pSkillTemplet )
			const_cast<CX2SkillTree::SkillTemplet*>(pSkillTemplet)->m_eActiveSkillUseCondtion = CX2SkillTree::ASUT_GROUND;

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		// 쿠글블릿츠 슬롯아이디를 검색.
		m_sKugelBlitz_Data.SetSlotID( SKugelBlitz_Data::ST_A, -1 );
		m_sKugelBlitz_Data.SetSlotID( SKugelBlitz_Data::ST_B, -1 );

		for( int iBool = 0; iBool < static_cast<int>( SKugelBlitz_Data::ST_END ); ++iBool )	// 슬롯 A,B
		{
			for( int iSlot = 0; iSlot < EQUIPPED_SKILL_SLOT_COUNT * 2; ++iSlot )	// 슬롯 인덱스.
			{
				const bool bSlotB = (iSlot > 3) ? true : false;
				const int iSlotIndex = (iSlot > 3) ? iSlot - 4 : iSlot;
				
				if( false == g_pData->GetMyUser()->GetSelectUnit()->GetUnitData().m_UserSkillTree.GetEnabledSkillSlotB() 
					&& bSlotB == true)
				{
					break;
				}
				const CX2UserSkillTree::SkillSlotData* pSlotData = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillSlot( iSlotIndex, bSlotB );

				if( pSlotData != NULL )
				{
					if( pSlotData->m_eID == CX2SkillTree::SI_A_EBS_KUGELBLITZ )
					{
						m_sKugelBlitz_Data.SetSlotID( static_cast<SKugelBlitz_Data::SLOT_TYPE>( iBool ), iSlot );
						break;
					}
				}
			}
		}
#endif //UPGRADE_SKILL_SYSTEM_2013
	}

	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_SA_EEG_QUEENS_THRONE );
	if( NULL != pSkillTemplet )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			if ( NULL == GetUnit() )
				return;
	
			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	
			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
			m_sEGQueensThrone.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel );
	#else // UPGRADE_SKILL_SYSTEM_2013
			m_sEGQueensThrone.m_fPowerRate = pSkillTemplet->m_fPowerRate;
	#endif // UPGRADE_SKILL_SYSTEM_2013
	}
}



void CX2GUEve::InitPassiveSkillState()
{
	CX2GUUser::InitPassiveSkillState();

	// kimhc // 2009-11-27 // 패시브 스킬 초기화 시에 항등원으로 초기화
	m_SkillRelatedData.m_fStatAtkRateOfSummoned = 1.f;

	// 마나 회복량 증가 값 초기화.
	SetAdditionalMPChangeRateByPassive(0.f);
	const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	int iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EN_REFINED_STEP, true );

	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EN_REFINED_STEP );

		if( NULL != pSkillTemplet )
		{
			const float fMoveSpeed = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MOVE_SPEED, iSkillLevel );
			m_AdditionalWalkSpeed.SetPassiveMultiple( m_AdditionalWalkSpeed.GetPassiveMultiple() * fMoveSpeed );
			m_AdditionalDashSpeed.SetPassiveMultiple( m_AdditionalDashSpeed.GetPassiveMultiple() * fMoveSpeed );

			const float fJumpSpeed = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_JUMP_SPEED, iSkillLevel );
			m_AdditionalJumpPower.SetPassiveMultiple( m_AdditionalJumpPower.GetPassiveMultiple() * fJumpSpeed );
			m_AdditionalDashJumpPower.SetPassiveMultiple( m_AdditionalDashJumpPower.GetPassiveMultiple() * fJumpSpeed );
		}
	}
#else //UPGRADE_SKILL_SYSTEM_2013
	int iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_COMMON_REFINED_STEP );

	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_COMMON_REFINED_STEP, iSkillLevel );

		if( NULL != pSkillTemplet )
		{
			const float fMoveSpeed = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MOVE_SPEED );
			m_AdditionalWalkSpeed.SetPassiveMultiple( m_AdditionalWalkSpeed.GetPassiveMultiple() * fMoveSpeed );
			m_AdditionalDashSpeed.SetPassiveMultiple( m_AdditionalDashSpeed.GetPassiveMultiple() * fMoveSpeed );

			const float fJumpSpeed = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_JUMP_SPEED );
			m_AdditionalJumpPower.SetPassiveMultiple( m_AdditionalJumpPower.GetPassiveMultiple() * fJumpSpeed );
			m_AdditionalDashJumpPower.SetPassiveMultiple( m_AdditionalDashJumpPower.GetPassiveMultiple() * fJumpSpeed );
		}
	}
#endif //UPGRADE_SKILL_SYSTEM_2013

#ifdef EVE_ELECTRA
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EN_PHOTON_BOOSTER, true ); // SI_P_EPR_PHOTON_BOOSTER 광자 추진기

	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EN_PHOTON_BOOSTER );

		if( NULL != pSkillTemplet )
		{
			const float fMoveSpeed = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MOVE_SPEED, iSkillLevel );
			m_AdditionalWalkSpeed.SetPassiveMultiple( m_AdditionalWalkSpeed.GetPassiveMultiple() * fMoveSpeed );
			m_AdditionalDashSpeed.SetPassiveMultiple( m_AdditionalDashSpeed.GetPassiveMultiple() * fMoveSpeed );
		}
	}
#else //UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EEL_PHOTON_BOOSTER ); // SI_P_EPR_PHOTON_BOOSTER 광자 추진기

	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EEL_PHOTON_BOOSTER, iSkillLevel );

		if( NULL != pSkillTemplet )
		{
			const float fMoveSpeed = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MOVE_SPEED );
			m_AdditionalWalkSpeed.SetPassiveMultiple( m_AdditionalWalkSpeed.GetPassiveMultiple() * fMoveSpeed );
			m_AdditionalDashSpeed.SetPassiveMultiple( m_AdditionalDashSpeed.GetPassiveMultiple() * fMoveSpeed );
		}
	}
#endif //UPGRADE_SKILL_SYSTEM_2013
#endif EVE_ELECTRA

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EN_QUEENS_CONTROL, true );
#else // UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EN_QUEENS_CONTROL );
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevel > 0 )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EN_QUEENS_CONTROL );
		if( NULL != pSkillTemplet )
		{
			m_SkillRelatedData.m_fStatAtkRateOfSummoned *= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SUMMON_ATK_REL, iSkillLevel );
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EN_QUEENS_CONTROL, iSkillLevel );
		if( NULL != pSkillTemplet )
		{
			m_SkillRelatedData.m_fStatAtkRateOfSummoned *= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SUMMON_ATK_REL );
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013
	}

#ifdef EVE_ELECTRA
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EN_PHOTON_BOOSTER, true ); // SI_P_EPR_PHOTON_BOOSTER 광자 추진기

	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EN_PHOTON_BOOSTER );

		if( NULL != pSkillTemplet )
		{
			m_iPhotonBoosterAdditionalDashJumpCount = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_AIR_MOVE_COUNT, iSkillLevel );
		}
	}
#else //UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EEL_PHOTON_BOOSTER ); // SI_P_EPR_PHOTON_BOOSTER 광자 추진기

	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EEL_PHOTON_BOOSTER, iSkillLevel );

		if( NULL != pSkillTemplet )
		{
			m_iPhotonBoosterAdditionalDashJumpCount = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_AIR_MOVE_COUNT );
		}
	}
#endif //UPGRADE_SKILL_SYSTEM_2013
#endif EVE_ELECTRA

#ifdef BALANCE_CODE_NEMESIS_20121213
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EN_REFINED_STEP, true ); // SI_P_COMMON_REFINED_STEP 우아한 발걸음

	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EN_REFINED_STEP );

		if( NULL != pSkillTemplet )
		{
			m_iPhotonBoosterAdditionalDashJumpCount = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_AIR_MOVE_COUNT, iSkillLevel );
		}
	}
#else //UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_COMMON_REFINED_STEP ); // SI_P_COMMON_REFINED_STEP 우아한 발걸음

	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_COMMON_REFINED_STEP, iSkillLevel );

		if( NULL != pSkillTemplet )
		{
			m_iPhotonBoosterAdditionalDashJumpCount = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_AIR_MOVE_COUNT );
		}
	}
#endif //UPGRADE_SKILL_SYSTEM_2013
#endif //BALANCE_CODE_NEMESIS_20121213

	m_fElectronBallRangeRate = 1.f;
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EN_ELECTRONBALL_UP, true );	
#else // UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EN_ELECTRONBALL_UP );	
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevel > 0 )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EN_ELECTRONBALL_UP );
		if( NULL != pSkillTemplet )
		{
			m_fElectronBallRangeRate *= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_RANGE_REL, iSkillLevel );
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EN_ELECTRONBALL_UP, iSkillLevel );
		if( NULL != pSkillTemplet )
		{
			m_fElectronBallRangeRate *= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_RANGE_REL );
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013
	}

#ifdef EVE_ELECTRA
	m_EveElectraSystem.m_fLaserRangeScale = 1.f;
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EEL_SPECTRUM_DYNAMICS, true );	// SI_P_EPR_SPECTRUM_DYNAMICS 분광 역학
#else // UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EEL_SPECTRUM_DYNAMICS );	// SI_P_EPR_SPECTRUM_DYNAMICS 분광 역학
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevel > 0 )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EEL_SPECTRUM_DYNAMICS );
		if( NULL != pSkillTemplet )
		{
			float fRangeScale = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_RANGE_REL, iSkillLevel );
			m_fElectronBallRangeRate *= fRangeScale;
			m_EveElectraSystem.m_fLaserRangeScale *= fRangeScale;
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EEL_SPECTRUM_DYNAMICS, iSkillLevel );
		if( NULL != pSkillTemplet )
		{
			float fRangeScale = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_RANGE_REL );
			m_fElectronBallRangeRate *= fRangeScale;
			m_EveElectraSystem.m_fLaserRangeScale *= fRangeScale;
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		if( iSkillLevel >= 1 )
#else //UPGRADE_SKILL_SYSTEM_2013
		if( iSkillLevel >= 5 )
#endif //UPGRADE_SKILL_SYSTEM_2013
			m_EveElectraSystem.SetEnableSpectrumDynamics( true );
	}
#endif EVE_ELECTRA



	m_fMPConsumeRateElectronBall = 1.f;
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EN_QUEENS_POTENTIAL, true );	
#else // UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EN_QUEENS_POTENTIAL );	
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevel > 0 )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EN_QUEENS_POTENTIAL );
		if( NULL != pSkillTemplet )
		{
			// 값 범위 : -0.01~ -.03 
			float fMPConsumeRel = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_CONSUME_REL, iSkillLevel );
			m_fMPConsumeRateElectronBall *= 1.f + fMPConsumeRel;
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EN_QUEENS_POTENTIAL, iSkillLevel );
		if( NULL != pSkillTemplet )
		{
			m_fMPConsumeRateElectronBall *= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_CONSUME_REL );
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013
	}

#ifdef EVE_ELECTRA
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EEL_ADVANCED_EL_ENERGY_REACTOR, true ); // SI_P_EPR_ADVANCED_EL_ENERGY_REACTOR	
#else // UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EEL_ADVANCED_EL_ENERGY_REACTOR ); // SI_P_EPR_ADVANCED_EL_ENERGY_REACTOR	
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevel > 0 )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EEL_ADVANCED_EL_ENERGY_REACTOR );

		if( NULL != pSkillTemplet )
		{
			float fAddMpChangeRate = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_REGENERATION_ABS, iSkillLevel );

		//{{ mauntain : 김태환 [2012.07.26] 클로킹 메모 쓸쓸한 기다림 버그 수정 ( 작업자 : 엘소드 대만 이지헌 )
		#ifdef EVE_MEMO5_BUG_FIX
			SetAdditionalMPChangeRateByPassive( fAddMpChangeRate );
			ResetMPChangeRate( GetOriginalMPChangeRate());
		#else  EVE_MEMO5_BUG_FIX
			ResetMPChangeRate( GetOriginalMPChangeRate() + fAddMpChangeRate );
		#endif EVE_MEMO5_BUG_FIX
		//}}
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EEL_ADVANCED_EL_ENERGY_REACTOR, iSkillLevel );

		if( NULL != pSkillTemplet )
		{
			float fAddMpChangeRate = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_REGENERATION_ABS );

		//{{ mauntain : 김태환 [2012.07.26] 클로킹 메모 쓸쓸한 기다림 버그 수정 ( 작업자 : 엘소드 대만 이지헌 )
		#ifdef EVE_MEMO5_BUG_FIX
			SetAdditionalMPChangeRateByPassive( fAddMpChangeRate );
			ResetMPChangeRate( GetOriginalMPChangeRate());
		#else  EVE_MEMO5_BUG_FIX
			ResetMPChangeRate( GetOriginalMPChangeRate() + fAddMpChangeRate );
		#endif EVE_MEMO5_BUG_FIX
		//}}
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013		
	}
#endif EVE_ELECTRA


#ifdef SKILL_30_TEST
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_A_EAT_OBERON_GUARD );	
	if( iSkillLevel > 0 )
	{
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	#ifdef PVP_SEASON2
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_A_EAT_OBERON_GUARD  );
	#else
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_A_EAT_OBERON_GUARD, iSkillLevel );
	#endif

		if( NULL != pSkillTemplet )
		{
			m_sATOveronGuardData.SetProjectileSize( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_SIZE, iSkillLevel ) );
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO12 ) == true )
				m_sATOveronGuardData.SetEffectiveTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillLevel ) / 2.f );
			else
				m_sATOveronGuardData.SetEffectiveTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillLevel ) );
		}
#else // UPGRADE_SKILL_SYSTEM_2013
	#ifdef PVP_SEASON2
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_A_EAT_OBERON_GUARD,
			min( iSkillLevel +GetSkillLevelUpNum( CX2SkillTree::SI_A_EAT_OBERON_GUARD ), 10 ) );
	#else
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_A_EAT_OBERON_GUARD, iSkillLevel );
	#endif

		if( NULL != pSkillTemplet )
		{
			m_sATOveronGuardData.SetProjectileSize( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_SIZE ) );
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO12 ) == true )
				m_sATOveronGuardData.SetEffectiveTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME ) / 2.f );
			else
				m_sATOveronGuardData.SetEffectiveTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME ) );
		}
#endif // UPGRADE_SKILL_SYSTEM_2013
	}
#endif SKILL_30_TEST


#ifdef EVE_SECOND_CLASS_CHANGE
	// oasis907 : 김상윤 [2010.1.29] //  엠프레스 일렉트론볼 마스터 패시브
	m_fAttackPowerRateElectronBall = 1.f;
	m_fForceDownValueRateElectronBall = 1.f;
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EEP_ELECTRONBALL_MASTER, true );
#else // UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EEP_ELECTRONBALL_MASTER );
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevel > 0 )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EEP_ELECTRONBALL_MASTER );
		if( NULL != pSkillTemplet )
		{
			m_fAttackPowerRateElectronBall *= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_DAMAGE_REL, iSkillLevel );
			m_fForceDownValueRateElectronBall *= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FORCE_DOWN_RANGE_REL, iSkillLevel );
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EEP_ELECTRONBALL_MASTER, iSkillLevel );
		if( NULL != pSkillTemplet )
		{
			m_fAttackPowerRateElectronBall *= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_DAMAGE_REL );
			m_fForceDownValueRateElectronBall *= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FORCE_DOWN_RANGE_REL );
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013
	}
#endif EVE_SECOND_CLASS_CHANGE

	//{{ kimhc // 2010.11.2 // 엠프레스 - 충전 추진기
#ifdef	NEW_SKILL_2010_11
	const CX2SkillTree::SkillTemplet* pSkillTempletChargingBooster = userSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_P_EEP_CHARGING_BOOSTER );

	if ( NULL != pSkillTempletChargingBooster )
	{
#ifdef  X2OPTIMIZE_REMOVE_UNNECESSARY_SHARED_PTR    
        if ( !m_ChargingBoosterSkillDataBasePtr )
#else   X2OPTIMIZE_REMOVE_UNNECESSARY_SHARED_PTR    
		if ( 0 == m_ChargingBoosterSkillDataBasePtr.use_count() )
#endif  X2OPTIMIZE_REMOVE_UNNECESSARY_SHARED_PTR    
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			const int iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EEP_CHARGING_BOOSTER, true );

			m_ChargingBoosterSkillDataBasePtr = CSkillDataBase::CSkillCreateSkillDataBasePtr( CX2SkillTree::SI_P_EEP_CHARGING_BOOSTER, 
				pSkillTempletChargingBooster->GetSkillCoolTimeValue( iSkillLevel ) );
	#else // UPGRADE_SKILL_SYSTEM_2013
			m_ChargingBoosterSkillDataBasePtr = CSkillDataBase::CSkillCreateSkillDataBasePtr( CX2SkillTree::SI_P_EEP_CHARGING_BOOSTER, 
				pSkillTempletChargingBooster->m_fSkillCoolTime );
	#endif // UPGRADE_SKILL_SYSTEM_2013
		}		

		// 처음 시작시 바로 사용할 수 있도록 쿨타임 시간을 넣어줌
		m_ChargingBoosterSkillDataBasePtr->SetCoolTime( 15.0f );
		m_ChargingBoosterSkillDataBasePtr->SetTimerBasedOnCoolTime( m_ChargingBoosterSkillDataBasePtr->GetCoolTime() );
	}
#endif	NEW_SKILL_2010_11
	//}} kimhc // 2010.11.2 // 엠프레스 - 충전 추진기
#ifdef SERV_EVE_BATTLE_SERAPH
#pragma region 고출력 전자회로
	const CX2SkillTree::SkillTemplet* pSkillTempletHighpoweredElectrics = userSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_P_EBS_HIGHPOWERED_ELECTRICS );

	if ( NULL != pSkillTempletHighpoweredElectrics )
	{
		m_bHighPoweredElectrics = true;
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EBS_HIGHPOWERED_ELECTRICS, true ) );	/// 스킬 레벨

		m_fHighPoweredElectricsSpeed = pSkillTempletHighpoweredElectrics->GetSkillAbilityValue( CX2SkillTree::SA_MOVE_SPEED, iSkillTempletLevel );
	#else // UPGRADE_SKILL_SYSTEM_2013
		m_fHighPoweredElectricsSpeed = pSkillTempletHighpoweredElectrics->GetSkillAbilityValue( CX2SkillTree::SA_MOVE_SPEED );
	#endif // UPGRADE_SKILL_SYSTEM_2013
	}
#pragma endregion

#pragma region 초광학 연구
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EBS_HYPER_OPTICAL_RESEARCH, true );
#else // UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EBS_HYPER_OPTICAL_RESEARCH );
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevel > 0 )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EBS_HYPER_OPTICAL_RESEARCH );
		if( NULL != pSkillTemplet )
		{
			float fScaleRate = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SIZE_ABS, iSkillLevel );
			m_EveElectraSystem.m_fHyperOpticalResearchScale = fScaleRate;
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EBS_HYPER_OPTICAL_RESEARCH, iSkillLevel );
		if( NULL != pSkillTemplet )
		{
			float fScaleRate = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SIZE_ABS );
			m_EveElectraSystem.m_fHyperOpticalResearchScale = fScaleRate;
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		if( iSkillLevel >= 1 )
#else //UPGRADE_SKILL_SYSTEM_2013
		if( iSkillLevel >= 5 )
#endif //UPGRADE_SKILL_SYSTEM_2013
			m_EveElectraSystem.SetEnableHyperOpticalResearch( true );
	}
#pragma endregion
#endif

#ifdef BALANCE_CODE_NEMESIS_20121213
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_ENS_ENERGY_OF_CONCENTRATION, true ); //집중의 기운
#else // UPGRADE_SKILL_SYSTEM_2013
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_ENS_ENERGY_OF_CONCENTRATION ); //집중의 기운
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevel > 0 )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_ENS_ENERGY_OF_CONCENTRATION );
		if( NULL != pSkillTemplet )
		{
			const float fCriticalRateValueAtkBase = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_ATK_CRITICAL_RATE_ATK_BASE, iSkillLevel );
			const float fMixAtk = (GetStat().GetStat().m_fAtkMagic + GetStat().GetStat().m_fAtkPhysic) / 2;

			float fPassiveCriticalValue = fMixAtk * fCriticalRateValueAtkBase;
			m_AdditionalCriticalRate.SetOptionValue( m_AdditionalCriticalRate.GetOptionValue() + fPassiveCriticalValue );
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_ENS_ENERGY_OF_CONCENTRATION, iSkillLevel );
		if( NULL != pSkillTemplet )
		{
			const float fCriticalRateValueAtkBase = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_ATK_CRITICAL_RATE_ATK_BASE );
			const float fMixAtk = (GetStat().GetStat().m_fAtkMagic + GetStat().GetStat().m_fAtkPhysic) / 2;

			float fPassiveCriticalValue = fMixAtk * fCriticalRateValueAtkBase;
			m_AdditionalCriticalRate.SetOptionValue( m_AdditionalCriticalRate.GetOptionValue() + fPassiveCriticalValue );
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013
	} 
#endif //BALANCE_CODE_NEMESIS_20121213

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	iSkillLevel = userSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EBS_AMPLIFIED_EL_ENERGY_REACTOR, true ); // 증폭 엘 에너지 반응로
	m_fAddSpectrumTime = m_fAddEnergeticHeartTime = 0.f;
	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EBS_AMPLIFIED_EL_ENERGY_REACTOR );
		if( NULL != pSkillTemplet )
		{
			const float fCriticalRateValueAtkBase = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_ATK_CRITICAL_RATE_ATK_BASE, iSkillLevel );
			const float fMixAtk = (GetStat().GetStat().m_fAtkMagic + GetStat().GetStat().m_fAtkPhysic) / 2;

			float fPassiveCriticalValue = fMixAtk * fCriticalRateValueAtkBase;
			m_AdditionalCriticalRate.SetOptionValue( m_AdditionalCriticalRate.GetOptionValue() + fPassiveCriticalValue );

			float fAddMpChangeRate = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_REGENERATION_ABS, iSkillLevel );
			SetAdditionalMPChangeRateByPassive( fAddMpChangeRate );
			ResetMPChangeRate( GetOriginalMPChangeRate());

			m_fAddSpectrumTime = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillLevel );
			m_fAddEnergeticHeartTime = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME_HYPER, iSkillLevel );
		}
	} 
#endif //UPGRADE_SKILL_SYSTEM_2013
}


#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
/*static*/
void	CX2GUEve::AppendEffectToDeviceList( CKTDXDeviceDataList& listInOut_, CX2DamageManager::EXTRA_DAMAGE_TYPE eDamageType_ )
{
	CX2GUEve::AppendMajorParticleToDeviceList( listInOut_ );
	CX2GUEve::AppendMinorParticleToDeviceList( listInOut_ );
	CX2GameUnit::Weapon::AppendEnchantParticleForBowToDeviceList( listInOut_, eDamageType_ );
}
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD


void CX2GUEve::InitEffect()
{
	CX2GUUser::InitEffect();

	CreateMajorParticleArray();
	CreateMinorParticleArray();
}




/*virtual*/ void CX2GUEve::InitEnchantWeaponEffectUnitSpecific() 
{
	for( UINT i=0; i<m_vecpWeapon.size(); ++i )
	{
		Weapon* pWeapon = m_vecpWeapon[i];
		pWeapon->InitEnchantParticleForBow();
	}
}

void CX2GUEve::DeleteEveMajorParticle()
{
	CX2GUUser::DeleteGUUserMajorParticle();

	CKTDGParticleSystem* pMajorParticleSystem = g_pX2Game->GetMajorParticle();

	for ( int index = 0; index < EVE_MAJOR_PII_END; index++ )
	{
		pMajorParticleSystem->DestroyInstanceHandle( m_ahEveMajorParticleInstance[index] );
	}
}

void CX2GUEve::DeleteEveMinorParticle()
{
	CX2GUUser::DeleteGUUserMinorParticle();

	CKTDGParticleSystem* pMajorParticleSystem = g_pX2Game->GetMinorParticle();

	for ( int index = 0; index < EVE_MINOR_PII_END; index++ )
	{
		m_ahEveMinorParticleInstance[index] = INVALID_PARTICLE_SEQUENCE_HANDLE;
	}
}

void CX2GUEve::InitializeEveMajorParticleArray()
{
	CX2GUUser::InitializeGUUserMajorParticleArray();

	for ( int index = 0; index < EVE_MAJOR_PII_END; index++ )
	{
		m_ahEveMajorParticleInstance[index] = INVALID_PARTICLE_SEQUENCE_HANDLE;
	}
}

#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
/*static*/
void	CX2GUEve::AppendMajorParticleToDeviceList( CKTDXDeviceDataList& listInOut_ )
{
	if ( g_pData->GetGameMajorParticle() == NULL )
		return;

	g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"DamageImpact" );
	g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"DamageImpactCore" );
	g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"DamageImpactSlash" );
	g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"DamageImpactRed" );
	g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"DamageImpactRingRed" );
	g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"DamageImpactCoreRed" );
	g_pData->GetGameMajorParticle()->AppendToDeviceList( listInOut_, L"DamageImpactSlashRed" );
}
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD


/*virtual*/ void CX2GUEve::CreateMajorParticleArray()
{
	CX2GUUser::CreateMajorParticleArray();

	CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

	// small damage 타격을 줬을 때 나오는 파티클
	pSeq = SetCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT,			L"DamageImpact",			2 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT_CORE,		L"DamageImpactCore",		2 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT_SLASH,		L"DamageImpactSlash",		2 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	// AttackResult의 switch case에서 default:로 처리되는 타격에 대한 파티클 (현재는 small 이외의 파티클)
	pSeq = SetCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT_RED,			L"DamageImpactRed",		2 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT_RING_RED,	L"DamageImpactRingRed",		1 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT_CORE_RED,	L"DamageImpactCoreRed",		1 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );

	pSeq = SetCommonMajorParticleByEnum( COMMON_MAJOR_PII_DAMAGE_IMPACT_SLASH_RED,	L"DamageImpactSlashRed",	1 );
	if( pSeq != NULL )
		pSeq->SetTriggerWait( true );
}

CKTDGParticleSystem::CParticleEventSequence* CX2GUEve::SetEveMajorParticleByEnum( EVE_MAJOR_PARTICLE_INSTANCE_ID eVal_, wstring wstrParticleName_, int iDrawCount_ /*= -1*/ )
{
	if ( INVALID_PARTICLE_SEQUENCE_HANDLE == GetHandleEveMajorParticleByEnum( eVal_ ) )
	{
		ParticleEventSequenceHandle hHandle = 
			g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  wstrParticleName_.c_str(), 0,0,0, 0, 0, iDrawCount_, 0 );

		SetHandleEveMajorParticleByEnum( eVal_, hHandle );
	}

	CKTDGParticleSystem::CParticleEventSequence* pSeq =
		g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleEveMajorParticleByEnum( eVal_) );

	return pSeq;
}

void CX2GUEve::InitializeEveMinorParticleArray()
{
	CX2GUUser::InitializeGUUserMinorParticleArray();

	for ( int index = 0; index < EVE_MINOR_PII_END; index++ )
	{
		m_ahEveMinorParticleInstance[index] = INVALID_PARTICLE_SEQUENCE_HANDLE;
	}
}

#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
/*static*/
void	CX2GUEve::AppendMinorParticleToDeviceList( CKTDXDeviceDataList& listInOut_ )
{
}

#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD


/*virtual*/ void CX2GUEve::CreateMinorParticleArray()
{
	CX2GUUser::CreateMinorParticleArray();
}

CKTDGParticleSystem::CParticleEventSequence* CX2GUEve::SetEveMinorParticleByEnum( EVE_MINOR_PARTICLE_INSTANCE_ID eVal_, wstring wstrParticleName_, int iDrawCount_ /*= -1*/ )
{
	if ( INVALID_PARTICLE_SEQUENCE_HANDLE == GetHandleEveMinorParticleByEnum( eVal_ ) )
	{
		ParticleEventSequenceHandle hHandle = 
			g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  wstrParticleName_.c_str(), 0,0,0, 0, 0, iDrawCount_, 0 );

		SetHandleEveMinorParticleByEnum( eVal_, hHandle );
	}

	CKTDGParticleSystem::CParticleEventSequence* pSeq =
		g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleEveMinorParticleByEnum( eVal_) );

	return pSeq;
}

void CX2GUEve::CommonStateStartFuture()
{
	KTDXPROFILE();
	CX2GUUser::CommonStateStartFuture();
}

void CX2GUEve::CommonStateStart()
{
	KTDXPROFILE();
	CX2GUUser::CommonStateStart();

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	m_fEffectStartTime = 0.f;
#endif //UPGRADE_SKILL_SYSTEM_2013
}

void CX2GUEve::CommonFrameMoveFuture()
{
	KTDXPROFILE();
	m_fReAttackZ1Time -= m_fElapsedTime;
	if( m_fReAttackZ1Time < 0.0f )
		m_fReAttackZ1Time = 0.0f;

	m_fReDashJumpXTime -= m_fElapsedTime;
	if( m_fReDashJumpXTime < 0.0f )
		m_fReDashJumpXTime = 0.0f;

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	// Maneuver Core Lv 을 전달한다.
	m_FrameDataFuture.syncData.m_CannonBallCount = m_iManeuverCoreLv;
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어

	CX2GUUser::CommonFrameMoveFuture();
}

void CX2GUEve::CommonFrameMove()
{
	KTDXPROFILE();


	CX2GUUser::CommonFrameMove();




	// 소환된 몬스터 처리
	if( 0.f != m_fSummonedLifeTime )
	{
		if( m_timerSummoned.elapsed() > (double) m_fSummonedLifeTime )
		{
			m_fSummonedLifeTime = 0.f;
			SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE );
#ifdef SERV_SKILL_NOTE
			SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE_MEMO );
#endif
		}
	}
	//{{ JHKang / 강정훈 / 2010/11/22 / 아토믹 쉴드 지속 시간 처리
#ifdef NEW_SKILL_2010_11
	if ( 0.f != m_fAtomicShieldLifeTime )
	{
		if( m_timerAtomicShieldSummoned.elapsed() > (double) m_fAtomicShieldLifeTime )
		{
			m_fAtomicShieldLifeTime = 0.f;
			SetSelfDestructSummonedNPC( CX2UnitManager::NUI_ATOMIC_SHIELD_EVE );
		}
	}
#endif NEW_SKILL_2010_11
	//}} JHKang / 강정훈 / 2010/11/22 / 아토믹 쉴드 지속 시간 처리

#ifdef FINALITY_SKILL_SYSTEM //김창한
	if( 0.f <= m_fFerdinandLifeTime )
	{
		if( m_timerFerdinandSummoned.elapsed() > static_cast<double>( m_fFerdinandLifeTime ) )
		{
			SetSelfDestructSummonedNPC( CX2UnitManager::NUI_SI_HA_FERDINAND );
		}
	}
#endif //FINALITY_SKILL_SYSTEM

	// 이브 투명화 특수기 처리
	if( true == m_bInvisibility )
	{
		if( GetNowHp() <= 0.f )
		{
			m_bInvisibility			= false;
			m_bAbsoluteInvisibility = false;
			m_fInvisibilityAlpha	= 1.f;
		}
		else
		{
#ifdef BALANCE_PATCH_20120329
			if( m_timerInvisibility.elapsed() > m_fInvisibilityTime || GetNowMp() < 1.f ) 			
#else
			if( m_timerInvisibility.elapsed() > m_fInvisibilityTime ) 
#endif
			{
				m_bInvisibility			= false;
				m_bAbsoluteInvisibility = false;

				SetAlphaObject( false );
				m_RenderParam.bAlphaBlend = false;

				m_RenderParam.outLineColor.a	= 1.f;
				m_RenderParam.color.a			= 1.f;
			}
#ifdef BALANCE_PATCH_20120329
			else
			{
#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
				// 마나 소모량, SA 값으로 변경
				UpNowMp(m_fDecraseInvisibilityMP * m_fElapsedTime);
#else // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
				UpNowMp(-5.f * m_fElapsedTime);
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
			}
#endif
		}

		if( false == m_bInvisibility )	// 투명화가 풀렸다
		{

			// 각성 상태이면 각성 파티클을 다시 보이게 한다.
			if( GetRemainHyperModeTime() > 0.f )
			{
				CKTDGParticleSystem::CParticleEventSequence* pSeq_RFoot = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostRFoot );
				CKTDGParticleSystem::CParticleEventSequence* pSeq_LFoot = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostLFoot );
				CKTDGParticleSystem::CParticleEventSequence* pSeq_RArm = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostRArm );
				CKTDGParticleSystem::CParticleEventSequence* pSeq_LArm = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostLArm );

				if( pSeq_RFoot != NULL )
				{
					pSeq_RFoot->SetShowObject( true );
				}
				if( pSeq_LFoot != NULL )
				{
					pSeq_LFoot->SetShowObject( true );
				}
				if( pSeq_RArm != NULL )
				{
					pSeq_RArm->SetShowObject( true );
				}
				if( pSeq_LArm != NULL )
				{
					pSeq_LArm->SetShowObject( true );
				}
			}

			//{{ kimhc // 2010.6.16 // 같은 기능을 하는 함수가 존재하여 함수를 사용함
#ifdef	ENCHANT_BUG_TEST
			// 무기 속성 인챈트 파티클을 다시 보이게 한다
			SetShowEnchantWeaponParticle( true );
#else	ENCHANT_BUG_TEST
			// 무기 속성 인챈트 파티클을 다시 보이게 한다
			SetShowEnchantedWeaponEffectAtHand( true );
			BOOST_TEST_FOREACH( CX2GameUnit::Weapon*, pWeapon, m_vecpWeapon )
			{
				pWeapon->SetEnchantParticleShow( true );
			}
#endif	ENCHANT_BUG_TEST
			//{{ kimhc // 2010.6.16 // 같은 기능을 하는 함수가 존재하여 함수를 사용함


			// 장비에 부착된 파티클 안보이게
			BOOST_TEST_FOREACH( CX2EqipPtr, pEquip, m_ViewEqipList )
			{
				if( pEquip != NULL )
					pEquip->SetShowAttachedParticle( true );
			}
#ifdef EVE_CLOAKING_ADJUST
			BOOST_FOREACH( Weapon* pWeapon, m_vecpWeapon )
			{
				if( NULL != pWeapon )
				{
					pWeapon->SetShowObject(true);
				}
			}
			
			SetShowViewList( true );
#endif //EVE_CLOAKING_ADJUST

#ifdef SERV_SKILL_NOTE
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO5 ) == true )
			{
				//{{ kimhc // 2010.6.14	// 드래고닉셋트 효과 적용 여부 포함 
				// GetOriginalMPChangeRate() 에서 드래고닉셋트 효과가 아직 적용 중인지를 판단함
#ifdef	SERV_SECRET_HELL
				ResetMPChangeRate( GetOriginalMPChangeRate() );
#else	SERV_SECRET_HELL
				ResetMPChangeRate(m_fOriginalMPChangeRate);
#endif	SERV_SECRET_HELL
				//}} kimhc // 2010.6.14 // 드래고닉셋트 효과 적용 여부 포함
			}			
#endif

#ifdef BALANCE_PATCH_20120329
			RemoveVecMoveSpeedFactor( CX2GameUnit::SFI_SPEED_13 );
#endif
		}
	}

	if( false == m_bInvisibility && 1.f != m_fInvisibilityAlpha )
	{
		m_fInvisibilityAlpha += 0.05f;

		if( m_fInvisibilityAlpha > 1.f )
		{
			m_fInvisibilityAlpha = 1.f;

			if ( false == IsMyUnit() && false == IsNullGageUI() )
				m_pGageUI->SetAlpha( 255.0f ); // 게이지바를 다시 보이게 한다. 
		}
	}

	if( true == m_bInvisibility )
	{
#ifndef BALANCE_PATCH_20120329
		if( 0.f == m_fInvisibilityAlpha ) // 이브를 전혀 못보는 상태
#endif
		{
			if( true == GetStateparam(false).bAttackState ||			
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                false == m_vecAttackTime.empty()
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
				false == m_AttackTimeList.empty() 
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
                )				// 공격상태이면 
			{
				m_bAbsoluteInvisibility = false;				// 이브를 보이게 하고
#ifdef BALANCE_PATCH_20120329
				m_fInvisibilityTime = 0.f;
#endif
			}
			else
			{
				m_bAbsoluteInvisibility = true;
			}
		}
	}


#ifdef OLD_HAND_SLASH_TRACE
	//{{AFX

	//note!! 일단은 레이븐과 같은 방식으로 slash_trace구현, 나중에 수정해야함
	bool bHandSlash = false;
	LUA_GET_VALUE( m_LuaManager, "HAND_SLASH_TRACE", bHandSlash, false );

#ifdef X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
	if( g_pMain->GetGameOption().GetOptionList().m_eEffect == CX2GameOption::OL_HIGH )
#else//X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
	if( g_pMain->GetGameOption().GetOptionList().m_bEffect == true )
#endif//X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
	{
		for( int i=0; i<ARRAY_SIZE( m_aSlashTraceData ) ; i++ )
		{
			m_aSlashTraceData[i].SetShowObject( true );
			if( NULL != m_aSlashTraceData[i].m_pSlashTrace )
			{
				m_aSlashTraceData[i].m_pSlashTrace->OnFrameMove( m_fTime, m_fElapsedTime );
				m_aSlashTraceData[i].m_pSlashTrace->GetMatrix().Move( GetMatrix().GetPos() );
			}
		}
	}
	else
	{
		for( int i=0; i<ARRAY_SIZE( m_aSlashTraceData ) ; i++ )
		{
			m_aSlashTraceData[ i ].SetShowObject( false );
		}
	}

#ifdef X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
	if( g_pMain->GetGameOption().GetOptionList().m_eEffect == CX2GameOption::OL_HIGH )
#else//X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
	if( g_pMain->GetGameOption().GetOptionList().m_bEffect == true )
#endif//X2OPTIMIZE_USER_DAMAGEEFFECT_SHOW_BY_GAMEOPTION
	{
		if( NULL != m_aSlashTraceData[ SlashID_LHand ].m_pSlashTrace )
		{
			D3DXVECTOR3 up, down;
			GetFramePos( &up, m_aSlashTraceData[ SlashID_LHand ].m_pFrame_TRACE_START );
			GetFramePos( &down, m_aSlashTraceData[ SlashID_LHand ].m_pFrame_TRACE_END );

			const float MAGIC_SLASH_TRACE_TIP_WIDTH = 4.f;
			D3DXVECTOR3 dirTip	= down - up;
			D3DXVec3Normalize( &dirTip, &dirTip );
			D3DXVECTOR3 tipDown = up + dirTip * MAGIC_SLASH_TRACE_TIP_WIDTH;


			if( true == bHandSlash )
			{
				switch( m_aSlashTraceData[ SlashID_LHand ].m_eType )
				{
				case CKTDGSlashTrace::STT_DEFAULT:
					{
						m_aSlashTraceData[ SlashID_LHand ].m_pSlashTrace->AddSlashData( up, down, 0xcc5555ff );
						//m_pSlashTraceTip->AddSlashData( up, tipDown, 0xff5555ff );
					} break;

				case CKTDGSlashTrace::STT_CONSTANT_WIDTH:
					{
						D3DXVECTOR3 vLineDir = GetDirVector();
						D3DXVec3Normalize( &vLineDir, &vLineDir );

						m_aSlashTraceData[ SlashID_LHand ].m_pSlashTrace->AddSlashDataConstantWidth( up, down, 0xcc5555ff, vLineDir );
						//m_pSlashTraceTip->AddSlashData( up, tipDown, D3DXCOLOR( 0, 0, 0, 0 ) );
					} break;

				case CKTDGSlashTrace::STT_CIRCULAR:
					{
						D3DXVECTOR3 vLineDir = GetDirVector();
						D3DXVec3Normalize( &vLineDir, &vLineDir );

						D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );

						m_aSlashTraceData[ SlashID_LHand ].m_pSlashTrace->AddSlashDataCircular( vBonePos, up, down, 0xcc5555ff, vLineDir, 50.f, false );
						//m_pSlashTraceTip->AddSlashData( up, tipDown, D3DXCOLOR( 0, 0, 0, 0 ) );
					} break;
				}
			}
			else
			{
				m_aSlashTraceData[ SlashID_LHand ].m_pSlashTrace->AddSlashData( up, down, D3DXCOLOR( 0, 0, 0, 0 ) );
				//m_pSlashTraceTip->AddSlashData( up, tipDown, D3DXCOLOR( 0, 0, 0, 0 ) );
			}
		}





		if( NULL != m_aSlashTraceData[ SlashID_RHand ].m_pSlashTrace )
		{
			D3DXVECTOR3 up, down;
			GetFramePos( &up, m_aSlashTraceData[ SlashID_RHand ].m_pFrame_TRACE_START );
			GetFramePos( &down, m_aSlashTraceData[ SlashID_RHand ].m_pFrame_TRACE_END );

			const float MAGIC_SLASH_TRACE_TIP_WIDTH = 4.f;
			D3DXVECTOR3 dirTip	= down - up;
			D3DXVec3Normalize( &dirTip, &dirTip );
			D3DXVECTOR3 tipDown = up + dirTip * MAGIC_SLASH_TRACE_TIP_WIDTH;


			if( true == bHandSlash )
			{
				switch( m_aSlashTraceData[ SlashID_RHand ].m_eType )
				{
				case CKTDGSlashTrace::STT_DEFAULT:
					{
						m_aSlashTraceData[ SlashID_RHand ].m_pSlashTrace->AddSlashData( up, down, 0xcc5555ff );
						//m_pSlashTraceTip->AddSlashData( up, tipDown, 0xff5555ff );
					} break;

				case CKTDGSlashTrace::STT_CONSTANT_WIDTH:
					{
						D3DXVECTOR3 vLineDir = GetDirVector();
						D3DXVec3Normalize( &vLineDir, &vLineDir );

						m_aSlashTraceData[ SlashID_RHand ].m_pSlashTrace->AddSlashDataConstantWidth( up, down, 0xcc5555ff, vLineDir );
						//m_pSlashTraceTip->AddSlashData( up, tipDown, D3DXCOLOR( 0, 0, 0, 0 ) );
					} break;

				case CKTDGSlashTrace::STT_CIRCULAR:
					{
						D3DXVECTOR3 vLineDir = GetDirVector();
						D3DXVec3Normalize( &vLineDir, &vLineDir );

						m_aSlashTraceData[ SlashID_RHand ].m_pSlashTrace->AddSlashDataCircular( GetPos(), up, down, 0xcc5555ff, vLineDir, 50.f, false );
						//m_pSlashTraceTip->AddSlashData( up, tipDown, D3DXCOLOR( 0, 0, 0, 0 ) );
					} break;
				}
			}
			else
			{
				m_aSlashTraceData[ SlashID_RHand ].m_pSlashTrace->AddSlashData( up, down, D3DXCOLOR( 0, 0, 0, 0 ) );
				//m_pSlashTraceTip->AddSlashData( up, tipDown, D3DXCOLOR( 0, 0, 0, 0 ) );
			}
		}
	}
	//}}AFX
#endif OLD_HAND_SLASH_TRACE



#ifdef EVE_FIRST_CHANGE_JOB
	if( m_sEGQueensThrone.m_bEnable == true )
	{
		if( m_sEGQueensThrone.m_dMaxLifeTime >= m_sEGQueensThrone.m_TimerElapsedTime.elapsed() )
		{
			if( INVALID_MESH_INSTANCE_HANDLE != m_sEGQueensThrone.m_ahMajorMeshInstance[0] )
			{
				CKTDXDeviceXSkinMesh::MultiAnimFrame*	pMultiAnimFrame	= m_pXSkinAnim->GetCloneFrame( L"Bip01_Spine1" );
				CKTDGXMeshPlayer::CXMeshInstance*		pMeshInst = NULL;
				D3DXVECTOR3	vBonePos = GetBonePos(L"Bip01_Spine1");

				for( int i = 0; i < ARRAY_SIZE(m_sEGQueensThrone.m_ahMajorMeshInstance); ++i )
				{
					pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_sEGQueensThrone.m_ahMajorMeshInstance[i] );
					if( NULL != pMeshInst && NULL != pMultiAnimFrame )
					{
						pMeshInst->SetUseDXMatrix( pMultiAnimFrame->combineMatrix );	//캐릭터 동작에 맞추기 위해..
						pMeshInst->SetPos( vBonePos );	//컬링등에 사용되는 기능에 제약이 안걸리게 하기위해..
					}
				}

				// 3필 시전동안 몸에 이펙트를 붙여보자.(이렀게 막생성해서 붙이면 ㅠㅂㅠ 수정수정 꼭 필요.)
				// 5개의 파티클을 사용하며 파티클에서 사용되는 
				// Eve_EG_StateMsg01~5.Y : 개당 580byte
				// Eve_StateMsg01.tga : 공용으로 사용되는 텍스쳐 64Kbyte
				if( m_TimerEGQTRefreshMsg.elapsed() > 0.6 )
				{
					m_sEGQueensThrone.m_ahMajorParticleInstance[EG_QueensThroneData::PP_BODY] = INVALID_PARTICLE_SEQUENCE_HANDLE;
					WCHAR wstrParName[MAX_PATH] = L"";

					StringCchPrintf(wstrParName,MAX_PATH, L"Eve_EG_Sp3a_QT_StateMsg0%d", (rand()%5 + 1) );
					//wsprintf(wstrParName, L"Eve_EG_Sp3a_QT_StateMsg0%d", (rand()%5 + 1) );

					m_sEGQueensThrone.m_iSelectBoneNameID = rand()%5;

					CKTDGParticleSystem::CParticleEventSequence* pSeq =
						g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  wstrParName, GetBonePos( m_sEGQueensThrone.m_wstrBoneName[m_sEGQueensThrone.GetBoneNameID()].c_str() ) );
					if( NULL != pSeq )
					{
						m_sEGQueensThrone.m_ahMajorParticleInstance[EG_QueensThroneData::PP_BODY] = pSeq->GetHandle();
					}

					m_TimerEGQTRefreshMsg.restart();
				}
				else
				{
					//파티클 위치 업데이트.
					if( m_sEGQueensThrone.m_ahMajorParticleInstance[EG_QueensThroneData::PP_BODY] != INVALID_PARTICLE_SEQUENCE_HANDLE )
					{
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sEGQueensThrone.m_ahMajorParticleInstance[EG_QueensThroneData::PP_BODY] );
						if( NULL != pSeq )
						{
							pSeq->SetPosition(GetBonePos(m_sEGQueensThrone.m_wstrBoneName[m_sEGQueensThrone.GetBoneNameID()].c_str()));
						}
					}
					if( m_sEGQueensThrone.m_ahMajorParticleInstance[EG_QueensThroneData::PP_WING] != INVALID_PARTICLE_SEQUENCE_HANDLE )
					{
						CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_sEGQueensThrone.m_ahMajorMeshInstance[2] );
						if( pMeshInst != NULL )
						{
							CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sEGQueensThrone.m_ahMajorParticleInstance[EG_QueensThroneData::PP_WING] );
							if( NULL != pSeq )
							{
								pSeq->SetPosition( pMeshInst->GetBonePos(L"Dummy01") );
							}
						}
					}
				}
			}
		}
		else
		{
			m_sEGQueensThrone.Reset();

			D3DXVECTOR3 vBonePos = GetBonePos(L"Bip01_Spine1");
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_EG_Sp3a_QT_End02", vBonePos );
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_EG_Sp3a_QT_End01", vBonePos );

			UpDownCrashCameraNoReset();

			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_QT_END_RING", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );

			PlaySound( L"Eve_EG_SP3_QueensThrone_Disappear.ogg" );
		}
	}
#endif EVE_FIRST_CHANGE_JOB

	// 메가일랙트론볼 차지모드 이펙트 처리..
	if( m_sMegaElectronBallData.m_bEnable == true )
	{
		// 차지도중 슬롯이 바뀌면 중지..
		if( m_sMegaElectronBallData.GetSkillSlotSwap() != g_pData->GetUIManager()->GetUISkillTree()->GetSkillSlotSwap() )
			m_sMegaElectronBallData.Reset( false, &AccessFutureFrameData() );
		else
		{

	
			//살아있으면 이팩트 랜더링..
			if( GetNowHp() > 0 )
			{		
				// 모으는 이펙트.
				if( m_sMegaElectronBallData.m_dMaxTime > m_sMegaElectronBallData.m_timerElapsedTime.elapsed() )
				{
					if( m_sMegaElectronBallData.m_ahMajorParticleInstance[0] == INVALID_PARTICLE_SEQUENCE_HANDLE )
					{
						D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
						vBonePos.x += 5.f;
						vBonePos.y += 5.f;
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Hole_Eve_SI_A_EN_Condense_Power01", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sMegaElectronBallData.m_ahMajorParticleInstance[0] = pSeq->GetHandle();
						}
					}
					else
					{
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sMegaElectronBallData.m_ahMajorParticleInstance[0] );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );
							D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
							vBonePos.x += 5.f;
							vBonePos.y += 5.f;
							pSeq->SetPosition( vBonePos );
						}
					}
					if( m_sMegaElectronBallData.m_ahMajorParticleInstance[1] == INVALID_PARTICLE_SEQUENCE_HANDLE )
					{
						D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
						vBonePos.y += 5.f;
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_SI_A_EN_Condense_Power01", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sMegaElectronBallData.m_ahMajorParticleInstance[1] = pSeq->GetHandle();
						}
					}
					else
					{
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sMegaElectronBallData.m_ahMajorParticleInstance[1] );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );
							D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
							vBonePos.y += 5.f;
							pSeq->SetPosition( vBonePos );
						}
					}
					if( m_sMegaElectronBallData.m_ahMajorParticleInstance[2] == INVALID_PARTICLE_SEQUENCE_HANDLE )
					{
						D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
						vBonePos.y += 5.f;
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_SI_A_EN_Condense_Power02", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sMegaElectronBallData.m_ahMajorParticleInstance[2] = pSeq->GetHandle();
						}
					}
					else
					{
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sMegaElectronBallData.m_ahMajorParticleInstance[2] );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );
							D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
							vBonePos.y += 5.f;
							pSeq->SetPosition( vBonePos );
						}
					}
				}
				//차지 완성 이팩트로 전환..
				else if( m_sMegaElectronBallData.m_dMaxTime <= m_sMegaElectronBallData.m_timerElapsedTime.elapsed() )
				{
					static bool bIsFirstSucCharge = false;

					// 차지가 완료된 첫순간이면.
					if( m_sMegaElectronBallData.m_bIsSucCharge == false )
					{
						m_sMegaElectronBallData.m_bIsSucCharge = true;
						m_sMegaElectronBallData.ResetParticle();

						D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );

						// 완료이펙트를 보여주고..
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_SI_A_EN_Condense_Power01", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sMegaElectronBallData.m_ahMajorParticleInstance[0] = pSeq->GetHandle();
						}
						pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_SI_A_EN_Condense_Power02", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sMegaElectronBallData.m_ahMajorParticleInstance[1] = pSeq->GetHandle();
						}

						// 완료된 차지 이펙트를 생성하여 전환.
						vBonePos = GetBonePos( L"Bip01_R_Finger2" );				

						vBonePos.y += 5.f;
						pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_SI_A_EN_Condense_Power02", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sMegaElectronBallData.m_ahMajorParticleInstance[2] = pSeq->GetHandle();
						}
						vBonePos = GetBonePos( L"Bip01_R_Finger2" );
						pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_SI_A_EN_MEB_FullCharge01", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sMegaElectronBallData.m_ahMajorParticleInstance[3] = pSeq->GetHandle();
						}

						if( IsMyUnit() == true )
						{
							g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_Condense_power.ogg" );
							PlaySound( L"Eve_MEB_Condense_power_charge.ogg" );
						}					
						bIsFirstSucCharge = true;

#ifdef ADD_FULL_CHARGING_VOICE	/// 메가 일렉트론 볼 풀 차지시 음성 출력
						PlaySoundAtNoAttackState( L"EveVoice_MegaElectronBall.ogg" );
#endif ADD_FULL_CHARGING_VOICE
					}
					else
					{
						if( m_sMegaElectronBallData.m_ahMajorParticleInstance[0] != INVALID_PARTICLE_SEQUENCE_HANDLE )
						{
							CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sMegaElectronBallData.m_ahMajorParticleInstance[0] );
							if( NULL != pSeq )
							{
								pSeq->SetAddRotate( GetRotateDegree() );
								pSeq->SetAxisAngle( GetRotateDegree() );
								D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
								pSeq->SetPosition( vBonePos );
							}
						}
						if( m_sMegaElectronBallData.m_ahMajorParticleInstance[1] != INVALID_PARTICLE_SEQUENCE_HANDLE )
						{
							CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sMegaElectronBallData.m_ahMajorParticleInstance[1] );
							if( NULL != pSeq )
							{
								pSeq->SetAddRotate( GetRotateDegree() );
								pSeq->SetAxisAngle( GetRotateDegree() );
								D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
								pSeq->SetPosition( vBonePos );
							}
						}
						if( m_sMegaElectronBallData.m_ahMajorParticleInstance[2] != INVALID_PARTICLE_SEQUENCE_HANDLE )
						{
							CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sMegaElectronBallData.m_ahMajorParticleInstance[2] );
							if( NULL != pSeq )
							{
								pSeq->SetAddRotate( GetRotateDegree() );
								pSeq->SetAxisAngle( GetRotateDegree() );
								D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
								vBonePos.y += 5.f;
								pSeq->SetPosition( vBonePos );
							}
						}
						if( m_sMegaElectronBallData.m_ahMajorParticleInstance[3] != INVALID_PARTICLE_SEQUENCE_HANDLE )
						{
							CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sMegaElectronBallData.m_ahMajorParticleInstance[3] );
							if( NULL != pSeq )
							{
								pSeq->SetAddRotate( GetRotateDegree() );
								pSeq->SetAxisAngle( GetRotateDegree() );
								D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
								pSeq->SetPosition( vBonePos );
							}
						}

						if(bIsFirstSucCharge == true)
						{
							bIsFirstSucCharge = false;
							if( IsMyUnit() == true )
								g_pKTDXApp->GetDeviceManager()->PlaySound( L"Eve_MEB_FullCharge.ogg", true, false );
						}
					}
				}
			}
			else
				//내캐릭티 죽었으면 차지 중지..
				m_sMegaElectronBallData.Reset( false, &AccessFutureFrameData() );
		}
#ifdef BALANCE_PATCH_20120329
		for(int iParticle = 0; iParticle < 4; ++iParticle)
		{
			if( m_sMegaElectronBallData.m_ahMajorParticleInstance[iParticle] != INVALID_PARTICLE_SEQUENCE_HANDLE )
			{
				CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sMegaElectronBallData.m_ahMajorParticleInstance[iParticle] );
				if( pSeq != NULL && m_bInvisibility == true )
				{
					pSeq->SetShowObject(false);
				}
				else if( pSeq != NULL )
				{
					pSeq->SetShowObject(true);
				}						
			}
		}
#endif
	}

#ifdef SKILL_30_TEST
	if( m_sATOveronGuardData.GetEnable() == true && m_sATOveronGuardData.IsLive() == false )
	{
		m_sATOveronGuardData.SetEnable(false);

		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle( m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_01] );
		m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_01] = INVALID_MESH_INSTANCE_HANDLE;

#ifndef SKILL_BALANCE_PATCH
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle( m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_02] );
		m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_02] = INVALID_MESH_INSTANCE_HANDLE;

		g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_01 ) );
		SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_01, INVALID_PARTICLE_SEQUENCE_HANDLE );

		g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_02 ) );
		SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_02, INVALID_PARTICLE_SEQUENCE_HANDLE );
#else
		g_pX2Game->GetEffectSet()->StopEffectSet(m_hOberonGuard);
		m_hOberonGuard = INVALID_EFFECTSET_HANDLE;
#endif
	}
#endif SKILL_30_TEST

	//{{ kimhc // 2010.11.9 // 엠프레스 - 충전 추진기
#ifdef	NEW_SKILL_2010_11
	// 충전 추진기를 배웠고, 아직 쿨타임 중이면
	if ( 
#ifdef  X2OPTIMIZE_REMOVE_UNNECESSARY_SHARED_PTR      
        m_ChargingBoosterSkillDataBasePtr
#else   X2OPTIMIZE_REMOVE_UNNECESSARY_SHARED_PTR        
        0 < m_ChargingBoosterSkillDataBasePtr.use_count() 
#endif  X2OPTIMIZE_REMOVE_UNNECESSARY_SHARED_PTR        
		&& false == m_ChargingBoosterSkillDataBasePtr->IsEndCoolTime() )
		m_ChargingBoosterSkillDataBasePtr->OnFrameMove( m_fElapsedTime );
#endif	NEW_SKILL_2010_11
	//}} kimhc // 2010.11.9 // 엠프레스 - 충전 추진기

#ifdef EVE_ELECTRA
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    m_EveElectraSystem.ProcessSystem( m_fElapsedTime );
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	m_EveElectraSystem.ProcessSystem();
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	DoFrameMoveThousandStar();
#endif EVE_ELECTRA

#ifdef SERV_EVE_BATTLE_SERAPH
	// 테이저 필라 차지모드 이펙트 처리..
	if( m_sTaserPilumData.m_bEnable == true )
	{
		// 차지도중 슬롯이 바뀌면 중지..
		if( m_sTaserPilumData.GetSkillSlotSwap() != g_pData->GetUIManager()->GetUISkillTree()->GetSkillSlotSwap() )
			m_sTaserPilumData.Reset( false, &AccessFutureFrameData() );
		else
		{
			//살아있으면 이팩트 랜더링..
			if( GetNowHp() > 0 )
			{		
				// 모으는 이펙트.
				if( m_sTaserPilumData.m_dMaxTime > m_sTaserPilumData.m_timerElapsedTime.elapsed() )
				{
					if( m_sTaserPilumData.m_ahMajorParticleInstance[0] == INVALID_PARTICLE_SEQUENCE_HANDLE )
					{
						D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
						vBonePos.x += 5.f;
						vBonePos.y += 5.f;
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Hole_Eve_SI_A_EN_Condense_Power01", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sTaserPilumData.m_ahMajorParticleInstance[0] = pSeq->GetHandle();
						}
					}
					else
					{
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sTaserPilumData.m_ahMajorParticleInstance[0] );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );
							D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
							vBonePos.x += 5.f;
							vBonePos.y += 5.f;
							pSeq->SetPosition( vBonePos );
						}
					}
					if( m_sTaserPilumData.m_ahMajorParticleInstance[1] == INVALID_PARTICLE_SEQUENCE_HANDLE )
					{
						D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
						vBonePos.y += 5.f;
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_SI_A_EN_Condense_Power01", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sTaserPilumData.m_ahMajorParticleInstance[1] = pSeq->GetHandle();
						}
					}
					else
					{
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sTaserPilumData.m_ahMajorParticleInstance[1] );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );
							D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
							vBonePos.y += 5.f;
							pSeq->SetPosition( vBonePos );
						}
					}
					if( m_sTaserPilumData.m_ahMajorParticleInstance[2] == INVALID_PARTICLE_SEQUENCE_HANDLE )
					{
						D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
						vBonePos.y += 5.f;
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_SI_A_EN_Condense_Power02", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sTaserPilumData.m_ahMajorParticleInstance[2] = pSeq->GetHandle();
						}
					}
					else
					{
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sTaserPilumData.m_ahMajorParticleInstance[2] );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );
							D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
							vBonePos.y += 5.f;
							pSeq->SetPosition( vBonePos );
						}
					}
				}
				//차지 완성 이팩트로 전환..
				else if( m_sTaserPilumData.m_dMaxTime <= m_sTaserPilumData.m_timerElapsedTime.elapsed() )
				{
					static bool bIsFirstSucCharge = false;

					// 차지가 완료된 첫순간이면.
					if( m_sTaserPilumData.m_bIsSucCharge == false )
					{
						m_sTaserPilumData.m_bIsSucCharge = true;
						m_sTaserPilumData.ResetParticle();

						D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );

						// 완료이펙트를 보여주고..
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_SI_A_EN_Condense_Power01", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sTaserPilumData.m_ahMajorParticleInstance[0] = pSeq->GetHandle();
						}
						pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_SI_A_EN_Condense_Power02", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sTaserPilumData.m_ahMajorParticleInstance[1] = pSeq->GetHandle();
						}

						// 완료된 차지 이펙트를 생성하여 전환.
						vBonePos = GetBonePos( L"Bip01_R_Finger2" );				

						vBonePos.y += 5.f;
						pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_SI_A_EN_Condense_Power02", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sTaserPilumData.m_ahMajorParticleInstance[2] = pSeq->GetHandle();
						}
						vBonePos = GetBonePos( L"Bip01_R_Finger2" );
						pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"EBS_A_TASER_PILUM_ready_P01", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sTaserPilumData.m_ahMajorParticleInstance[3] = pSeq->GetHandle();
						}

						if( IsMyUnit() == true )
						{
							g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_Condense_power.ogg" );
							PlaySound( L"Eve_MEB_Condense_power_charge.ogg" );
						}					
						bIsFirstSucCharge = true;

#ifdef ADD_FULL_CHARGING_VOICE	/// 테이저 필라 풀 차지시 음성 출력
						PlaySoundAtNoAttackState( L"EveVoice_MegaElectronBall.ogg" );
#endif ADD_FULL_CHARGING_VOICE
					}
					else
					{
						if( m_sTaserPilumData.m_ahMajorParticleInstance[0] != INVALID_PARTICLE_SEQUENCE_HANDLE )
						{
							CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sTaserPilumData.m_ahMajorParticleInstance[0] );
							if( NULL != pSeq )
							{
								pSeq->SetAddRotate( GetRotateDegree() );
								pSeq->SetAxisAngle( GetRotateDegree() );
								D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
								pSeq->SetPosition( vBonePos );
							}
						}
						if( m_sTaserPilumData.m_ahMajorParticleInstance[1] != INVALID_PARTICLE_SEQUENCE_HANDLE )
						{
							CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sTaserPilumData.m_ahMajorParticleInstance[1] );
							if( NULL != pSeq )
							{
								pSeq->SetAddRotate( GetRotateDegree() );
								pSeq->SetAxisAngle( GetRotateDegree() );
								D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
								pSeq->SetPosition( vBonePos );
							}
						}
						if( m_sTaserPilumData.m_ahMajorParticleInstance[2] != INVALID_PARTICLE_SEQUENCE_HANDLE )
						{
							CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sTaserPilumData.m_ahMajorParticleInstance[2] );
							if( NULL != pSeq )
							{
								pSeq->SetAddRotate( GetRotateDegree() );
								pSeq->SetAxisAngle( GetRotateDegree() );
								D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
								vBonePos.y += 5.f;
								pSeq->SetPosition( vBonePos );
							}
						}
						if( m_sTaserPilumData.m_ahMajorParticleInstance[3] != INVALID_PARTICLE_SEQUENCE_HANDLE )
						{
							CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sTaserPilumData.m_ahMajorParticleInstance[3] );
							if( NULL != pSeq )
							{
								pSeq->SetAddRotate( GetRotateDegree() );
								pSeq->SetAxisAngle( GetRotateDegree() );
								D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
								pSeq->SetPosition( vBonePos );
							}
						}

						if(bIsFirstSucCharge == true)
						{
							bIsFirstSucCharge = false;
							if( IsMyUnit() == true )
								g_pKTDXApp->GetDeviceManager()->PlaySound( L"Eve_MEB_FullCharge.ogg", true, false );
						}
					}
				}
			}
			else
				//내캐릭티 죽었으면 차지 중지..
				m_sTaserPilumData.Reset( false, &AccessFutureFrameData() );
		}

		for(int iParticle = 0; iParticle < 4; ++iParticle)
		{
			if( m_sTaserPilumData.m_ahMajorParticleInstance[iParticle] != INVALID_PARTICLE_SEQUENCE_HANDLE )
			{
				CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sTaserPilumData.m_ahMajorParticleInstance[iParticle] );
				if( pSeq != NULL && m_bInvisibility == true )
				{
					pSeq->SetShowObject(false);
				}
				else if( pSeq != NULL )
				{
					pSeq->SetShowObject(true);
				}						
			}
		}
#endif //UPGRADE_SKILL_SYSTEM_2013

// 		if( m_bInvisibility == true )
// 		{
// 			if( m_GuildSkillData.m_ChangeToReverse.m_fTimeLeft > 0.f )
// 			{
// 				if( m_GuildSkillData.m_ChangeToReverse.m_hEffectSet != INVALID_EFFECTSET_HANDLE )
// 				{
// 					g_pX2Game->GetEffectSet()->StopEffectSet( m_GuildSkillData.m_ChangeToReverse.m_hEffectSet );				
// 				}
// 			}				
// 		}
// 		else
// 		{
// 			if( m_GuildSkillData.m_ChangeToReverse.m_fTimeLeft > 0.f )
// 			{
// 				if ( m_GuildSkillData.m_ChangeToReverse.m_hEffectSet == INVALID_EFFECTSET_HANDLE )
// 				{
// 					m_GuildSkillData.m_ChangeToReverse.m_hEffectSet = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_ChanceToReverse", this, this );				
// 				}
// 			}
// 		}		
	}

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	// 쿠글블릿츠 차지모드 이펙트 처리..
	if( m_sKugelBlitz_Data.m_bEnable == true )
	{
		// 차지도중 슬롯이 바뀌면 중지..
		if( m_sKugelBlitz_Data.GetSkillSlotSwap() != g_pData->GetUIManager()->GetUISkillTree()->GetSkillSlotSwap() )
			m_sKugelBlitz_Data.Reset( false, &AccessFutureFrameData() );
		else
		{
			//살아있으면 이팩트 랜더링..
			if( GetNowHp() > 0 )
			{		
				// 모으는 이펙트.
				if( m_sKugelBlitz_Data.m_dMaxTime > m_sKugelBlitz_Data.m_timerElapsedTime.elapsed() )
				{
					if( m_sKugelBlitz_Data.m_ahMajorParticleInstance[0] == INVALID_PARTICLE_SEQUENCE_HANDLE )
					{
						D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
						vBonePos.x += 5.f;
						vBonePos.y += 5.f;
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence(
							(CKTDGObject*) this,  L"Light_Hole_Eve_SI_A_EN_Condense_Power01", vBonePos );

						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sKugelBlitz_Data.m_ahMajorParticleInstance[0] = pSeq->GetHandle();
						}
					}
					else
					{
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( 
							m_sKugelBlitz_Data.m_ahMajorParticleInstance[0] );

						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );
							D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
							vBonePos.x += 5.f;
							vBonePos.y += 5.f;
							pSeq->SetPosition( vBonePos );
						}
					}
					if( m_sKugelBlitz_Data.m_ahMajorParticleInstance[1] == INVALID_PARTICLE_SEQUENCE_HANDLE )
					{
						D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
						vBonePos.y += 5.f;
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_SI_A_EN_Condense_Power01", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sKugelBlitz_Data.m_ahMajorParticleInstance[1] = pSeq->GetHandle();
						}
					}
					else
					{
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence(
							m_sKugelBlitz_Data.m_ahMajorParticleInstance[1] );

						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );
							D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
							vBonePos.y += 5.f;
							pSeq->SetPosition( vBonePos );
						}
					}
					if( m_sKugelBlitz_Data.m_ahMajorParticleInstance[2] == INVALID_PARTICLE_SEQUENCE_HANDLE )
					{
						D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
						vBonePos.y += 5.f;
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence(
							(CKTDGObject*) this,  L"Light_Eve_SI_A_EN_Condense_Power02", vBonePos );

						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sKugelBlitz_Data.m_ahMajorParticleInstance[2] = pSeq->GetHandle();
						}
					}
					else
					{
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence(
							m_sKugelBlitz_Data.m_ahMajorParticleInstance[2] );

						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );
							D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
							vBonePos.y += 5.f;
							pSeq->SetPosition( vBonePos );
						}
					}
				}
				//차지 완성 이팩트로 전환..
				else if( m_sKugelBlitz_Data.m_dMaxTime <= m_sKugelBlitz_Data.m_timerElapsedTime.elapsed() )
				{
					static bool bIsFirstSucCharge = false;

					// 차지가 완료된 첫순간이면.
					if( m_sKugelBlitz_Data.m_bIsSucCharge == false )
					{
						m_sKugelBlitz_Data.m_bIsSucCharge = true;
						m_sKugelBlitz_Data.ResetParticle();

						D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );

						// 완료이펙트를 보여주고..
						CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_SI_A_EN_Condense_Power01", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sKugelBlitz_Data.m_ahMajorParticleInstance[0] = pSeq->GetHandle();
						}
						pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_SI_A_EN_Condense_Power02", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sKugelBlitz_Data.m_ahMajorParticleInstance[1] = pSeq->GetHandle();
						}

						// 완료된 차지 이펙트를 생성하여 전환.
						vBonePos = GetBonePos( L"Bip01_R_Finger2" );				

						vBonePos.y += 5.f;
						pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_SI_A_EN_Condense_Power02", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sKugelBlitz_Data.m_ahMajorParticleInstance[2] = pSeq->GetHandle();
						}
						vBonePos = GetBonePos( L"Bip01_R_Finger2" );
						pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"EBS_A_TASER_PILUM_ready_P01", vBonePos );
						if( NULL != pSeq )
						{
							pSeq->SetAddRotate( GetRotateDegree() );
							pSeq->SetAxisAngle( GetRotateDegree() );

							m_sKugelBlitz_Data.m_ahMajorParticleInstance[3] = pSeq->GetHandle();
						}

						if( IsMyUnit() == true )
						{
							g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_Condense_power.ogg" );
							PlaySound( L"Eve_MEB_Condense_power_charge.ogg" );
						}					
						bIsFirstSucCharge = true;

#ifndef SERV_COUNTRY_JP
						PlaySoundAtNoAttackState( L"EveVoice_MegaElectronBall.ogg" );
#endif //SERV_COUNTRY_JP
					}
					else
					{
						if( m_sKugelBlitz_Data.m_ahMajorParticleInstance[0] != INVALID_PARTICLE_SEQUENCE_HANDLE )
						{
							CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sKugelBlitz_Data.m_ahMajorParticleInstance[0] );
							if( NULL != pSeq )
							{
								pSeq->SetAddRotate( GetRotateDegree() );
								pSeq->SetAxisAngle( GetRotateDegree() );
								D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
								pSeq->SetPosition( vBonePos );
							}
						}
						if( m_sKugelBlitz_Data.m_ahMajorParticleInstance[1] != INVALID_PARTICLE_SEQUENCE_HANDLE )
						{
							CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sKugelBlitz_Data.m_ahMajorParticleInstance[1] );
							if( NULL != pSeq )
							{
								pSeq->SetAddRotate( GetRotateDegree() );
								pSeq->SetAxisAngle( GetRotateDegree() );
								D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
								pSeq->SetPosition( vBonePos );
							}
						}
						if( m_sKugelBlitz_Data.m_ahMajorParticleInstance[2] != INVALID_PARTICLE_SEQUENCE_HANDLE )
						{
							CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sKugelBlitz_Data.m_ahMajorParticleInstance[2] );
							if( NULL != pSeq )
							{
								pSeq->SetAddRotate( GetRotateDegree() );
								pSeq->SetAxisAngle( GetRotateDegree() );
								D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
								vBonePos.y += 5.f;
								pSeq->SetPosition( vBonePos );
							}
						}
						if( m_sKugelBlitz_Data.m_ahMajorParticleInstance[3] != INVALID_PARTICLE_SEQUENCE_HANDLE )
						{
							CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sKugelBlitz_Data.m_ahMajorParticleInstance[3] );
							if( NULL != pSeq )
							{
								pSeq->SetAddRotate( GetRotateDegree() );
								pSeq->SetAxisAngle( GetRotateDegree() );
								D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
								pSeq->SetPosition( vBonePos );
							}
						}

						if(bIsFirstSucCharge == true)
						{
							bIsFirstSucCharge = false;
							if( IsMyUnit() == true )
								g_pKTDXApp->GetDeviceManager()->PlaySound( L"Eve_MEB_FullCharge.ogg", true, false );
						}
					}
				}
			}
			else
				//내캐릭티 죽었으면 차지 중지..
				m_sKugelBlitz_Data.Reset( false, &AccessFutureFrameData() );
		}

		for(int iParticle = 0; iParticle < 4; ++iParticle)
		{
			if( m_sKugelBlitz_Data.m_ahMajorParticleInstance[iParticle] != INVALID_PARTICLE_SEQUENCE_HANDLE )
			{
				CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_sKugelBlitz_Data.m_ahMajorParticleInstance[iParticle] );
				if( pSeq != NULL && m_bInvisibility == true )
				{
					pSeq->SetShowObject(false);
				}
				else if( pSeq != NULL )
				{
					pSeq->SetShowObject(true);
				}						
			}
		}
	}
#endif //UPGRADE_SKILL_SYSTEM_2013

	m_EnergyNiddleData.OnFrameMove( this, m_fElapsedTime );

#ifdef FIX_EVE_ELCRYSTAL_BUG
	OnFrameMove_EndElCrystalSystem();
#endif // FIX_EVE_ELCRYSTAL_BUG

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	// 기동 코어의 OnFrameMove
	OnFrameMove_ManeuverCore();
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어

}


/*virtual*/ void CX2GUEve::CommonEventProcess()
{
	KTDXPROFILE();
	CX2GUUser::CommonEventProcess();

	if( m_sMegaElectronBallData.m_bEnable == false )
	{
		m_sMegaElectronBallData.SetSkillSlotSwap( g_pData->GetUIManager()->GetUISkillTree()->GetSkillSlotSwap() );	//현재 선택된 슬롯을 셋팅.

		// 현재 슬롯에 스킬이 있는지 검가..
		if( m_sMegaElectronBallData.GetSkillSlotID() >= 0 && m_sMegaElectronBallData.GetSkillSlotID() < EQUIPPED_SKILL_SLOT_COUNT*2 )
		{
			//메가일랙트론볼 스테이트 아이디를 찾아서.
			int iNowState = -1;
			if( GetRemainHyperModeTime() > 0.f )
			{
				iNowState = _CONST_GUUSER_::aHyperSkillStateID[m_sMegaElectronBallData.GetSkillSlotID()];
				if( iNowState == -1 ) //A스킬슬롯에서 찾지 못했다면
					iNowState = _CONST_GUUSER_::aHyperSkillStateIDSlotB[m_sMegaElectronBallData.GetSkillSlotID()];
			}
			else
			{
				iNowState = _CONST_GUUSER_::aNormalSkillStateID[m_sMegaElectronBallData.GetSkillSlotID()];
				if( iNowState == -1 ) //A스킬슬롯에서 찾지 못했다면
					iNowState = _CONST_GUUSER_::aNormalSkillStateIDSlotB[m_sMegaElectronBallData.GetSkillSlotID()];
			}

			//메가일랙트론볼 스킬 키가 눌려졌는지 체크..
			bool bIsKeyPress = false;
			switch( m_sMegaElectronBallData.GetSkillSlotID() )
			{
			case 0: bIsKeyPress = m_InputData.oneA; break;
			case 1: bIsKeyPress = m_InputData.oneS; break;
			case 2: bIsKeyPress = m_InputData.oneD; break;
			case 3: bIsKeyPress = m_InputData.oneC; break;
			case 4: bIsKeyPress = m_InputData.oneQ; break;
			case 5: bIsKeyPress = m_InputData.oneW; break;
			case 6: bIsKeyPress = m_InputData.oneE; break;
			case 7: bIsKeyPress = m_InputData.oneR; break;
			default :
				break;
			}

			//키가 체크 되었으면 시작..
			if( bIsKeyPress == true )
			{
				m_FrameDataFuture.syncData.nowAction = UAI_MEGA_ELECTRONBALL;
			}
		}
	}

#ifdef SERV_EVE_BATTLE_SERAPH
	if( m_sTaserPilumData.m_bEnable == false )
	{
		// 테이저 필라 스테이트 아이디를 찾아서.

		m_sTaserPilumData.SetSkillSlotSwap( g_pData->GetUIManager()->GetUISkillTree()->GetSkillSlotSwap() );	//현재 선택된 슬롯을 셋팅.

		int iSlotIndex = 0;
		bool bSlotB = false;
		CX2UserSkillTree::GetSlotIndexAndSlotB( m_sTaserPilumData.GetSkillSlotID(), OUT iSlotIndex, OUT bSlotB );

		int iNowState = -1;
			
		if ( ARRAY_SIZE( _CONST_GUUSER_::aNormalSkillStateID ) > iSlotIndex && 0 < iSlotIndex )
		{
			if( GetRemainHyperModeTime() > 0.f )
			{
				if( bSlotB == true )
					iNowState = _CONST_GUUSER_::aHyperSkillStateIDSlotB[iSlotIndex];
				else
					iNowState = _CONST_GUUSER_::aHyperSkillStateID[iSlotIndex];
			}
			else
			{
				if( bSlotB == true )
					iNowState = _CONST_GUUSER_::aNormalSkillStateIDSlotB[iSlotIndex];
				else
					iNowState = _CONST_GUUSER_::aNormalSkillStateID[iSlotIndex];
			}
		}

		// 테이저 필라 스킬 키가 눌려졌는지 체크..
		bool bIsKeyPress = false;
		switch( m_sTaserPilumData.GetSkillSlotID() )
		{
		case 0: bIsKeyPress = m_InputData.oneA; break;
		case 1: bIsKeyPress = m_InputData.oneS; break;
		case 2: bIsKeyPress = m_InputData.oneD; break;
		case 3: bIsKeyPress = m_InputData.oneC; break;
		case 4: bIsKeyPress = m_InputData.oneQ; break;
		case 5: bIsKeyPress = m_InputData.oneW; break;
		case 6: bIsKeyPress = m_InputData.oneE; break;
		case 7: bIsKeyPress = m_InputData.oneR; break;
		default :
			break;
		}

		//키가 체크 되었으면 시작..
		if( bIsKeyPress == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_TASER_PILUM;
		}
	}
#endif	// SERV_EVE_BATTLE_SERAPH

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	if( m_sKugelBlitz_Data.m_bEnable == false )
	{
		// 테이저 필라 스테이트 아이디를 찾아서.

		m_sKugelBlitz_Data.SetSkillSlotSwap( g_pData->GetUIManager()->GetUISkillTree()->GetSkillSlotSwap() );	//현재 선택된 슬롯을 셋팅.

		int iSlotIndex = 0;
		bool bSlotB = false;
		CX2UserSkillTree::GetSlotIndexAndSlotB( m_sKugelBlitz_Data.GetSkillSlotID(), OUT iSlotIndex, OUT bSlotB );

		int iNowState = -1;

		if ( ARRAY_SIZE( _CONST_GUUSER_::aNormalSkillStateID ) > iSlotIndex && 0 < iSlotIndex )
		{
			if( GetRemainHyperModeTime() > 0.f )
			{
				if( bSlotB == true )
					iNowState = _CONST_GUUSER_::aHyperSkillStateIDSlotB[iSlotIndex];
				else
					iNowState = _CONST_GUUSER_::aHyperSkillStateID[iSlotIndex];
			}
			else
			{
				if( bSlotB == true )
					iNowState = _CONST_GUUSER_::aNormalSkillStateIDSlotB[iSlotIndex];
				else
					iNowState = _CONST_GUUSER_::aNormalSkillStateID[iSlotIndex];
			}
		}

		// 쿠글블릿츠 스킬 키가 눌려졌는지 체크..
		bool bIsKeyPress = false;
		switch( m_sKugelBlitz_Data.GetSkillSlotID() )
		{
		case 0: bIsKeyPress = m_InputData.oneA; break;
		case 1: bIsKeyPress = m_InputData.oneS; break;
		case 2: bIsKeyPress = m_InputData.oneD; break;
		case 3: bIsKeyPress = m_InputData.oneC; break;
		case 4: bIsKeyPress = m_InputData.oneQ; break;
		case 5: bIsKeyPress = m_InputData.oneW; break;
		case 6: bIsKeyPress = m_InputData.oneE; break;
		case 7: bIsKeyPress = m_InputData.oneR; break;
		default :
			break;
		}

		//키가 체크 되었으면 시작..
		if( bIsKeyPress == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_KUGELBLITZ;
		}
	}
#endif //UPGRADE_SKILL_SYSTEM_2013
}


void CX2GUEve::CommonStateEndFuture()
{
	KTDXPROFILE();
	CX2GUUser::CommonStateEndFuture();
}

void CX2GUEve::CommonStateEnd()
{
	KTDXPROFILE();
	CX2GUUser::CommonStateEnd();
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	m_fEffectStartTime = 0.f;
#endif //UPGRADE_SKILL_SYSTEM_2013

#ifdef FIX_EVE_ELCRYSTAL_BUG
	m_bIsCheckEndElCrystal = true;
#endif // FIX_EVE_ELCRYSTAL_BUG
}

//{{ robobeg : 2008-10-28
//void CX2GUEve::CommonRender()
/*virtual*/ 
RENDER_HINT CX2GUEve::CommonRender_Prepare()
	//}} robobeg : 2008-10-28
{
	KTDXPROFILE();
	// 	if( GetRemainHyperModeTime() > 0.0f )
	// 	{
	// 		m_RenderParam.renderType		= CKTDGXRenderer::RT_CARTOON_COLOR_EDGE;
	// 		m_RenderParam.cartoonTexType	= CKTDGXRenderer::CTT_RED;
	// 		m_RenderParam.outLineColor		= D3DXCOLOR( 1.f, 0.694f, 0.737f, 1.f );
	// 	}
	// 	else
	// 	{
	// 		m_RenderParam.renderType		= CKTDGXRenderer::RT_CARTOON_BLACK_EDGE;
	// 		m_RenderParam.cartoonTexType	= CKTDGXRenderer::CTT_NORMAL;
	// 		m_RenderParam.outLineColor		= 0xffffffff;
	// 	}

	//{{ robobeg : 2008-10-28
	//CX2GUUser::CommonRender();
	return CX2GUUser::CommonRender_Prepare();
	//}} robobeg : 2008-10-28
}

/*virtual*/ bool CX2GUEve::SpecialAttackEventProcess( CX2SkillTree::ACTIVE_SKILL_USE_CONDITION eActiveSkillUseCondition /*= CX2SkillTree::ASUT_ONLY_ON_LINE*/ )
{
	KTDXPROFILE();

	const int INVALID_SKILL_SLOT_INDEX = -1;

	int iPressedSkillSlotIndex = INVALID_SKILL_SLOT_INDEX;
	const CX2UserSkillTree::SkillSlotData* pSkillSlotData = NULL;
	CX2UserSkillTree& cUserSkillTree =  GetUnit()->AccessUnitData().m_UserSkillTree;	// 유저가 배운 스킬 트리

	if ( false == CommonSpecialAttackEventProcess( cUserSkillTree, pSkillSlotData, iPressedSkillSlotIndex ) )
		return false;

	bool bIsUpSkillSlotMegaElectronBall = IsUpSkillSlotMegaElectronBall();

	//메가일랙트론볼 차지중인 키가 업된는지 체크..
	if ( true == bIsUpSkillSlotMegaElectronBall )
	{
		pSkillSlotData = GetSkillSlotDataMegaElectronBall( cUserSkillTree, iPressedSkillSlotIndex );
	}

#ifdef SERV_EVE_BATTLE_SERAPH
	if ( NULL != pSkillSlotData && pSkillSlotData->m_eID == CX2SkillTree::SI_A_EN_MEGA_ELECTRONBALL && false == bIsUpSkillSlotMegaElectronBall )
	{
		//메가일렉트론본 사용시 enable 되지 않아도 첫타임에 넘어오는 경우가 있어서 단순예외처리.
		return false;
	}

	bool bIsUpSkillSlotTaserPilum = IsUpSkillSlotTaserPilum();

	// 테이저 필라 차지중인 키가 업된는지 체크..
	if ( true == bIsUpSkillSlotTaserPilum )
	{
		pSkillSlotData = GetSkillSlotDataTaserPilum( cUserSkillTree, iPressedSkillSlotIndex );
	}

	if ( NULL != pSkillSlotData && pSkillSlotData->m_eID == CX2SkillTree::SI_A_EBS_TASER_PILUM && false == bIsUpSkillSlotTaserPilum )
	{
		return false;
	}

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	bool bIsUpSkillSlotKugelBlitz = IsUpSkillSlotKugelBlitz();

	// 쿠글블릿츠 차지중인 키가 업된는지 체크..
	if ( true == bIsUpSkillSlotKugelBlitz )
	{
		pSkillSlotData = GetSkillSlotDataKugelBlitz( cUserSkillTree, iPressedSkillSlotIndex );
	}

	if ( NULL != pSkillSlotData && pSkillSlotData->m_eID == CX2SkillTree::SI_A_EBS_KUGELBLITZ && false == bIsUpSkillSlotKugelBlitz )
	{
		return false;
	}
#endif //UPGRADE_SKILL_SYSTEM_2013

	if( NULL == pSkillSlotData )
		return false;
#else
	if( NULL == pSkillSlotData )
		return false;

	if ( pSkillSlotData->m_eID == CX2SkillTree::SI_A_EN_MEGA_ELECTRONBALL && false == bIsUpSkillSlotMegaElectronBall )
	{
		//메가일렉트론본 사용시 enable 되지 않아도 첫타임에 넘어오는 경우가 있어서 단순예외처리.
		return false;
	}	
#endif

	const CX2SkillTree::SkillTemplet* pSkillTempletUsing = GetEquippedActiveSkillTemplet( pSkillSlotData->m_eID );
	if( NULL == pSkillTempletUsing )
		return false;

#ifdef ADD_MEMO_1ST_CLASS //김창한
	if( false == CheckSkillUseCondition( eActiveSkillUseCondition, pSkillTempletUsing->m_eActiveSkillUseCondtion ) )
#else //ADD_MEMO_1ST_CLASS
	if( false == CheckSkillUseCondition( eActiveSkillUseCondition, pSkillTempletUsing ) )
#endif //ADD_MEMO_1ST_CLASS
		return false;

	//소환 필살기 종류는 게임이 끝난 상태에서 사용할 수 없다.
	if( false == CheckSummonSpecialAttack( pSkillTempletUsing->m_eID ) )
		return false;

	// 공식대전에서 사용 가능한 스킬인지 검사
	if( false == CheckSkillUsePVPOfficial( pSkillTempletUsing->m_eID ) )
		return false;

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	const int iSkillTempletLevel = max( 1, cUserSkillTree.GetSkillLevel( pSkillTempletUsing->m_eID ) );	/// 스킬 레벨
	
	float fMPConsume = GetActualMPConsume( pSkillTempletUsing->m_eID, iSkillTempletLevel );	
#else // UPGRADE_SKILL_SYSTEM_2013
	float fMPConsume = GetActualMPConsume( pSkillTempletUsing->m_eID, pSkillTempletUsing->m_iSkillLevel );
#endif // UPGRADE_SKILL_SYSTEM_2013

#ifdef ADDITIONAL_MEMO
	if( pSkillTempletUsing->m_eID == CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL && GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO13 ) == true )
	{
		fMPConsume -= 10.f;
		if( fMPConsume < 0.f )
			fMPConsume = 0.f;
	}
#endif

#ifdef EVE_ELECTRA
	if( pSkillTempletUsing->m_eID == CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL && m_EveElectraSystem.GetEnableSystem() == true )
	{
		fMPConsume	= 0.f;
	}
	if( pSkillTempletUsing->m_eID == CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS && m_iThousandStarCount > 0 )
	{
		fMPConsume	= 0.f;
	}
#endif EVE_ELECTRA

#ifdef TOGGLE_UNLIMITED_SKILL_USE
#if defined( _IN_HOUSE_ ) || defined( _OPEN_TEST_ )
	if( false == g_pMain->IsMyAuthLevelHigherThan( CX2User::XUAL_OPERATOR ) || false == g_pMain->IsUnlimitedSkillUse() )
#endif //defined( _IN_HOUSE_ ) || defined( _OPEN_TEST_ )
#else //TOGGLE_UNLIMITED_SKILL_USE
#ifndef _SERVICE_
	if( false == g_pMain->IsMyAuthLevelHigherThan( CX2User::XUAL_DEV ) )
#endif _SERVICE_
#endif //TOGGLE_UNLIMITED_SKILL_USE
	{
		if( pSkillSlotData->m_fCoolTimeLeft > 0.f )
		{
#ifdef ALWAYS_SCREEN_SHOT_TEST
			if( g_pInstanceData != NULL && g_pInstanceData->GetScreenShotTest() == true)
			{
				return false;
			}
#endif ALWAYS_SCREEN_SHOT_TEST
			g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, GET_STRING( STR_ID_226 ), D3DXCOLOR(1,1,1,1), D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );
			return false;
		}

		if ( GetNowMp() < fMPConsume )
		{
#ifdef ALWAYS_SCREEN_SHOT_TEST
			if( g_pInstanceData != NULL && g_pInstanceData->GetScreenShotTest() == true)
			{
				return false;
			}
#endif ALWAYS_SCREEN_SHOT_TEST
			g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, GET_STRING( STR_ID_2549 ), D3DXCOLOR(1,1,1,1), D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );
			return false;
		}

#ifdef FINALITY_SKILL_SYSTEM //JHKang
		if ( pSkillTempletUsing->m_eType == CX2SkillTree::ST_HYPER_ACTIVE_SKILL && g_pMain->GetNowStateID() != CX2Main::XS_TRAINING_GAME
			&& false == GetActiveLinkOverChargeIllusion() ) //페르디난도 피니시 공격에 대한 예외처리)
		{
			const int iItemNum = g_pData->GetMyUser()->GetSelectUnit()->GetInventory().GetNumItemByTID( CX2EnchantItem::ATI_HYPER_SKILL_STONE );

			if( iItemNum <= 0
#ifdef SERV_BALANCE_FINALITY_SKILL_EVENT
				&& false == g_pData->GetMyUser()->GetSelectUnit()->IsInfinityElEssence()
#endif //SERV_BALANCE_FINALITY_SKILL_EVENT
				)
			{
#ifdef ALWAYS_SCREEN_SHOT_TEST
			if( g_pInstanceData != NULL && g_pInstanceData->GetScreenShotTest() == true)
			{
				return false;
			}
#endif ALWAYS_SCREEN_SHOT_TEST
				g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, GET_STRING( STR_ID_26119 ), D3DXCOLOR(1,1,1,1), D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );
				return false;
			}
		}
#endif //FINALITY_SKILL_SYSTEM
	}

	if( pSkillTempletUsing->m_eID == CX2SkillTree::SI_SA_EEG_QUEENS_THRONE )
	{
		//쿨타임만 끝나면 기존셋팅을 종료하고 다시 사용될수 있도록 하기위해.
		m_sEGQueensThrone.Reset();
	}

	if( pSkillTempletUsing->m_eID == CX2SkillTree::SI_A_EN_CONVERSION )
	{//
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		// 마력전환 일경우 HP 가 소모될 양보다 많은지 체크.
		if( (GetMaxHp() * pSkillTempletUsing->GetSkillAbilityValue( CX2SkillTree::SA_HP_REL_TO_MP_ABS_1, iSkillTempletLevel ) ) >= GetNowHp() )
	#else // UPGRADE_SKILL_SYSTEM_2013
		// 마력전환 일경우 HP 가 소모될 양보다 많은지 체크.
		if( (GetMaxHp() * pSkillTempletUsing->GetSkillAbilityValue( CX2SkillTree::SA_HP_REL_TO_MP_ABS_1 ) ) >= GetNowHp() )
	#endif // UPGRADE_SKILL_SYSTEM_2013
		{
#ifdef ALWAYS_SCREEN_SHOT_TEST
			if( g_pInstanceData != NULL && g_pInstanceData->GetScreenShotTest() == true)
			{
				return false;
			}
#endif ALWAYS_SCREEN_SHOT_TEST
			g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, 
				GET_STRING( STR_ID_2627 ), D3DXCOLOR(1,1,1,1), D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );

			return false;
		}

		if( GetMaxMp() == GetNowMp() )
		{
#ifdef ALWAYS_SCREEN_SHOT_TEST
			if( g_pInstanceData != NULL && g_pInstanceData->GetScreenShotTest() == true)
			{
				return false;
			}
#endif ALWAYS_SCREEN_SHOT_TEST
			g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, 
				GET_STRING( STR_ID_2662 ), D3DXCOLOR(1,1,1,1), D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );

			return false;
		}
	}

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	/// 스킬창에서 스킬 습득중이면, 스킬 사용 불가
	if (	NULL != g_pData &&
			NULL != g_pData->GetUIManager() &&
			NULL != g_pData->GetUIManager()->GetUISkillTree() &&
			true == g_pData->GetUIManager()->GetUISkillTree()->GetNowLearnSkill() )
		{
			g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, GET_STRING( STR_ID_25110 ), D3DXCOLOR(1,1,1,1),
				D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );
			return false;
		}
#endif // UPGRADE_SKILL_SYSTEM_2013

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	if ( NULL != m_pManeuverCore && m_pManeuverCore->m_eManeuverCoreState == MCS_PARRYING ) 
	{
		// Parrying 중에는 기술을 사용할 수 없다.
		return false;
	}	
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어

	//메가일론트론볼은 자체스테이트에서 깍는다.
	if( pSkillSlotData->m_eID != CX2SkillTree::SI_A_EN_MEGA_ELECTRONBALL
#ifdef SERV_EVE_BATTLE_SERAPH
		&& pSkillSlotData->m_eID != CX2SkillTree::SI_A_EBS_TASER_PILUM
#endif
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		&& pSkillSlotData->m_eID != CX2SkillTree::SI_A_EBS_KUGELBLITZ
#endif //UPGRADE_SKILL_SYSTEM_2013
		)
	{
		UpNowMp( -fMPConsume );
	}

#ifdef FINALITY_SKILL_SYSTEM //JHKang
	if ( pSkillTempletUsing->m_eType == CX2SkillTree::ST_HYPER_ACTIVE_SKILL && g_pMain->GetNowStateID() != CX2Main::XS_TRAINING_GAME 
		&& false == GetActiveLinkOverChargeIllusion() ) //페르디난도 피니시 공격에 대한 예외처리
	{
#ifdef SERV_BALANCE_FINALITY_SKILL_EVENT
		if ( true == g_pData->GetMyUser()->GetSelectUnit()->IsInfinityElEssence() )
			g_pX2Game->Handler_EGS_USE_FINALITY_SKILL_REQ();
		else
		{
#endif //SERV_BALANCE_FINALITY_SKILL_EVENT
		CX2Item* pItem = g_pData->GetMyUser()->GetSelectUnit()->GetInventory().GetItemByTID( CX2EnchantItem::ATI_HYPER_SKILL_STONE );

		if ( NULL != pItem )
			g_pX2Game->Handler_EGS_USE_FINALITY_SKILL_REQ( pItem->GetItemData().m_ItemUID );
#ifdef SERV_BALANCE_FINALITY_SKILL_EVENT
		}
#endif //SERV_BALANCE_FINALITY_SKILL_EVENT
	}
#endif //FINALITY_SKILL_SYSTEM

	//{{ JHKang / 강정훈 / 2011/02/14 / 던전 랭크 개선 관련
#ifdef DUNGEON_RANK_NEW
	CountUsedSkill( iPressedSkillSlotIndex );
#endif DUNGEON_RANK_NEW
	//}} JHKang / 강정훈 / 2011/02/14 / 던전 랭크 개선 관련

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->GetSkillCoolTimeValue( iSkillTempletLevel ) );

#else // UPGRADE_SKILL_SYSTEM_2013
	cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->m_fSkillCoolTime );
#endif // UPGRADE_SKILL_SYSTEM_2013

#ifdef SERV_SKILL_NOTE
#ifndef BALANCE_PATCH_20120329
	if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO5 ) == true && pSkillTempletUsing->m_eID == CX2SkillTree::SI_A_EN_CLOAKING )
	{
		cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->m_fSkillCoolTime + 10.f );
	}
	else
#endif //BALANCE_PATCH_20120329
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO6 ) == true && pSkillTempletUsing->m_eID == CX2SkillTree::SI_A_EN_CONVERSION ) 
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->GetSkillCoolTimeValue( iSkillTempletLevel ) + 3.f );

	#else // UPGRADE_SKILL_SYSTEM_2013
			cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->m_fSkillCoolTime + 3.f );
	#endif // UPGRADE_SKILL_SYSTEM_2013
		}
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		else if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO2 ) == true && pSkillTempletUsing->m_eID == CX2SkillTree::SI_A_EN_DIMENSION_LINK )
#else //UPGRADE_SKILL_SYSTEM_2013
		else if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO2 ) == true && pSkillTempletUsing->m_eID == CX2SkillTree::SI_SA_EN_DIMENSION_LINK )
#endif //UPGRADE_SKILL_SYSTEM_2013
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->GetSkillCoolTimeValue( iSkillTempletLevel ) + 5.f );

	#else // UPGRADE_SKILL_SYSTEM_2013
			cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->m_fSkillCoolTime + 5.f );
	#endif // UPGRADE_SKILL_SYSTEM_2013
		}

#ifdef	BALANCE_PATCH_20110303
		else if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO7 ) == true && pSkillTempletUsing->m_eID == CX2SkillTree::SI_A_EN_MEGA_ELECTRONBALL )
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->GetSkillCoolTimeValue( iSkillTempletLevel ) - 1.f );

	#else // UPGRADE_SKILL_SYSTEM_2013
			cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->m_fSkillCoolTime - 1.f );
	#endif // UPGRADE_SKILL_SYSTEM_2013
		}
#endif	// BALANCE_PATCH_20110303

#ifdef EVE_ELECTRA
		if( pSkillTempletUsing->m_eID == CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL )
		{
			cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, 0.f );
		}

#ifdef SERV_EVE_BATTLE_SERAPH
		if ( pSkillTempletUsing->m_eID == CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL && false == m_EveElectraSystem.GetEnableExceptionSystem()
			&& true != m_FrameDataNow.stateParam.bNoChangSpectro)
		{
			if(	m_EveElectraSystem.GetEnableSystem() == false && m_EveElectraSystem.GetEnableSpectrumDynamics() == true
				&& m_EveElectraSystem.GetEnableHyperOpticalResearch() == false )
			{
				cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, 0.f );

				if ( IsMyUnit() )
					g_pX2Game->UpdateSkillSlotUI();
			}
			else if( m_EveElectraSystem.GetEnableSystem() == false && m_EveElectraSystem.GetEnableSpectrumDynamics() == false
				&& m_EveElectraSystem.GetEnableHyperOpticalResearch() == false )
			{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
				cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->GetSkillCoolTimeValue( iSkillTempletLevel ) );
	#else // UPGRADE_SKILL_SYSTEM_2013
				cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->m_fSkillCoolTime );
	#endif // UPGRADE_SKILL_SYSTEM_2013
				if ( IsMyUnit() )
					g_pX2Game->UpdateSkillSlotUI();
			}
			else if (m_EveElectraSystem.GetEnableSystem() == true && m_EveElectraSystem.GetEnableSpectrumDynamics() == true
				&& m_EveElectraSystem.GetEnableHyperOpticalResearch() == false )
			{
				cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, 2.f );
				if ( IsMyUnit() )
					g_pX2Game->UpdateSkillSlotUI();
			}
			else if ( m_EveElectraSystem.GetEnableSystem() == false && m_EveElectraSystem.GetEnableHyperOpticalResearch() == true )
			{
				cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, 0.0f );
				if ( IsMyUnit() )
					g_pX2Game->UpdateSkillSlotUI();
			}
			else if ( m_EveElectraSystem.GetEnableSystem() == false && m_EveElectraSystem.GetEnableHyperOpticalResearch() == false )
			{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
				cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->GetSkillCoolTimeValue( iSkillTempletLevel ) );
	#else // UPGRADE_SKILL_SYSTEM_2013
				cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->m_fSkillCoolTime );
	#endif // UPGRADE_SKILL_SYSTEM_2013
				if ( IsMyUnit() )
					g_pX2Game->UpdateSkillSlotUI();
			}
			else if (  m_EveElectraSystem.GetEnableSystem() == true && m_EveElectraSystem.GetEnableHyperOpticalResearch() == true )
			{
				cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, 0.5f );
				if ( IsMyUnit() )
					g_pX2Game->UpdateSkillSlotUI();
			}
		}
#else
		if( pSkillTempletUsing->m_eID == CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL &&
			m_EveElectraSystem.GetEnableSystem() == false && m_EveElectraSystem.GetEnableSpectrumDynamics() == true )
		{
			cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, 0.f );
			g_pX2Game->UpdateSkillSlotUI();
		}
		else if( pSkillTempletUsing->m_eID == CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL 
			&& m_EveElectraSystem.GetEnableSystem() == false && m_EveElectraSystem.GetEnableSpectrumDynamics() == false )
		{
			cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, pSkillTempletUsing->m_fSkillCoolTime );
			g_pX2Game->UpdateSkillSlotUI();
		}
		else if ( pSkillTempletUsing->m_eID == CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL &&
			m_EveElectraSystem.GetEnableSystem() == true && m_EveElectraSystem.GetEnableSpectrumDynamics() == true )
		{
			cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, 2.f );
			g_pX2Game->UpdateSkillSlotUI();
		}
#endif
		else if ( pSkillTempletUsing->m_eID == CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS )
		{
			cUserSkillTree.SetSkillCoolTimeLeft( pSkillTempletUsing->m_eID, 0.f );

			g_pX2Game->UpdateSkillSlotUI();
		}

#endif EVE_ELECTRA
#ifdef FINALITY_SKILL_SYSTEM //김창한
		if( pSkillTempletUsing->m_eID == CX2SkillTree::SI_HA_EEP_LINK_OVERCHARGE_ILLUSION )
		{
			cUserSkillTree.SetSkillCoolTimeLeft( CX2SkillTree::SI_HA_EEP_LINK_OVERCHARGE_ILLUSION, 0.f  );
		}
#endif //FINALITY_SKILL_SYSTEM
#endif

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
		// 스페셜 어택에 대해서 본노게이지 누적
		if( pSkillTempletUsing->m_eType == CX2SkillTree::ST_SPECIAL_ACTIVE && GetRemainHyperModeTime() > 0.f && IsMyUnit() == true )
		{
			m_fManeuverGauge += ( fMPConsume / 3.f );
			if( m_fManeuverGauge > 100.f )
				m_fManeuverGauge = 100.f;
		}
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어			   



		if( false == SpecialAttackNoStageChange( pSkillTempletUsing ) )
		{
			if( GetRemainHyperModeTime() <= 0.f )
			{
				if( iPressedSkillSlotIndex > 3 ) //슬롯 B일때
				{
					StateChange( _CONST_GUUSER_::aNormalSkillStateIDSlotB[iPressedSkillSlotIndex-4] );
				}
				else
				{
					StateChange( _CONST_GUUSER_::aNormalSkillStateID[iPressedSkillSlotIndex] );
				}
			}
			else
			{
				if( iPressedSkillSlotIndex > 3 ) //슬롯 B일때
				{
					StateChange( _CONST_GUUSER_::aHyperSkillStateIDSlotB[iPressedSkillSlotIndex-4] );
				}
				else
				{
					StateChange( _CONST_GUUSER_::aHyperSkillStateID[iPressedSkillSlotIndex] );
				}
			}
		}

#ifdef EVE_ELECTRA
		m_eSpecialAttackKeyPressed = (SPECIAL_ATTACK_KEY_PRESSED) (iPressedSkillSlotIndex + 1);
#endif EVE_ELECTRA

		m_iNowSpecialAttack = iPressedSkillSlotIndex + 1;
		m_bSpecialAttackEventProcessedAtThisFrame = true;

		//{{ kimhc // 2010.11.2 // 엠프레스 - 충전 추진기
#ifdef	NEW_SKILL_2010_11
		if ( true == CanUseChargingBooster( pSkillTempletUsing->m_eType, cUserSkillTree ) )
		{
			UseChargingBooster( cUserSkillTree );
			m_ChargingBoosterSkillDataBasePtr->ResetTimerBasedOnCoolTime();
		}
#endif	NEW_SKILL_2010_11
		//}} kimhc // 2010.11.2 // 엠프레스 - 충전 추진기

#ifdef SERV_SKILL_USE_SUBQUEST
		Send_SKILL_USE_REQ( pSkillTempletUsing->m_eID );
#endif SERV_SKILL_USE_SUBQUEST

		return true;

}





// 상태변화가 없는 필살기는 하드코딩해서 예외 처리 한다
/*virtual*/ bool CX2GUEve::SpecialAttackNoStageChange( const CX2SkillTree::SkillTemplet* pSkillTemplet )
{
	if ( pSkillTemplet == NULL )
		return false;

	//{{ kimhc // 2010.11.1 // 신스킬
#ifdef	NEW_SKILL_2010_11
	switch ( pSkillTemplet->m_eID )
	{
	case CX2SkillTree::SI_P_EEP_CHARGING_BOOSTER:	// 엠프 - 충전 추진기
		{
			m_FrameDataFuture.syncData.nowAction = UAI_CHARGING_BOOSTER;
		} break;
#ifdef EVE_ELECTRA
	case CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS:
		{
			if( m_iThousandStarCount > 0 )
			{
				m_FrameDataFuture.syncData.nowAction = UAI_THOUSANDS_OF_STARS;
				return true;
			}
		} break;
#endif EVE_ELECTRA
#ifdef SERV_EVE_BATTLE_SERAPH
	case CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL:
		{
			if ( true == m_EveElectraSystem.GetEnableSystem() && true == m_EveElectraSystem.GetEnableHyperOpticalResearch() )
			{
				m_FrameDataFuture.syncData.nowAction = UAI_CHANGE_SPECTRO_WITHOUT_MOTION;

				return true;
			}
		} break;
#endif
#ifdef FINALITY_SKILL_SYSTEM //김창한
	case CX2SkillTree::SI_HA_EEP_LINK_OVERCHARGE_ILLUSION:
		{
			if( true == GetActiveLinkOverChargeIllusion() )
			{
				m_FrameDataFuture.syncData.nowAction = UAI_EEP_LINK_OVERCHARGE_ILLUSION;
				return true;
			}
		} break;
#endif //FINALITY_SKILL_SYSTEM
	default:
		break;
	}
#endif	NEW_SKILL_2010_11
	//}} kimhc // 2010.11.1 // 신스킬

	return false;
}




/*virtual*/ void CX2GUEve::NoStateChangeActionFrameMove()
{
	switch( m_FrameDataNow.syncData.nowAction )
	{
	case UAI_MEGA_ELECTRONBALL:
		{
#ifdef RIDING_SYSTEM
			if ( false == GetRidingOn() )
			{
				const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EN_MEGA_ELECTRONBALL );
				if( NULL != pSkillTemplet )
				{
					m_sMegaElectronBallData.m_bEnable	= true;

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
					if ( NULL == GetUnit() )
						return;

					const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

					const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( CX2SkillTree::SI_A_EN_CONVERSION ) );	/// 스킬 레벨

					m_sMegaElectronBallData.m_dMaxTime	= static_cast<double>(pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_CHARGING_TIME, iSkillTempletLevel) );

	#else // UPGRADE_SKILL_SYSTEM_2013
					m_sMegaElectronBallData.m_dMaxTime	= static_cast<double>(pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_CHARGING_TIME) );
	#endif // UPGRADE_SKILL_SYSTEM_2013

					m_sMegaElectronBallData.m_timerElapsedTime.restart();

#ifdef SERV_SKILL_NOTE
					if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO7 ) == true )
					{
						m_sMegaElectronBallData.m_dMaxTime *= 0.67f;
					}
#endif

					if( IsMyUnit() == true )
						g_pKTDXApp->GetDeviceManager()->PlaySound( L"Eve_MEB_Condense_power.ogg", true, false );
				}
			}
#else //RIDING_SYSTEM
			const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EN_MEGA_ELECTRONBALL );
			if( NULL != pSkillTemplet )
			{
				m_sMegaElectronBallData.m_bEnable	= true;
				m_sMegaElectronBallData.m_dMaxTime	= static_cast<double>(pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_CHARGING_TIME) );
				m_sMegaElectronBallData.m_timerElapsedTime.restart();

#ifdef SERV_SKILL_NOTE
				if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO7 ) == true )
				{
					m_sMegaElectronBallData.m_dMaxTime *= 0.67f;
				}
#endif

				if( IsMyUnit() == true )
					g_pKTDXApp->GetDeviceManager()->PlaySound( L"Eve_MEB_Condense_power.ogg", true, false );
			}
#endif //RIDING_SYSTEM
		} break;
	case UAI_MEGA_ELECTRONBALL_CHARGE_FAIL:
		{
			m_sMegaElectronBallData.Reset();
			if( IsMyUnit() == true )
				g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_Condense_power.ogg" );
		} break;

		//{{ kimhc // 2010.11.1 // 신스킬
#ifdef	NEW_SKILL_2010_11
	case UAI_CHARGING_BOOSTER:	// 엠프 - 충전 추진기
		{
			g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_P_EEP_CHARGING_BOOSTER", this ); 			
		} break;
#endif	NEW_SKILL_2010_11
		//}} kimhc // 2010.11.1 // 신스킬
#ifdef EVE_ELECTRA
	case UAI_ELECTRA_PLANE_ANGLE_UP:
		{
			m_fPlaneZAngle = 24.f;
		} break;
	case UAI_ELECTRA_PLANE_ANGLE_DOWN:
		{
			m_fPlaneZAngle = -24.f;
		} break;
	case UAI_THOUSANDS_OF_STARS:
		{
#ifdef RIDING_SYSTEM
			if ( false == GetRidingOn() )
			{
				if( m_bEntireFireMode == false )
				{
					if( m_iLockOnUid != -1)
					{
						CX2GameUnit* pGameUnit = NULL;

						if( m_bLockOnNpc )
							pGameUnit = g_pX2Game->GetNPCUnitByUID( (int)m_iLockOnUid );
						else
							pGameUnit = g_pX2Game->GetUserUnitByUID( m_iLockOnUid );

						if( pGameUnit != NULL && pGameUnit->GetNowHp() > 0.f )
						{
							m_bEntireFireMode = true;
							if( m_iThousandStarCount % 2 == 0)
							{
								m_iThousandStarCount = (int)( m_iThousandStarCount / 2.f);
							}
							else
							{
								m_iThousandStarCount = (int)( m_iThousandStarCount / 2.f) + 1;
							}
							const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS );
							if( NULL != pSkillTemplet )
							{
				#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
								if ( NULL == GetUnit() )
									return;
	
								CX2UserSkillTree& userSkillTree = GetUnit()->AccessUnitData().m_UserSkillTree;
	
								const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
								float fRemainCoolTime = pSkillTemplet->GetSkillCoolTimeValue( iSkillTempletLevel ) - m_fElapsedTimeThousandStartCreated; 
				#else // UPGRADE_SKILL_SYSTEM_2013

								CX2UserSkillTree& userSkillTree = GetUnit()->AccessUnitData().m_UserSkillTree;

								float fRemainCoolTime = pSkillTemplet->m_fSkillCoolTime - m_fElapsedTimeThousandStartCreated; 
				#endif // UPGRADE_SKILL_SYSTEM_2013
								
								if( fRemainCoolTime < 0.f )
									fRemainCoolTime = 0.f;

								userSkillTree.SetSkillCoolTimeLeft( CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS, fRemainCoolTime  );
								if ( IsMyUnit() )
									g_pX2Game->UpdateSkillSlotUI();
							}
							PlaySound( L"EveVoice_ThousandStar_2.ogg" );

							if ( NULL != g_pX2Game && GetShowCutInAndChangeWorldColor() )
							{
								g_pX2Game->GetWorld()->SetWorldColor( 0xff222222 );
								g_pX2Game->GetWorld()->FadeWorldColor( g_pX2Game->GetWorld()->GetOriginColor(), 5.0f );
							}

						}
					}
				}
				if( m_bEntireFireMode == false )
				{
					if( IsMyUnit() == true )
						g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, GET_STRING( STR_ID_15829 ), D3DXCOLOR(1,1,1,1), D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );
				}
			}
#else //RIDING_SYSTEM
			if( m_bEntireFireMode == false )
			{
				if( m_iLockOnUid != -1)
				{
					CX2GameUnit* pGameUnit = NULL;

					if( m_bLockOnNpc )
						pGameUnit = g_pX2Game->GetNPCUnitByUID( (int)m_iLockOnUid );
					else
						pGameUnit = g_pX2Game->GetUserUnitByUID( m_iLockOnUid );

					if( pGameUnit != NULL && pGameUnit->GetNowHp() > 0.f )
					{
						m_bEntireFireMode = true;
						if( m_iThousandStarCount % 2 == 0)
						{
							m_iThousandStarCount = (int)( m_iThousandStarCount / 2.f);
						}
						else
						{
							m_iThousandStarCount = (int)( m_iThousandStarCount / 2.f) + 1;
						}
						const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS );
						const CX2UserSkillTree& cUserSkillTree =  GetUnit()->GetUnitData().m_UserSkillTree;
						if( NULL != pSkillTemplet )
						{
							float fRemainCoolTime = pSkillTemplet->m_fSkillCoolTime - m_fElapsedTimeThousandStartCreated; 
							if( fRemainCoolTime < 0.f )
								fRemainCoolTime = 0.f;

							cUserSkillTree.SetSkillCoolTimeLeft( CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS, fRemainCoolTime  );
							if ( IsMyUnit() )
								g_pX2Game->UpdateSkillSlotUI();
						}
						PlaySound( L"EveVoice_ThousandStar_2.ogg" );

						if ( NULL != g_pX2Game && GetShowCutInAndChangeWorldColor() )
						{
							g_pX2Game->GetWorld()->SetWorldColor( 0xff222222 );
							g_pX2Game->GetWorld()->FadeWorldColor( g_pX2Game->GetWorld()->GetOriginColor(), 5.0f );
						}

					}
				}
			}
			if( m_bEntireFireMode == false )
			{
				if( IsMyUnit() == true )
					g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, GET_STRING( STR_ID_15829 ), D3DXCOLOR(1,1,1,1), D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );
			}
#endif //RIDING_SYSTEM			
		} break;
#endif EVE_ELECTRA

#ifdef SERV_EVE_BATTLE_SERAPH
	case UAI_TASER_PILUM:
		{
#ifdef RIDING_SYSTEM
			if ( false == GetRidingOn() )
			{
				const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EBS_TASER_PILUM );

				if( NULL != pSkillTemplet )
				{
					m_sTaserPilumData.m_bEnable = true;

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
					if ( NULL == GetUnit() )
						return;

					const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

					const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( CX2SkillTree::SI_A_EBS_TASER_PILUM ) );	/// 스킬 레벨

					m_sTaserPilumData.m_dMaxTime = static_cast<double>( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_CHARGING_TIME, iSkillTempletLevel) );
	#else // UPGRADE_SKILL_SYSTEM_2013
					m_sTaserPilumData.m_dMaxTime = static_cast<double>( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_CHARGING_TIME) );
	#endif // UPGRADE_SKILL_SYSTEM_2013

					m_sTaserPilumData.m_timerElapsedTime.restart();

					if( IsMyUnit() == true )
						g_pKTDXApp->GetDeviceManager()->PlaySound( L"Eve_MEB_Condense_power.ogg", true, false );
				}
			}
#else //RIDING_SYSTEM
			const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EBS_TASER_PILUM );

			if( NULL != pSkillTemplet )
			{
				m_sTaserPilumData.m_bEnable	= true;
				m_sTaserPilumData.m_dMaxTime = static_cast<double>(pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_CHARGING_TIME) );
				m_sTaserPilumData.m_timerElapsedTime.restart();

				if( IsMyUnit() == true )
					g_pKTDXApp->GetDeviceManager()->PlaySound( L"Eve_MEB_Condense_power.ogg", true, false );
			}

#endif //RIDING_SYSTEM
		} break;
	case UAI_TASER_PILUM_CHARGE_FAIL:
		{
			m_sTaserPilumData.Reset();
			if( IsMyUnit() == true )
				g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_Condense_power.ogg" );
		} break;

	case UAI_CHANGE_SPECTRO_WITHOUT_MOTION:
		{
#ifdef RIDING_SYSTEM
			if ( false == GetRidingOn() )
			{
				if ( true == m_EveElectraSystem.GetEnableSystem() && PFT_FUSION != m_EveElectraSystem.GetPlaneFormation()
					&& true != m_FrameDataNow.stateParam.bNoChangSpectro )
				{
					StartElCrystalSystem();
					//SPECTRO_EL_CRYSTAL_Start();
					m_EveElectraSystem.StartFormationEffect();
					PlaySound( L"Eve_ElCrystal_1.ogg" );
				}
			}
#else //RIDING_SYSTEM
			if ( true == m_EveElectraSystem.GetEnableSystem() && PFT_FUSION != m_EveElectraSystem.GetPlaneFormation()
				&& true != m_FrameDataNow.stateParam.bNoChangSpectro )
			{
				StartElCrystalSystem();
				//SPECTRO_EL_CRYSTAL_Start();
				m_EveElectraSystem.StartFormationEffect();
				PlaySound( L"Eve_ElCrystal_1.ogg" );
			}
#endif //RIDING_SYSTEM
		} break;

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	case UAI_KUGELBLITZ:
		{
			if ( false == GetRidingOn() )
			{
				const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EBS_KUGELBLITZ );

				if( NULL != pSkillTemplet )
				{
					m_sKugelBlitz_Data.m_bEnable = true;

					if ( NULL == GetUnit() )
						return;

					const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

					const int iSkillLevel = max( 1, userSkillTree.GetSkillLevel( CX2SkillTree::SI_A_EBS_KUGELBLITZ ) );	/// 스킬 레벨
					m_sKugelBlitz_Data.m_dMaxTime = static_cast<double>( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_CHARGING_TIME, iSkillLevel ) );
					m_sKugelBlitz_Data.m_timerElapsedTime.restart();

					if( IsMyUnit() == true )
						g_pKTDXApp->GetDeviceManager()->PlaySound( L"Eve_MEB_Condense_power.ogg", true, false );
				}
			}
		} break;

	case UAI_KUGELBLITZ_CHARGE_FAIL:
		{
			m_sKugelBlitz_Data.Reset();
			if( IsMyUnit() == true )
				g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_Condense_power.ogg" );
		} break;
#endif //UPGRADE_SKILL_SYSTEM_2013

#endif
#ifdef FINALITY_SKILL_SYSTEM //김창한
	case UAI_EEP_LINK_OVERCHARGE_ILLUSION:
		{
#ifdef RIDING_SYSTEM
			if ( false == GetRidingOn() && true == GetActiveLinkOverChargeIllusion() )
#else //RIDING_SYSTEM
			if ( true == GetActiveLinkOverChargeIllusion() )
#endif //RIDING_SYSTEM
			{
				SetSelfDestructSummonedNPC( CX2UnitManager::NUI_SI_HA_FERDINAND );
			}		
		} break;
#endif //FINALITY_SKILL_SYSTEM
	}
}

#ifndef SERV_9TH_NEW_CHARACTER // 김태환
/// 다른 캐릭터들 전부 똑같은 함수를 쓰고 있으니, X2GUUser로 옮기자.
void CX2GUEve::CreateNotEnoughMPEffect( D3DXVECTOR3 vPos, float fDegreeX, float fDegreeY, float fDegreeZ )
{
	CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleCommonMajorParticleByEnum( COMMON_MAJOR_PII_MAGIC_FAIL ) );
	if( NULL != pSeq )
	{
		PlaySequenceByTriggerCount( pSeq, vPos, 100, 100, 1 );
		D3DXVECTOR3 vAngle = GetRotateDegree();
		vAngle += D3DXVECTOR3( fDegreeX, fDegreeY, fDegreeZ );

		pSeq->SetAxisAngle( vAngle );
		pSeq->SetAddRotate( vAngle );
	}
}
#endif // SERV_9TH_NEW_CHARACTER




/*virtual*/ void CX2GUEve::CreateStepDust()
{
	if( true == GetAbsoluteInvisibility() )
		return; 

	CX2GUUser::CreateStepDust();
}


void CX2GUEve::CancelComboWhenChangedDirection( int iFlagCount )
{
	bool bCancel = false;
	if( m_InputData.pureLeft == true && m_FrameDataFuture.syncData.bIsRight == true )
	{
		bCancel = true;
	}
	else if( m_InputData.pureRight == true && m_FrameDataFuture.syncData.bIsRight == false )
	{
		bCancel = true;
	}

	if( true == bCancel )
	{
		for( int i=0; i<iFlagCount;i++ )
		{
			m_FrameDataFuture.stateParam.bEventFlagList[i] = false;
		}
	}
}


///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////

//							스테이트 함수 시작

///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
//ENSI_DIE_FRONT
void CX2GUEve::ENSI_DIE_FRONT_StartFuture()
{
	CommonStateStartFuture();

	m_pXSkinAnimFuture->SetPlaySpeed( 0.5f );
}

void CX2GUEve::ENSI_DIE_FRONT_Start()
{
	CommonStateStart();
	DyingStart();

	m_pXSkinAnim->SetPlaySpeed( 0.5f );


	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE );	
#ifdef SERV_SKILL_NOTE
	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE_MEMO );
#endif

	//{{ JHKang / 강정훈 / 2010/11/23 / 아토믹 쉴드
#ifdef NEW_SKILL_2010_11
	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_ATOMIC_SHIELD_EVE );	/// 아토믹 쉴드 소환 해제
#endif NEW_SKILL_2010_11
	//}} JHKang / 강정훈 / 2010/11/23 / 아토믹 쉴드
#ifdef FINALITY_SKILL_SYSTEM //김창한
	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_SI_HA_FERDINAND );
#endif //FINALITY_SKILL_SYSTEM

#ifdef EVE_FIRST_CHANGE_JOB
	m_sEGQueensThrone.Reset();
#endif EVE_FIRST_CHANGE_JOB

#ifdef EVE_ELECTRA
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( m_hEffectSweepParadeTriangle != INVALID_DAMAGE_EFFECT_HANDLE )
        g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_hEffectSweepParadeTriangle );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	if( m_EffectSweepParadeTriangle != NULL )
		g_pX2Game->GetDamageEffect()->DestroyInstance( m_EffectSweepParadeTriangle );
    m_EffectSweepParadeTriangle = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
#endif EVE_ELECTRA

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	ClearManeuverCore( true );
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
}

void CX2GUEve::ENSI_DIE_FRONT_FrameMove()
{
	const float TIME_CREATE_STEP_DUST = 0.19f;		// 연기가 발생되야하는 애니메이션 시간
	const float TIME_SACRIFICE_OF_HERO = 1.12f;		// 영웅의 희생이 실행되어야 하는 애니메이션 시간

	DieFrameMove( TIME_CREATE_STEP_DUST, TIME_SACRIFICE_OF_HERO );
}

void CX2GUEve::ENSI_DIE_FRONT_EventProcess()
{
	//{{ robobeg : 2008-10-21
	//if( m_bShow == false && m_pXSkinAnim->IsAnimationEnd() == true )
	if ( GetShowObject() == false && m_pXSkinAnim->IsAnimationEnd() == true )
		//}} robobeg : 2008-10-21
	{
		StateChange( GUSI_DIE );
	}
}


//ENSI_DIE_BACK
void CX2GUEve::ENSI_DIE_BACK_StartFuture()
{
	CommonStateStartFuture();

	m_pXSkinAnimFuture->SetPlaySpeed( 0.5f );
}

void CX2GUEve::ENSI_DIE_BACK_Start()
{
	CommonStateStart();
	DyingStart();

	m_pXSkinAnim->SetPlaySpeed( 0.5f );

	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE );
#ifdef SERV_SKILL_NOTE
	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE_MEMO );
#endif

	//{{ JHKang / 강정훈 / 2010/11/23 / 아토믹 쉴드
#ifdef NEW_SKILL_2010_11
	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_ATOMIC_SHIELD_EVE );	/// 아토믹 쉴드 소환 해제
#endif NEW_SKILL_2010_11
	//}} JHKang / 강정훈 / 2010/11/23 / 아토믹 쉴드
#ifdef FINALITY_SKILL_SYSTEM //김창한
	SetSelfDestructSummonedNPC( CX2UnitManager::NUI_SI_HA_FERDINAND );
#endif //FINALITY_SKILL_SYSTEM

#ifdef EVE_FIRST_CHANGE_JOB
	m_sEGQueensThrone.Reset();
#endif EVE_FIRST_CHANGE_JOB

#ifdef EVE_ELECTRA
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( m_hEffectSweepParadeTriangle != INVALID_DAMAGE_EFFECT_HANDLE )
        g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_hEffectSweepParadeTriangle );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	if( m_EffectSweepParadeTriangle != NULL )
		g_pX2Game->GetDamageEffect()->DestroyInstance( m_EffectSweepParadeTriangle );
    m_EffectSweepParadeTriangle = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
#endif EVE_ELECTRA

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	ClearManeuverCore( true );
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
}

void CX2GUEve::ENSI_DIE_BACK_FrameMove()
{
	const float TIME_CREATE_STEP_DUST = 0.32f;		// 연기가 발생되야하는 애니메이션 시간
	const float TIME_SACRIFICE_OF_HERO = 1.12f;		// 영웅의 희생이 실행되어야 하는 애니메이션 시간

	DieFrameMove( TIME_CREATE_STEP_DUST, TIME_SACRIFICE_OF_HERO );
}

void CX2GUEve::ENSI_DIE_BACK_EventProcess()
{
	//{{ robobeg : 2008-10-21
	//if( m_bShow == false && m_pXSkinAnim->IsAnimationEnd() == true )
	if ( GetShowObject() == false  && m_pXSkinAnim->IsAnimationEnd() == true )
		//}} robobeg : 2008-10-21
	{
		StateChange( GUSI_DIE );
	}
}

void CX2GUEve::ENSI_WAIT_StartFuture()
{
	CommonStateStartFuture();
	PlayAnimationWaitStart( m_pXSkinAnimFuture, m_FrameDataFuture );

	m_iJumpFlyCount = 0;
	m_iDashJumpCount = 0;
#ifdef EVE_ELECTRA
	m_iDashJumpUpCount = 0;
#endif EVE_ELECTRA
#ifdef SERV_EVE_BATTLE_SERAPH
	m_eBoostDashState = BDS_NONE;
	m_bEnableBoostDash = false;
#endif
}

void CX2GUEve::ENSI_WAIT_Start()
{
	CommonStateStart();
	PlayAnimationWaitStart( m_pXSkinAnim.get(), m_FrameDataNow );
}

void CX2GUEve::ENSI_WAIT_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.oneZ == true && (m_bReAttackZ1Right != m_FrameDataFuture.syncData.bIsRight || m_fReAttackZ1Time <= 0.0f) )
	{
		StateChange( ENSI_COMBO_Z );
	}
	else if( m_InputData.oneX == true )
	{
		StateChange( ENSI_COMBO_X );
	}
	else if( SpecialAttackEventProcess() == true )
	{
	}
	else if( m_InputData.pureDoubleRight == true || m_InputData.pureDoubleLeft == true )
	{
		StateChangeDashIfPossible();
	}
	else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
	{
		StateChange( USI_WALK );
	}
	else if( m_InputData.pureUp == true )
	{
		StateChange( USI_JUMP_UP );
		m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		m_FrameDataFuture.syncData.position.y += LINE_RADIUS;
	}
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( GetHyperModeStateID() )
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( USI_HYPER_MODE )
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	
		
		//ELSE_IF_EVE_CAN_USE_SPECIAL_ABILITY_THEN_STATE_CHANGE( 35.f, m_bInvisibility, ENSI_INVISIBILITY_ON )
	else if( m_InputData.oneDown == true 
	&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, LINE_RADIUS, &m_FrameDataFuture.unitCondition.landPosition, &m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
#ifdef RIDING_SYSTEM
	else if ( true == GetRidingOn() )
	{
		StateChange( USI_RIDING_ON );
	}
#endif //RIDING_SYSTEM

	CommonEventProcess();
}

void CX2GUEve::ENSI_WALK_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.oneZ == true && (m_bReAttackZ1Right != m_FrameDataFuture.syncData.bIsRight || m_fReAttackZ1Time <= 0.0f) )
	{
		StateChange( ENSI_COMBO_Z );
	}
	else if( m_InputData.oneX == true )
	{
		StateChange( ENSI_COMBO_X );
	}
	else if( SpecialAttackEventProcess() == true )
	{
	}
	else if( m_InputData.pureDoubleRight == true || m_InputData.pureDoubleLeft == true )
	{
		StateChangeDashIfPossible();
	}
	else if( m_InputData.pureRight == false && m_InputData.pureLeft == false )
	{
		StateChange( USI_WAIT );
	}
	else if( m_InputData.pureUp == true )
	{
		StateChange( USI_JUMP_UP );
		m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		m_FrameDataFuture.syncData.position.y += LINE_RADIUS;
	}
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( GetHyperModeStateID() )
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항	
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( USI_HYPER_MODE )
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항	
	
		//ELSE_IF_EVE_CAN_USE_SPECIAL_ABILITY_THEN_STATE_CHANGE( 35.f, m_bInvisibility, ENSI_INVISIBILITY_ON )
	else if( m_InputData.oneDown == true 
	&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, 
	LINE_RADIUS, 
	&m_FrameDataFuture.unitCondition.landPosition, 
	&m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
#ifdef RIDING_SYSTEM
	else if ( true == GetRidingOn() )
	{
		StateChange( USI_RIDING_ON );
	}
#endif //RIDING_SYSTEM

	CommonEventProcess();
}


//ENSI_JUMP_READY
void CX2GUEve::ENSI_JUMP_READY_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.oneZ == true )
	{
		StateChange( ENSI_JUMP_COMBO_Z );
		m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		m_FrameDataFuture.syncData.position.y += LINE_RADIUS;

		m_pComboGuide->ShowComboCommand(L"J", L"JZ");
	}
	else if( m_InputData.oneX == true )
	{
		StateChange( ENSI_JUMP_COMBO_X );
		m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		m_FrameDataFuture.syncData.position.y += LINE_RADIUS;
		m_pComboGuide->ShowComboCommand(L"J", L"JX");
	}
	else if( SpecialAttackEventProcess() == true )
	{
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true
		|| m_InputData.pureRight == true
		|| m_InputData.pureLeft == true )
	{
		StateChange( USI_JUMP_UP );
		m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		m_FrameDataFuture.syncData.position.y += LINE_RADIUS;
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_JUMP_UP_EventProcess()
{
#ifdef EVE_ELECTRA
	if( m_iDashJumpCount < 2 + m_iPhotonBoosterAdditionalDashJumpCount && m_InputData.pureDown == false && 
		( m_InputData.pureDoubleLeft == true || m_InputData.pureDoubleRight == true ) )
#else
	if( m_iDashJumpCount < 2 && m_InputData.pureDown == false && 
		( m_InputData.pureDoubleLeft == true || m_InputData.pureDoubleRight == true ) )
#endif EVE_ELECTRA
	{
		StateChangeJumpDashIfPossible();
	}
	else if( m_InputData.oneUp == true && m_iJumpFlyCount == 0 )
	{
		StateChange( ENSI_JUMP_FLY_UP );
	}
	else if( true == SpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) )
	{
	}
	else if( m_InputData.oneZ == true )
	{
		StateChange( ENSI_JUMP_COMBO_Z );
		m_pComboGuide->ShowComboCommand(L"J", L"JZ");
	}
	else if( m_InputData.oneX == true )
	{
		StateChange( ENSI_JUMP_COMBO_X );
		m_pComboGuide->ShowComboCommand(L"J", L"JX");
	}
	else if( m_PhysicParam.nowSpeed.y <= 0.0f )
	{
		StateChange( USI_JUMP_DOWN );
	}
#ifdef RIDING_SYSTEM
	else if ( true == GetRidingOn() )
	{
		StateChange( USI_RIDING_ON );
	}
#endif //RIDING_SYSTEM

	CommonEventProcess();
}

void CX2GUEve::ENSI_JUMP_DOWN_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		if( true == m_bDownForce )						
		{
			StateChange( ENSI_DASH_JUMP_POWER_LANDING );
		}
		else
		{
			StateChange( USI_JUMP_LANDING );
		}
	}
#ifdef WALL_JUMP_TEST
	else if( m_FrameDataFuture.unitCondition.bFootOnWall == true &&
		( true == m_InputData.oneUp || true == m_InputData.oneDoubleUp ) )
	{
		m_bDisableGravity = true;
		StateChange( ENSI_WALL_LANDING );
	}
#endif WALL_JUMP_TEST
	else if( m_InputData.oneUp == true && m_iJumpFlyCount == 0 )
	{
		StateChange( ENSI_JUMP_FLY_UP );
	}
#ifdef EVE_ELECTRA
	else if( m_iDashJumpCount < 2 + m_iPhotonBoosterAdditionalDashJumpCount && false == m_InputData.pureDown &&
		( m_InputData.pureDoubleLeft == true || m_InputData.pureDoubleRight == true ) )
#else
	else if( m_iDashJumpCount < 2 && false == m_InputData.pureDown &&
		( m_InputData.pureDoubleLeft == true || m_InputData.pureDoubleRight == true ) )
#endif EVE_ELECTRA
	{
		StateChangeJumpDashIfPossible();

	}
#ifdef EVE_FIRST_CHANGE_JOB
	else if( m_sEGQueensThrone.m_bEnable == true && false == m_InputData.pureDown &&
		( m_InputData.pureDoubleLeft == true || m_InputData.pureDoubleRight == true ) )
	{
		StateChangeJumpDashIfPossible();

	}
#endif EVE_FIRST_CHANGE_JOB
	else if( true == SpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) )
	{
	}
	else if( m_InputData.oneZ == true )
	{
		StateChange( ENSI_JUMP_COMBO_Z );
		m_pComboGuide->ShowComboCommand(L"J", L"JZ");
	}
	else if( m_InputData.oneX == true )
	{
		StateChange( ENSI_JUMP_COMBO_X );
		m_pComboGuide->ShowComboCommand(L"J", L"JX");
	}
	else if( m_InputData.pureDown == true )
	{
		m_bDownForce = true;
	}
	else if( m_PhysicParam.nowSpeed.y >= 0.f )
	{
		StateChange( USI_JUMP_UP );
	}	
#ifdef RIDING_SYSTEM
	else if ( true == GetRidingOn() )
	{
		StateChange( USI_RIDING_ON );
	}
#endif //RIDING_SYSTEM

	CommonEventProcess();
}

//ENSI_JUMP_LANDING
void CX2GUEve::ENSI_JUMP_LANDING_StartFuture()
{
	CommonStateStartFuture();

	m_iJumpFlyCount = 0;
	m_iDashJumpCount = 0;
#ifdef EVE_ELECTRA
	m_iDashJumpUpCount = 0;
#endif EVE_ELECTRA

#ifdef SERV_EVE_BATTLE_SERAPH
	m_eBoostDashState = BDS_NONE;
	m_bEnableBoostDash = false;
#endif

}

void CX2GUEve::ENSI_JUMP_LANDING_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.oneZ == true && (m_bReAttackZ1Right != m_FrameDataFuture.syncData.bIsRight || m_fReAttackZ1Time <= 0.0f) )
	{
		StateChange( ENSI_COMBO_Z );
	}
	else if( m_InputData.oneX == true )
	{
		StateChange( ENSI_COMBO_X );
	}
	else if( SpecialAttackEventProcess() == true )
	{
	}
	else if( m_InputData.pureDoubleRight == true || m_InputData.pureDoubleLeft == true )
	{
		StateChangeDashIfPossible();
	}
	else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
	{
		StateChange( USI_WALK );
	}
	else if( m_InputData.pureUp == true )
	{
		StateChange( USI_JUMP_UP );
		m_PhysicParam.nowSpeed.y = GetJumpSpeed();
		m_FrameDataFuture.syncData.position.y += LINE_RADIUS;
	}
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( GetHyperModeStateID() )
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( USI_HYPER_MODE )
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
		//ELSE_IF_EVE_CAN_USE_SPECIAL_ABILITY_THEN_STATE_CHANGE( 35.f, m_bInvisibility, ENSI_INVISIBILITY_ON )
	
	
	else if( m_InputData.oneDown == true 
	&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, 
	LINE_RADIUS, 
	&m_FrameDataFuture.unitCondition.landPosition, 
	&m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXCAS
	{
		StateChange( USI_WAIT, false );
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
}


//ENSI_DASH
/*virtual*/ void CX2GUEve::DashStartFuture()
{
	CommonStateStartFuture();

	m_PhysicParam.nowSpeed.x = 0.0f;
	m_iJumpFlyCount = 0;
	m_iDashJumpCount = 0;
#ifdef EVE_ELECTRA
	m_iDashJumpUpCount = 0;
#endif EVE_ELECTRA

}

void CX2GUEve::ENSI_DASH_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
#ifdef EVE_ELECTRA
		if( m_iDashJumpCount < 2 + m_iPhotonBoosterAdditionalDashJumpCount )
#else
		if( m_iDashJumpCount < 2 )
#endif EVE_ELECTRA
		{
			StateChangeJumpDashIfPossible();

		}
		else
		{
			StateChange( USI_JUMP_DOWN );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}
	}
	else if( m_InputData.oneZ == true )
	{
		StateChange( ENSI_DASH_COMBO_Z );
	}
	else if( m_InputData.oneX == true )
	{
		StateChange( ENSI_DASH_COMBO_X );
	}
	else if( SpecialAttackEventProcess() == true )
	{
	}
#ifdef EVE_ELECTRA
	else if( m_InputData.oneUp == true && m_iDashJumpUpCount  < 1   )
#else
	else if( m_InputData.oneUp == true && m_iDashJumpCount < 2 )
#endif EVE_ELECTRA
	{
		StateChange( USI_DASH_JUMP );
		m_PhysicParam.nowSpeed.y = GetDashJumpSpeed();
	}
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( GetHyperModeStateID() )
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( USI_HYPER_MODE )
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
		//ELSE_IF_EVE_CAN_USE_SPECIAL_ABILITY_THEN_STATE_CHANGE( 35.f, m_bInvisibility, ENSI_INVISIBILITY_ON )
	else if( m_InputData.pureRight == false && m_InputData.pureLeft == false )
	{
		StateChange( USI_DASH_END );
	}
	else if( m_InputData.pureRight == true && m_InputData.pureLeft == true )
	{
		StateChange( USI_DASH_END );
	}
	else if( m_InputData.pureRight == true && m_FrameDataFuture.syncData.bIsRight == false )
	{
		StateChange( USI_DASH_END );
	}
	else if( m_InputData.pureLeft == true && m_FrameDataFuture.syncData.bIsRight == true )
	{
		StateChange( USI_DASH_END );
	}
	else if( m_InputData.oneDown == true 
		&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, 
		LINE_RADIUS, 
		&m_FrameDataFuture.unitCondition.landPosition, 
		&m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
#ifdef RIDING_SYSTEM
	else if ( true == GetRidingOn() )
	{
		StateChange( USI_RIDING_ON );
	}
#endif //RIDING_SYSTEM

#ifdef SERV_EVE_BATTLE_SERAPH
	if( true == m_bHighPoweredElectrics && 1.0f <= m_FrameDataFuture.unitCondition.fStateTime && 
		CX2Unit::UC_EVE_BATTLE_SERAPH == GetUnit()->GetClass() )
	{
		StateChange( ENSI_EBS_BOOST_DASH_START );
	}
#endif

	CommonEventProcess();
}


//ENSI_DASH_END
void CX2GUEve::ENSI_DASH_END_StartFuture()
{
	CommonStateStartFuture();

	m_PhysicParam.nowSpeed.x = GetDashSpeed();
}

void CX2GUEve::ENSI_DASH_END_Start()
{
	CommonStateStart();

}

void CX2GUEve::ENSI_DASH_END_FrameMove()
{
	if( m_pXSkinAnim->EventTimer( 0.4f ) == true )
	{
		CreateStepDust();
	}

	CommonFrameMove();
}


void CX2GUEve::ENSI_DASH_END_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.oneZ == true && (m_bReAttackZ1Right != m_FrameDataFuture.syncData.bIsRight || m_fReAttackZ1Time <= 0.0f) )
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > m_pXSkinAnimFuture->GetMaxAnimationTime() / 8.0f )
		{
			StateChange( ENSI_COMBO_Z );
		}
		else
		{
			StateChange( ENSI_DASH_COMBO_Z );
		}
	}
	else if( m_InputData.oneX == true )
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > m_pXSkinAnimFuture->GetMaxAnimationTime() / 8.0f )
		{
			StateChange( ENSI_COMBO_X );
		}
		else
		{
			StateChange( ENSI_DASH_COMBO_X );
		}
	}
	else if( SpecialAttackEventProcess() == true)
	{
	}
	else if( m_InputData.pureDoubleRight == true || m_InputData.pureDoubleLeft == true )
	{
		StateChangeDashIfPossible();
	}
	//3키 대시
	else if( m_InputData.oneRight == true && m_FrameDataFuture.syncData.bIsRight == true )
	{
		StateChangeDashIfPossible();
	}
	else if( m_InputData.oneLeft == true && m_FrameDataFuture.syncData.bIsRight == false )
	{
		StateChangeDashIfPossible();
	}
	else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
	{
		StateChange( USI_WALK );
	}
	else if( m_InputData.oneDown == true 
		&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, 
		LINE_RADIUS, 
		&m_FrameDataFuture.unitCondition.landPosition, 
		&m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.oneUp == true )
	{
		StateChange( USI_JUMP_READY );
	}
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( GetHyperModeStateID() )
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( USI_HYPER_MODE )
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
		//ELSE_IF_EVE_CAN_USE_SPECIAL_ABILITY_THEN_STATE_CHANGE( 35.f, m_bInvisibility, ENSI_INVISIBILITY_ON )
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( USI_WAIT );
	}
#ifdef RIDING_SYSTEM
	else if ( true == GetRidingOn() )
	{
		StateChange( USI_RIDING_ON );
	}
#endif //RIDING_SYSTEM

	CommonEventProcess();
}



//ENSI_DASH_JUMP
void CX2GUEve::ENSI_DASH_JUMP_StartFuture()
{
	CommonStateStartFuture();

	//m_PhysicParam.fDownAccel		= m_PhysicParam.fGAccel * 1.2f;
	m_bDownForce					= false;

	m_bDisableGravity = true;

	m_iDashJumpCount += 1;
	m_iJumpFlyCount += 1;
#ifdef EVE_ELECTRA
	m_iDashJumpUpCount++;
#endif EVE_ELECTRA

	// note!! 대시 점프 속도 스크립트에서 테스트 할 때 썻던 코드
	//float fValue1, fValue2, fValue3;
	//LUA_GET_VALUE( m_LuaManager, "TEST_SPEED_A",		fValue1,		1.f );		
	//LUA_GET_VALUE( m_LuaManager, "TEST_SPEED_B",		fValue2,		1.f );
	//LUA_GET_VALUE( m_LuaManager, "TEST_SPEED_C",		fValue3,		1.f );
	//m_fCurrDashJumpTime = 0.65f;

	m_fCurrDashJumpTime	= s_fMaxDashJumpTime;

}


void CX2GUEve::ENSI_DASH_JUMP_Start()
{
	CommonStateStart();

	if( GetMatrix().GetYPos() == m_FrameDataNow.unitCondition.landPosition.y )
	{
		CreateStepDust();
	}


	if( false == GetAbsoluteInvisibility() )
	{
		D3DXVECTOR3 vRot = GetRotateDegree();
		vRot.z += 45.f;
		if( false == GetIsRight() )
		{
			vRot.y -= 15.f; 
		}
		else
		{
			vRot.y += 15.f;
		}

		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DashWave01_Eve_DashAttack", vBonePos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( vRot );
			pSeq->SetAxisAngle( vRot );
		}

		vBonePos.y -= 60.f;
		if( true == GetIsRight() )
		{
			vBonePos -= GetDirVector() * 60.f;
		}
		else
		{
			vBonePos += GetDirVector() * 60.f;
		}
		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DashWave01_Eve_DashAttack_Small", vBonePos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( vRot );
			pSeq->SetAxisAngle( vRot );
		}
	}
}

void CX2GUEve::ENSI_DASH_JUMP_FrameMoveFuture()
{
	m_fCurrDashJumpTime -= m_fElapsedTime;

	//float fValue1, fValue2, fValue3;
	//LUA_GET_VALUE( m_LuaManager, "TEST_SPEED_A",		fValue1,		1.f );		
	//LUA_GET_VALUE( m_LuaManager, "TEST_SPEED_B",		fValue2,		1.f );
	//LUA_GET_VALUE( m_LuaManager, "TEST_SPEED_C",		fValue3,		1.f );

	const float fValue = m_fCurrDashJumpTime / s_fMaxDashJumpTime;
	const float NOW_FLY_SPEED_SCALE = s_fDashJumpSpeedScale * powf( fValue, 2 ) + s_fDashJumpSpeedLowerBound;

	if( m_fCurrDashJumpTime < 0.f )
	{
		StateChange( USI_JUMP_DOWN );
	}
	else if( m_InputData.pureUp == true && 
		m_InputData.pureRight == true && m_FrameDataNow.syncData.bIsRight	== true )
	{
		m_PhysicParam.nowSpeed.x			= GetDashSpeed()		* NOW_FLY_SPEED_SCALE;
		m_PhysicParam.nowSpeed.y			= GetDashJumpSpeed()	* NOW_FLY_SPEED_SCALE;
	}
	else if( m_InputData.pureUp == true && 
		m_InputData.pureLeft == true && m_FrameDataNow.syncData.bIsRight	== false )
	{
		m_PhysicParam.nowSpeed.x			= GetDashSpeed()		* NOW_FLY_SPEED_SCALE;
		m_PhysicParam.nowSpeed.y			= GetDashJumpSpeed()	* NOW_FLY_SPEED_SCALE;
	}
	else
	{
		StateChange( USI_JUMP_DOWN );
	}

	CommonFrameMoveFuture();
}

void CX2GUEve::ENSI_DASH_JUMP_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true )
		{
			StateChange( USI_DASH_JUMP );
			m_PhysicParam.nowSpeed.y = GetDashJumpSpeed();
			m_bDownForce = false;
		}
		else
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChangeDashIfPossible();
			}
			else
			{
				StateChange( USI_JUMP_LANDING ); // not dash jump landing
			}
			m_bDownForce = false;
		}
	}
#ifdef WALL_JUMP_TEST
	else if( m_FrameDataFuture.unitCondition.bFootOnWall == true &&
		( true == m_InputData.oneUp || true == m_InputData.oneDoubleUp ) )
	{
		m_bDisableGravity = true;
		StateChange( ENSI_WALL_LANDING );
	}
#endif WALL_JUMP_TEST
	else if( true == SpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) )
	{
	}
	else if( m_InputData.oneZ == true )
	{
		StateChange( ENSI_DASH_JUMP_COMBO_Z );
	}
	else if( m_InputData.oneX == true && m_fReDashJumpXTime <= 0.0f )
	{
		StateChange( ENSI_DASH_JUMP_COMBO_X );
	}
	else if( m_InputData.pureRight == true )
	{
		if( m_FrameDataFuture.syncData.bIsRight == false )
		{
			//if( m_PhysicParam.nowSpeed.y > GetJumpSpeed() )
			//	m_PhysicParam.nowSpeed.y = GetJumpSpeed();

			if( m_PhysicParam.nowSpeed.y > 0.0f )
			{
				m_PhysicParam.nowSpeed.y = GetJumpSpeed();
				StateChange( USI_JUMP_UP );
			}
			else
			{
				StateChange( USI_JUMP_DOWN );
			}
		}
	}
	else if( m_InputData.pureLeft == true )
	{
		if( m_FrameDataFuture.syncData.bIsRight == true )
		{
			//if( m_PhysicParam.nowSpeed.y > GetJumpSpeed() )
			//	m_PhysicParam.nowSpeed.y = GetJumpSpeed();

			if( m_PhysicParam.nowSpeed.y > 0.0f )
			{
				m_PhysicParam.nowSpeed.y = GetJumpSpeed();
				StateChange( USI_JUMP_UP );
			}
			else
			{
				StateChange( USI_JUMP_DOWN );
			}
		}
	}
#ifdef RIDING_SYSTEM
	else if ( true == GetRidingOn() )
	{
		StateChange( USI_RIDING_ON );
	}
#endif //RIDING_SYSTEM



	if( m_InputData.oneUp == true && m_PhysicParam.nowSpeed.y <= 0.0f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}
	if( m_InputData.oneDown == true )
	{
		m_PhysicParam.nowSpeed.y = m_PhysicParam.fMaxGSpeed;
		m_bDownForce = true;
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	}


	CommonEventProcess();
}

void CX2GUEve::ENSI_DASH_JUMP_EndFuture()
{
	/// 버그 수정 인듯
#ifdef SERV_EVE_BATTLE_SERAPH
	CommonStateEndFuture();
#else
	CommonStateEnd();
#endif


	if( m_PhysicParam.nowSpeed.x > GetDashSpeed() )
	{
		m_PhysicParam.nowSpeed.x = GetDashSpeed();
	}

	//m_PhysicParam.fDownAccel	= 0.0f;

	m_bDisableGravity = false;

#ifdef SERV_EVE_BATTLE_SERAPH
	m_bAfterJumpDash = false;
#endif
}

void CX2GUEve::ENSI_DASH_JUMP_LANDING_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	if( m_InputData.oneZ == true )
	{
		StateChange( ENSI_COMBO_Z );
	}
	else if( m_InputData.oneX == true )
	{
		StateChange( ENSI_COMBO_X );
	}
	else if( SpecialAttackEventProcess() == true )
	{
	}
	else if( m_InputData.pureDoubleRight == true || m_InputData.pureDoubleLeft == true )
	{
		StateChangeDashIfPossible();
	}
	else if( m_InputData.oneRight == true && m_FrameDataFuture.syncData.bIsRight == true )
	{
		StateChangeDashIfPossible();
	}
	else if( m_InputData.oneLeft == true && m_FrameDataFuture.syncData.bIsRight == false )
	{
		StateChangeDashIfPossible();
	}
	else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
	{
		StateChange( USI_WALK );
	}
	else if( m_InputData.pureUp == true )
	{
		StateChange( USI_JUMP_READY );
	}
	//ELSE_IF_EVE_CAN_USE_SPECIAL_ABILITY_THEN_STATE_CHANGE( 35.f, m_bInvisibility, ENSI_INVISIBILITY_ON )
	else if( m_InputData.oneDown == true 
		&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, 
		LINE_RADIUS, 
		&m_FrameDataFuture.unitCondition.landPosition, 
		&m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}		
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
}


//ENSI_DASH_JUMP_POWER_LANDING
void CX2GUEve::ENSI_DASH_JUMP_POWER_LANDING_StartFuture()
{
	CommonStateStartFuture();
	m_PhysicParam.nowSpeed.x /= 2.0f;
}

void CX2GUEve::ENSI_DASH_JUMP_POWER_LANDING_Start()
{
	CommonStateStart();
	CreateStepDust();
}

void CX2GUEve::ENSI_DASH_JUMP_POWER_LANDING_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	//else if( m_InputData.oneRight == true || m_InputData.oneLeft == true )
	//{
	//	StateChange( ENSI_WALK );
	//}
	else if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.01f )
	{
		if( m_InputData.oneZ == true )
		{
			StateChange( ENSI_COMBO_Z );
		}
		else if( m_InputData.oneX == true )
		{
			StateChange( ENSI_COMBO_X );
		}
		else if( SpecialAttackEventProcess() == true )
		{
		}
		else if( m_InputData.pureDoubleRight == true || m_InputData.pureDoubleLeft == true )
		{
			StateChangeDashIfPossible();
		}
		else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
		{
			StateChangeDashIfPossible();
		}
		else if( m_InputData.pureUp == true )
		{
			StateChange( USI_JUMP_READY );
		}
		//ELSE_IF_EVE_CAN_USE_SPECIAL_ABILITY_THEN_STATE_CHANGE( 35.f, m_bInvisibility, ENSI_INVISIBILITY_ON )
		else if( m_InputData.oneDown == true 
			&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, 
			LINE_RADIUS, 
			&m_FrameDataFuture.unitCondition.landPosition, 
			&m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
		{
			StateChange( USI_JUMP_DOWN );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}

		else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{
			StateChange( USI_WAIT );
		}
	}

	CommonEventProcess();
}




void CX2GUEve::ENSI_JUMP_FLY_UP_StartFuture()
{
	CommonStateStartFuture();

	//m_PhysicParam.fDownAccel		= m_PhysicParam.fGAccel * 1.2f;
	m_bDownForce					= false;
	m_iJumpFlyCount		+= 1;
	m_iDashJumpCount	+= 1;

#ifdef SERV_EVE_BATTLE_SERAPH
	m_bAfterJumpDash = false;
	m_bEnableBoostDash = false;
#endif

	//m_PhysicParam.nowSpeed.y			= m_PhysicParam.GetJumpSpeed() ;

}

void CX2GUEve::ENSI_JUMP_FLY_UP_Start()
{
	CommonStateStart();

	if( false == GetAbsoluteInvisibility() )
	{
		D3DXVECTOR3 vRot = GetRotateDegree();
		vRot.z += 90.f;

		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );
		vBonePos.y -= 40.f;
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DashWave01_Eve_DashAttack", vBonePos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( vRot );
			pSeq->SetAxisAngle( vRot );
		}

		//vBonePos.y -= 60.f;
		//pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DashWave01_Eve_DashAttack_Small", vBonePos );
		//if( NULL != pSeq )
		//{
		//	pSeq->SetAddRotate( vRot );
		//	pSeq->SetAxisAngle( vRot );
		//}
	}
}


void CX2GUEve::ENSI_JUMP_FLY_UP_FrameMoveFuture()
{
	if( m_InputData.pureRight == true && m_FrameDataNow.syncData.bIsRight	== true )
	{
		m_PhysicParam.nowSpeed.x			= GetWalkSpeed();
	}
	else if( m_InputData.pureLeft == true && m_FrameDataNow.syncData.bIsRight	== false )
	{
		m_PhysicParam.nowSpeed.x			= GetWalkSpeed();
	}

	if( m_InputData.pureDown == true  && m_InputData.pureUp == false )
	{
		m_PhysicParam.nowSpeed.y -= m_PhysicParam.fGAccel * m_fElapsedTime;
	}
	CommonFrameMoveFuture();
}

void CX2GUEve::ENSI_JUMP_FLY_UP_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
		{
			StateChange( USI_WALK );
		}
		else
		{
			StateChange( USI_JUMP_LANDING );	
		}

		m_bDownForce = false;

	}
#ifdef WALL_JUMP_TEST
	else if( m_FrameDataFuture.unitCondition.bFootOnWall == true &&
		( true == m_InputData.oneUp || true == m_InputData.oneDoubleUp ) )
	{
		m_bDisableGravity = true;
		StateChange( ENSI_WALL_LANDING );
	}
#endif WALL_JUMP_TEST
	else if( true == SpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) )
	{
	}
	else if( m_InputData.oneZ == true )
	{
		m_PhysicParam.nowSpeed.y = 0.f;	
		StateChange( ENSI_JUMP_COMBO_Z );

		m_pComboGuide->ShowComboCommand(L"j", L"JJZ");
	}
	else if( m_InputData.oneX == true && m_fReDashJumpXTime <= 0.0f )
	{
		m_PhysicParam.nowSpeed.y = 0.f;
		StateChange( ENSI_JUMP_COMBO_X ); 

		m_pComboGuide->ShowComboCommand(L"j", L"JJX");
	}
	//else if( m_InputData.pureRight == true )
	//{
	//	if( m_FrameDataFuture.syncData.bIsRight == false )
	//	{
	//		if( m_PhysicParam.nowSpeed.y > GetJumpSpeed() )
	//			m_PhysicParam.nowSpeed.y = GetJumpSpeed();

	//		if( m_PhysicParam.nowSpeed.y > 0.0f )
	//			StateChange( ENSI_JUMP_UP );
	//		else
	//			StateChange( ENSI_JUMP_DOWN );
	//	}
	//}
	//else if( m_InputData.pureLeft == true )
	//{
	//	if( m_FrameDataFuture.syncData.bIsRight == true )
	//	{
	//		if( m_PhysicParam.nowSpeed.y > GetJumpSpeed() )
	//			m_PhysicParam.nowSpeed.y = GetJumpSpeed();

	//		if( m_PhysicParam.nowSpeed.y > 0.0f )
	//			StateChange( ENSI_JUMP_UP );
	//		else
	//			StateChange( ENSI_JUMP_DOWN );
	//	}
	//}
	else if( m_PhysicParam.nowSpeed.y <= 0.0f )
	{
		StateChange( ENSI_JUMP_FLY_DOWN );
	}

	//if( m_InputData.oneUp == true && m_PhysicParam.nowSpeed.y <= 0.0f )
	//{
	//	m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	//}
	//if( m_InputData.oneDown == true )
	//{
	//	m_PhysicParam.nowSpeed.y = m_PhysicParam.fMaxGSpeed;
	//	m_bDownForce = true;
	//	m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	//}



	CommonEventProcess();
}

void CX2GUEve::ENSI_JUMP_FLY_UP_EndFuture()
{
	CommonStateEnd();

	//m_PhysicParam.fDownAccel		= m_PhysicParam.fGAccel * -0.8f;
	//m_PhysicParam.fDownAccel	= 0.0f;
}





void CX2GUEve::ENSI_JUMP_FLY_DOWN_StartFuture()
{
	CommonStateStartFuture();

	m_PhysicParam.fDownAccel		= m_PhysicParam.fGAccel * -0.8f;
	m_bDownForce = false;

}

void CX2GUEve::ENSI_JUMP_FLY_DOWN_FrameMoveFuture()
{
	if( m_InputData.pureRight == true )
	{
		m_FrameDataFuture.syncData.bIsRight = true;
		m_PhysicParam.nowSpeed.x = GetDashSpeed();
	}
	else if( m_InputData.pureLeft == true )
	{
		m_FrameDataFuture.syncData.bIsRight = false;
		m_PhysicParam.nowSpeed.x = GetDashSpeed();
	}

	if( m_InputData.pureDown == true && m_InputData.pureUp == false )
	{
		m_PhysicParam.nowSpeed.y -= m_PhysicParam.fGAccel * m_fElapsedTime;
	}
	CommonFrameMoveFuture();
}


void CX2GUEve::ENSI_JUMP_FLY_DOWN_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		if( true == m_bDownForce )
		{
			StateChange( ENSI_DASH_JUMP_POWER_LANDING );
		}
		else
		{
			StateChange( USI_JUMP_LANDING );
		}
	}
#ifdef WALL_JUMP_TEST
	else if( m_FrameDataFuture.unitCondition.bFootOnWall == true &&
		( true == m_InputData.oneUp || true == m_InputData.oneDoubleUp ) )
	{
		m_bDisableGravity = true;
		StateChange( ENSI_WALL_LANDING );
	}
#endif WALL_JUMP_TEST
	else if( true == SpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) )
	{
	}
	else if( m_InputData.oneZ == true )
	{
		StateChange( ENSI_JUMP_COMBO_Z );
		m_pComboGuide->ShowComboCommand(L"j", L"JJZ");
	}
	else if( m_InputData.oneX == true )
	{
		StateChange( ENSI_JUMP_COMBO_X );
		m_pComboGuide->ShowComboCommand(L"j", L"JJX");
	}
	else if( m_PhysicParam.nowSpeed.y >= 0.0f )
	{
		StateChange( USI_JUMP_UP );
	}
	else if( m_InputData.pureDown == true )
	{
		m_bDownForce = true;
	}

	CommonEventProcess();
}


void CX2GUEve::ENSI_JUMP_FLY_DOWN_EndFuture()
{
	CommonStateEnd();

	m_PhysicParam.fDownAccel	= 0.f;
}



void CX2GUEve::ENSI_JUMP_DASH_StartFuture()
{
	CommonStateStartFuture();

	//m_PhysicParam.fDownAccel		= m_PhysicParam.fGAccel * 1.2f;
	m_bDownForce					= false;

	m_bDisableGravity	= true;
	m_iDashJumpCount	+= 1;
	m_iJumpFlyCount		+= 1;


	//float fValue1, fValue2, fValue3;
	//LUA_GET_VALUE( m_LuaManager, "TEST_SPEED_A",		fValue1,		1.f ); 
	//LUA_GET_VALUE( m_LuaManager, "TEST_SPEED_B",		fValue2,		1.f );
	//LUA_GET_VALUE( m_LuaManager, "TEST_SPEED_C",		fValue3,		1.f );
	//m_fCurrDashJumpTime = fValue3;

	m_fCurrDashJumpTime = s_fMaxDashJumpTime;
}

void CX2GUEve::ENSI_JUMP_DASH_Start()
{
	CommonStateStart();

	if( false == GetAbsoluteInvisibility() )
	{
		D3DXVECTOR3 vRot = GetRotateDegree();
		if( false == GetIsRight() )
		{
			vRot.y -= 15.f;
		}
		else
		{
			vRot.y += 15.f;
		}

		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DashWave01_Eve_DashAttack", vBonePos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( vRot );
			pSeq->SetAxisAngle( vRot );
		}


		if( true == GetIsRight() )
		{
			vBonePos -= GetDirVector() * 60.f;
		}
		else
		{
			vBonePos += GetDirVector() * 60.f;
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DashWave01_Eve_DashAttack_Small", vBonePos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( vRot );
			pSeq->SetAxisAngle( vRot );
		}
	}
}

void CX2GUEve::ENSI_JUMP_DASH_FrameMoveFuture()
{
	m_fCurrDashJumpTime -= m_fElapsedTime;


	//float fValue1, fValue2, fValue3;
	//LUA_GET_VALUE( m_LuaManager, "TEST_SPEED_A",		fValue1,		1.f );
	//LUA_GET_VALUE( m_LuaManager, "TEST_SPEED_B",		fValue2,		1.f );
	//LUA_GET_VALUE( m_LuaManager, "TEST_SPEED_C",		fValue3,		1.f );
	//const float fValue = m_fCurrDashJumpTime / fValue3;

	const float fValue = m_fCurrDashJumpTime / s_fMaxDashJumpTime;
	const float NOW_FLY_SPEED_SCALE = s_fDashJumpSpeedScale * powf( fValue, 2 ) + s_fDashJumpSpeedLowerBound;


	if( m_fCurrDashJumpTime < 0.f )
	{
		StateChange( USI_JUMP_DOWN );
	}
	else if( m_InputData.pureDown == false && 
		m_InputData.pureRight == true && m_FrameDataNow.syncData.bIsRight == true )
	{
		m_PhysicParam.nowSpeed.x			= GetDashSpeed() * NOW_FLY_SPEED_SCALE;
		m_PhysicParam.nowSpeed.y			= 0.f;
	}
	else if( m_InputData.pureDown == false &&
		m_InputData.pureLeft == true && m_FrameDataNow.syncData.bIsRight == false )
	{
		m_PhysicParam.nowSpeed.x			= GetDashSpeed() * NOW_FLY_SPEED_SCALE;
		m_PhysicParam.nowSpeed.y			= 0.f;
	}
	else
	{
		StateChange( USI_JUMP_DOWN );
	}

	CommonFrameMoveFuture();
}

void CX2GUEve::ENSI_JUMP_DASH_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true )
		{
			StateChange( USI_DASH_JUMP );
			m_PhysicParam.nowSpeed.y = GetDashJumpSpeed();
			m_bDownForce = false;
		}
		else if( m_bDownForce == true )
		{
			StateChange( ENSI_DASH_JUMP_POWER_LANDING );
			m_bDownForce = false;
		}
		else
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChangeDashIfPossible();
			}
			else
			{
				StateChange( USI_JUMP_LANDING );		// not dash_jump_landing 
			}
			m_bDownForce = false;
		}
	}
#ifdef WALL_JUMP_TEST
	else if( m_FrameDataFuture.unitCondition.bFootOnWall == true &&
		( true == m_InputData.oneUp || true == m_InputData.oneDoubleUp ) )
	{
		m_bDisableGravity = true;
		StateChange( ENSI_WALL_LANDING );
	}
#endif WALL_JUMP_TEST
#ifdef EVE_ELECTRA
	else if( m_iDashJumpUpCount < 1 && 
		m_InputData.pureDown == false && m_InputData.pureUp == true )
#else
	else if( m_iDashJumpCount < 2 && 
		m_InputData.pureDown == false && m_InputData.pureUp == true )
#endif EVE_ELECTRA
	{
		StateChange( USI_DASH_JUMP );
	}
	else if( true == SpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) )
	{
	}
	else if( m_InputData.oneZ == true )
	{
		StateChange( ENSI_DASH_JUMP_COMBO_Z );
	}
	else if( m_InputData.oneX == true && m_fReDashJumpXTime <= 0.0f )
	{
		StateChange( ENSI_DASH_JUMP_COMBO_X );
	}
	else if( m_InputData.pureRight == true )
	{
		if( m_FrameDataFuture.syncData.bIsRight == false )
		{
			if( m_PhysicParam.nowSpeed.y > GetJumpSpeed() )
				m_PhysicParam.nowSpeed.y = GetJumpSpeed();

			if( m_PhysicParam.nowSpeed.y > 0.0f )
				StateChange( USI_JUMP_UP );
			else
				StateChange( USI_JUMP_DOWN );
		}
	}
	else if( m_InputData.pureLeft == true )
	{
		if( m_FrameDataFuture.syncData.bIsRight == true )
		{
			if( m_PhysicParam.nowSpeed.y > GetJumpSpeed() )
				m_PhysicParam.nowSpeed.y = GetJumpSpeed();

			if( m_PhysicParam.nowSpeed.y > 0.0f )
				StateChange( USI_JUMP_UP );
			else
				StateChange( USI_JUMP_DOWN );
		}
	}


	if( m_InputData.oneUp == true && m_PhysicParam.nowSpeed.y <= 0.0f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}


	if( m_InputData.pureDown == true )
	{
		//m_PhysicParam.nowSpeed.y = m_PhysicParam.fMaxGSpeed;
		m_bDownForce = true;
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	}


	CommonEventProcess();
}

void CX2GUEve::ENSI_JUMP_DASH_EndFuture()
{
	CommonStateEnd();

	//m_PhysicParam.fDownAccel	= 0.0f;

	if( m_PhysicParam.nowSpeed.x > GetDashSpeed() )
	{
		m_PhysicParam.nowSpeed.x = GetDashSpeed();
	}

	m_bDisableGravity = false;

#ifdef SERV_EVE_BATTLE_SERAPH
	m_bAfterJumpDash = true;
#endif
}








//ENSI_HYPER_MODE
void CX2GUEve::HyperModeFrameMove()
{
#ifdef MODIFY_RIDING_PET_AWAKE
	CommonHyperModeFrameMove( 0.05f, 0.83f );
#else
	g_pX2Game->GetWorld()->SetWorldColor( 0xff222222 );
	//g_pX2Game->GetWorld()->FadeWorldColor( g_pX2Game->GetWorld()->GetOriginColor(), 1.0f );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.05f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.05f ) == true && EventCheck(0.05f, false) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{		
		if( false == GetAbsoluteInvisibility() )
		{
			CKTDGParticleSystem::CParticleEventSequence* pSeqHyperModeChangeLine	= g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_HYPER_MODE_CHANGE_LINE ) );
			CKTDGParticleSystem::CParticleEventSequence* pSeqHyperModeChangeCenter	= g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_HYPER_MODE_CHANGE_CENTER ) );

			D3DXVECTOR3 pos = GetBonePos( L"Dummy1_Rhand" );
			if( pSeqHyperModeChangeLine != NULL )
			{
				pSeqHyperModeChangeLine->SetPosition( pos );
				pSeqHyperModeChangeLine->SetEmitRate( 40.0f, 80.0f );
				pSeqHyperModeChangeLine->SetTriggerCount( 10 );

				pSeqHyperModeChangeLine->SetBlackHolePosition( pos );
				pSeqHyperModeChangeLine->UseLookPoint( true );
				pSeqHyperModeChangeLine->SetLookPoint( pos );
			}
			if( pSeqHyperModeChangeCenter != NULL )
			{
				pSeqHyperModeChangeCenter->SetPosition( pos );
				pSeqHyperModeChangeCenter->SetEmitRate( 20.0f, 40.0f );
				pSeqHyperModeChangeCenter->SetTriggerCount( 10 );
			}
		}
	}


#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.83f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.83f ) == true && EventCheck(0.83f, false) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if( false == GetAbsoluteInvisibility() )
		{
			CKTDGParticleSystem::CParticleEventSequence* pSeqGroundShockWave	= g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_GROUND_SHOCK_WAVE ) );
			D3DXVECTOR3 pos = GetBonePos( L"Dummy1_Rhand" );
			if( pSeqGroundShockWave != NULL )
			{
				D3DXVECTOR3 posl = m_FrameDataNow.unitCondition.landPosition;
				posl.y += 5.0f;
				pSeqGroundShockWave->SetPosition( posl );
				pSeqGroundShockWave->SetEmitRate( 5.0f, 10.0f );
				pSeqGroundShockWave->SetTriggerCount( 3 );
			}

			CKTDGParticleSystem::CParticleEventSequence* pSeqWhiteShockWave		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_WHITE_SHOCK_WAVE ) );
			if( pSeqWhiteShockWave != NULL )
			{
				pSeqWhiteShockWave->SetPosition( pos );
				pSeqWhiteShockWave->SetEmitRate( 10.0f, 10.0f );
				pSeqWhiteShockWave->SetTriggerCount( 1 );
			}

			CKTDGParticleSystem::CParticleEventSequence* pSeqImpactTick 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_IMPACT_TICK ) );
			if( pSeqImpactTick != NULL )
			{
				pSeqImpactTick->SetPosition( pos );
				pSeqImpactTick->SetEmitRate( 200.0f, 200.0f );
				pSeqImpactTick->SetTriggerCount( 30 );
				pSeqImpactTick->SetLandPosition( m_FrameDataNow.unitCondition.landPosition.y );
			}
		}

		if ( GetShowSmallGageAndName() )
		{
			CKTDGParticleSystem::CParticleEventSequence* pSeqSTR_ToKang 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_STR_TOKANG ) );
			D3DXVECTOR2 projPos = g_pKTDXApp->GetProj3DPos( m_FrameDataNow.syncData.position );
			if( pSeqSTR_ToKang != NULL )
			{
				pSeqSTR_ToKang->SetPosition( D3DXVECTOR3( projPos.x, projPos.y, 0.0f ) );
				pSeqSTR_ToKang->SetEmitRate( 100.0f, 100.0f );
				pSeqSTR_ToKang->SetTriggerCount( 1 );
			}

			UpDownCrashCamera( 30.0f, 0.4f );
			g_pKTDXApp->GetDGManager()->ClearScreen();
		}

		//SetBoostPower( 30 );

#ifdef HYPER_MODE_EFFECT_ADD_BY_ITEM
		ShowSpecialEffectHyperMode();
#endif // HYPER_MODE_EFFECT_ADD_BY_ITEM

		CKTDGParticleSystem::CParticleEventSequence* pSeq_RFoot = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostRFoot );
		CKTDGParticleSystem::CParticleEventSequence* pSeq_LFoot = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostLFoot );
		CKTDGParticleSystem::CParticleEventSequence* pSeq_RArm = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostRArm );
		CKTDGParticleSystem::CParticleEventSequence* pSeq_LArm = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostLArm );




		if( pSeq_RFoot != NULL )
		{
			pSeq_RFoot->SetPosition( GetBonePos( L"Bip01_R_Foot" ) );
			pSeq_RFoot->SetEmitRate( 30, 40 );
		}
		if( pSeq_LFoot != NULL )
		{
			pSeq_LFoot->SetPosition( GetBonePos( L"Bip01_L_Foot" ) );
			pSeq_LFoot->SetEmitRate( 30, 40 );
		}
		if( pSeq_RArm != NULL )
		{
			pSeq_RArm->SetPosition( GetBonePos( L"Bip01_R_UpperArm" ) );
			pSeq_RArm->SetEmitRate( 30, 40 );
		}
		if( pSeq_LArm != NULL )
		{
			pSeq_LArm->SetPosition( GetBonePos( L"Bip01_L_UpperArm" ) );
			pSeq_LArm->SetEmitRate( 30, 40 );
		}

		if( pSeq_RFoot		!= NULL
			&& pSeq_LFoot	!= NULL
			&& pSeq_RArm 	!= NULL
			&& pSeq_LArm 	!= NULL )
		{
			pSeq_RFoot->SetTrace( true );
			pSeq_LFoot->SetTrace( true );
			pSeq_RArm->SetTrace( true );
			pSeq_LArm->SetTrace( true );


			if( true == GetAbsoluteInvisibility() )
			{
				pSeq_RFoot->SetShowObject( false );
				pSeq_LFoot->SetShowObject( false );
				pSeq_RArm->SetShowObject( false );
				pSeq_LArm->SetShowObject( false );
			}
			else
			{
				pSeq_RFoot->SetShowObject( true );
				pSeq_LFoot->SetShowObject( true );
				pSeq_RArm->SetShowObject( true );
				pSeq_LArm->SetShowObject( true );
			}
		}

		ApplyHyperModeBuff();
	}
	CommonFrameMove();
#endif // MODIFY_RIDING_PET_AWAKE
}


////ENSI_DAMAGE_GROGGY
//void CX2GUEve::ENSI_DAMAGE_GROGGY_FrameMoveFuture()
//{
//	if( m_fGroggyTime > 0.0f )
//	{
//		m_fGroggyTime -= m_fElapsedTime;
//		if( m_fGroggyTime < 0.0f )
//			m_fGroggyTime = 0.0f;
//	}
//	CommonFrameMoveFuture();
//}
//
//void CX2GUEve::ENSI_DAMAGE_GROGGY_EventProcess()
//{
//	if( m_fGroggyTime <= 0.0f )
//	{
//		StateChange( ENSI_WAIT );
//	}
//	CommonEventProcess();
//}

//ENSI_DAMAGE_SMALL_FRONT
void CX2GUEve::ENSI_DAMAGE_SMALL_FRONT_EventProcess()
{
	if( m_FrameDataFuture.syncData.position.y - m_FrameDataFuture.unitCondition.landPosition.y > 200.0f )
	{
		StateChange( USI_DAMAGE_AIR_SMALL );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		if( false == IsOnSomethingFuture() )
		{
			StateChange( USI_DAMAGE_AIR_SMALL );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}
		else
			StateChange( USI_WAIT );
	}	
	CommonEventProcess();
}


//ENSI_DAMAGE_SMALL_BACK
void CX2GUEve::ENSI_DAMAGE_SMALL_BACK_EventProcess()
{
	if( m_FrameDataFuture.syncData.position.y - m_FrameDataFuture.unitCondition.landPosition.y > 200.0f )
	{
		StateChange( USI_DAMAGE_AIR_SMALL );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		if( false == IsOnSomethingFuture() )
		{
			StateChange( USI_DAMAGE_AIR_SMALL );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}
		else
			StateChange( USI_WAIT );
	}	
	CommonEventProcess();
}


//ENSI_DAMAGE_BIG_FRONT
void CX2GUEve::ENSI_DAMAGE_BIG_FRONT_Start()
{
	CommonStateStart();

	CreateStepDust();

}

void CX2GUEve::ENSI_DAMAGE_BIG_FRONT_EventProcess()
{
	if( m_FrameDataFuture.syncData.position.y - m_FrameDataFuture.unitCondition.landPosition.y > 200.0f )
	{
		StateChange( USI_DAMAGE_AIR_SMALL );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.93f )
		{
			StateChange( USI_WAIT );
		}
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		if( false == IsOnSomethingFuture() )
		{
			StateChange( USI_DAMAGE_AIR_SMALL );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}
		else
			StateChange( USI_WAIT );
	}	
	CommonEventProcess();
}


//ENSI_DAMAGE_BIG_BACK
void CX2GUEve::ENSI_DAMAGE_BIG_BACK_Start()
{
	CommonStateStart();

	CreateStepDust();

}

void CX2GUEve::ENSI_DAMAGE_BIG_BACK_EventProcess()
{
	if( m_FrameDataFuture.syncData.position.y - m_FrameDataFuture.unitCondition.landPosition.y > 200.0f )
	{
		StateChange( USI_DAMAGE_AIR_SMALL );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		if( false == IsOnSomethingFuture() )
		{
			StateChange( USI_DAMAGE_AIR_SMALL );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}
		else
			StateChange( USI_WAIT );
	}	
	CommonEventProcess();
}


//ENSI_DAMAGE_DOWN_FRONT
void CX2GUEve::ENSI_DAMAGE_DOWN_FRONT_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.19f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.19f ) == true && EventCheck( 0.19f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{

		CreateStepDust();

	}

	CommonFrameMove();
}


void CX2GUEve::ENSI_DAMAGE_DOWN_FRONT_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_DAMAGE_AIR_FALL );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		if( m_FrameDataFuture.stateParam.bEventFlagList[4] == true )
		{
			if( GetRandomInt() < m_SkillRelatedData.m_iNoDownDamageAtStandUpAttackPercent )
			{
				StateChange( ENSI_STANDUP_ATTACK_FRONT ); // fix!!
			}
			else
			{
				StateChange( ENSI_STANDUP_ATTACK_FRONT );
			}
		}
		else if( m_FrameDataFuture.stateParam.bEventFlagList[1] == true )
		{
			StateChange( ENSI_STANDUP_ATTACK_FRONT );
		}
		else if( m_FrameDataFuture.stateParam.bEventFlagList[2] == true )
			StateChange( ENSI_STANDUP_ROLLING_FRONT_FRONT );
		else if( m_FrameDataFuture.stateParam.bEventFlagList[3] == true )
			StateChange( ENSI_STANDUP_ROLLING_FRONT_BACK );
		else
			StateChange( USI_DAMAGE_STANDUP_FRONT );
	}
	else if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.66 )
	{
		if( m_InputData.oneX == true )
		{	
			m_FrameDataFuture.stateParam.bEventFlagList[2]	= false;
			m_FrameDataFuture.stateParam.bEventFlagList[3]	= false;
			m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
			m_FrameDataFuture.stateParam.bEventFlagList[4]	= true;
		}
		else if( m_InputData.oneZ == true )
		{	
			m_FrameDataFuture.stateParam.bEventFlagList[2]	= false;
			m_FrameDataFuture.stateParam.bEventFlagList[3]	= false;
			m_FrameDataFuture.stateParam.bEventFlagList[1]	= true;
			m_FrameDataFuture.stateParam.bEventFlagList[4]	= false;
		}
		else if( m_FrameDataFuture.syncData.bIsRight == true )
		{
			if( m_InputData.pureRight == true )
			{	
				m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[3]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[2]	= true;
				m_FrameDataFuture.stateParam.bEventFlagList[4]	= false;
			}
			else if( m_InputData.pureLeft == true )
			{	
				m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[2]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[3]	= true;
				m_FrameDataFuture.stateParam.bEventFlagList[4]	= false;
			}
		}
		else
		{
			if( m_InputData.pureRight == true )
			{	
				m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[2]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[3]	= true;
				m_FrameDataFuture.stateParam.bEventFlagList[4]	= false;
			}
			else if( m_InputData.pureLeft == true )
			{	
				m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[3]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[2]	= true;
				m_FrameDataFuture.stateParam.bEventFlagList[4]	= false;
			}
		}
	}

	CommonEventProcess();
}
void CX2GUEve::ENSI_DAMAGE_DOWN_BACK_FrameMove()
{
	if( m_pXSkinAnim->EventTimer( 0.32f ) == true )
	{
		CreateStepDust();

	}

	CommonFrameMove();
}


void CX2GUEve::ENSI_DAMAGE_DOWN_BACK_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_DAMAGE_AIR_FALL );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		if( m_FrameDataFuture.stateParam.bEventFlagList[4] == true )
		{
			if( GetRandomInt() < m_SkillRelatedData.m_iNoDownDamageAtStandUpAttackPercent )
			{
				StateChange( ENSI_STANDUP_ATTACK_BACK ); // fix!!
			}
			else
			{
				StateChange( ENSI_STANDUP_ATTACK_BACK );
			}
		}
		else if( m_FrameDataFuture.stateParam.bEventFlagList[1] == true )
		{
			StateChange( ENSI_STANDUP_ATTACK_BACK );
		}
		else if( m_FrameDataFuture.stateParam.bEventFlagList[2] == true )
			StateChange( ENSI_STANDUP_ROLLING_BACK_FRONT );
		else if( m_FrameDataFuture.stateParam.bEventFlagList[3] == true )
			StateChange( ENSI_STANDUP_ROLLING_BACK_BACK );
		else
			StateChange( USI_DAMAGE_STANDUP_BACK );
	}
	else if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.66 )
	{
		if( m_InputData.oneX == true )
		{	
			m_FrameDataFuture.stateParam.bEventFlagList[2]	= false;
			m_FrameDataFuture.stateParam.bEventFlagList[3]	= false;
			m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
			m_FrameDataFuture.stateParam.bEventFlagList[4]	= true;
		}
		else if( m_InputData.oneZ == true )
		{	
			m_FrameDataFuture.stateParam.bEventFlagList[2]	= false;
			m_FrameDataFuture.stateParam.bEventFlagList[3]	= false;
			m_FrameDataFuture.stateParam.bEventFlagList[1]	= true;
			m_FrameDataFuture.stateParam.bEventFlagList[4]	= false;
		}
		else if( m_FrameDataFuture.syncData.bIsRight == true )
		{
			if( m_InputData.pureRight == true )
			{	
				m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[3]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[2]	= true;
				m_FrameDataFuture.stateParam.bEventFlagList[4]	= false;
			}
			else if( m_InputData.pureLeft == true )
			{	
				m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[2]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[3]	= true;
				m_FrameDataFuture.stateParam.bEventFlagList[4]	= false;
			}
		}
		else
		{
			if( m_InputData.pureRight == true )
			{	
				m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[2]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[3]	= true;
				m_FrameDataFuture.stateParam.bEventFlagList[4]	= false;
			}
			else if( m_InputData.pureLeft == true )
			{	
				m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[3]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[2]	= true;
				m_FrameDataFuture.stateParam.bEventFlagList[4]	= false;
			}
		}
	}

	CommonEventProcess();
}

//ENSI_DAMAGE_AIR_DOWN_LANDING
void CX2GUEve::ENSI_DAMAGE_AIR_DOWN_LANDING_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_DAMAGE_AIR_FALL );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		if( m_FrameDataFuture.stateParam.bEventFlagList[1] == true )
			StateChange( ENSI_STANDUP_ATTACK_FRONT );
		else if( m_FrameDataFuture.stateParam.bEventFlagList[2] == true )
			StateChange( ENSI_STANDUP_ROLLING_FRONT_FRONT );
		else if( m_FrameDataFuture.stateParam.bEventFlagList[3] == true )
			StateChange( ENSI_STANDUP_ROLLING_FRONT_BACK );
		else
			StateChange( USI_DAMAGE_STANDUP_FRONT );
	}
	else if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.66f )
	{
		if( m_InputData.oneZ == true || m_InputData.oneX == true )
		{	
			m_FrameDataFuture.stateParam.bEventFlagList[2]	= false;
			m_FrameDataFuture.stateParam.bEventFlagList[3]	= false;
			m_FrameDataFuture.stateParam.bEventFlagList[1]	= true;
		}
		else if( m_FrameDataFuture.syncData.bIsRight == true )
		{
			if( m_InputData.pureRight == true )
			{	
				m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[3]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[2]	= true;
			}
			else if( m_InputData.pureLeft == true )
			{	
				m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[2]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[3]	= true;
			}
		}
		else
		{
			if( m_InputData.pureRight == true )
			{	
				m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[2]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[3]	= true;
			}
			else if( m_InputData.pureLeft == true )
			{	
				m_FrameDataFuture.stateParam.bEventFlagList[1]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[3]	= false;
				m_FrameDataFuture.stateParam.bEventFlagList[2]	= true;
			}
		}
	}

	CommonEventProcess();
}

//ENSI_STANDUP_ROLLING_FRONT_FRONT
void CX2GUEve::ENSI_STANDUP_ROLLING_FRONT_FRONT_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
		{
			StateChangeDashIfPossible();
		}
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_STANDUP_ROLLING_FRONT_FRONT_End()
{
	CommonStateEnd();
	SetForceInvincible( 0.3f );
	SetShowInvincible( 0.3f );
}


//ENSI_STANDUP_ROLLING_FRONT_BACK
void CX2GUEve::ENSI_STANDUP_ROLLING_FRONT_BACK_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
		{
			StateChangeDashIfPossible();
		}
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}


void CX2GUEve::ENSI_STANDUP_ROLLING_FRONT_BACK_End()
{
	CommonStateEnd();
	SetForceInvincible( 0.3f );
	SetShowInvincible( 0.3f );
}



//ENSI_STANDUP_ROLLING_BACK_FRONT
void CX2GUEve::ENSI_STANDUP_ROLLING_BACK_FRONT_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
		{
			StateChangeDashIfPossible();
		}
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_STANDUP_ROLLING_BACK_FRONT_End()
{
	CommonStateEnd();
	SetForceInvincible( 0.3f );
	SetShowInvincible( 0.3f );
}



//ENSI_STANDUP_ROLLING_BACK_BACK
void CX2GUEve::ENSI_STANDUP_ROLLING_BACK_BACK_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
		{
			StateChangeDashIfPossible();
		}
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_STANDUP_ROLLING_BACK_BACK_End()
{
	CommonStateEnd();
	SetForceInvincible( 0.3f );
	SetShowInvincible( 0.3f );
}


//ENSI_STANDUP_ATTACK_FRONT
void CX2GUEve::ENSI_STANDUP_ATTACK_FRONT_FrameMove()
{

	CommonFrameMove();
}

void CX2GUEve::ENSI_STANDUP_ATTACK_FRONT_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
		{
			StateChange( USI_JUMP_DOWN );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}
		else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
		{
			StateChangeDashIfPossible();
		}
		else
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_STANDUP_ATTACK_FRONT_End()
{
	CommonStateEnd();
	SetForceInvincible( 0.3f );
	SetShowInvincible( 0.3f );
}


//ENSI_STANDUP_ATTACK_BACK
void CX2GUEve::ENSI_STANDUP_ATTACK_BACK_FrameMove()
{

	CommonFrameMove();
}

void CX2GUEve::ENSI_STANDUP_ATTACK_BACK_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
		{
			StateChange( USI_JUMP_DOWN );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}
		else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
		{
			StateChangeDashIfPossible();
		}
		else
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_STANDUP_ATTACK_BACK_End()
{
	CommonStateEnd();
	SetForceInvincible( 0.3f );
	SetShowInvincible( 0.3f );
}



void CX2GUEve::ENSI_INVISIBILITY_ON_Start()
{
	CommonStateStart();


#ifdef BALANCE_PATCH_20120329
	float fAddMoveSpeedFactor = 0.f;
#endif

	m_fInvisibilityTime = s_fEveDefaultInvisibilityTime;

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	const CX2SkillTree::SkillTemplet*	pSkillTemplet	= GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EN_CLOAKING );
	
	if( NULL != pSkillTemplet )
	{
		int iSkillLevel	= GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_A_EN_CLOAKING );
		m_fInvisibilityTime += pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillLevel );
		fAddMoveSpeedFactor = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MOVE_SPEED, iSkillLevel );
#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
		// 클로킹에 사용되는 MP 소모량, SA 로 변경
		// SA 에서는 마이너스 값으로 적혀있음
		m_fDecraseInvisibilityMP = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_RETAKE_ABS, iSkillLevel );
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
	}
#else //UPGRADE_SKILL_SYSTEM_2013
	int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_EN_CLOAKING_UP );
	if( iSkillLevel > 0 )
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_EN_CLOAKING_UP, iSkillLevel );
	
		if( NULL != pSkillTemplet )
		{
			m_fInvisibilityTime += pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME );
#ifdef BALANCE_PATCH_20120329
			fAddMoveSpeedFactor = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MOVE_SPEED );
#endif
		}
	}
#endif //UPGRADE_SKILL_SYSTEM_2013

#ifdef BALANCE_PATCH_20120329
	SetVecMoveSpeedFactor( 0.75f + fAddMoveSpeedFactor, m_fInvisibilityTime, CX2GameUnit::SFI_SPEED_13, CX2GameUnit::SFST_UPDATE );
#endif


	m_timerInvisibility.restart();
	m_fInvisibilityAlpha	= 1.f;
	m_bInvisibility			= true;
	m_bAbsoluteInvisibility = false;

	SetAlphaObject( true );
	m_RenderParam.bAlphaBlend = true;



	// 각성 상태이면 각성 파티클을 안보이게 한다.
	if( GetRemainHyperModeTime() > 0.f )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq_RFoot = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostRFoot );
		CKTDGParticleSystem::CParticleEventSequence* pSeq_LFoot = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostLFoot );
		CKTDGParticleSystem::CParticleEventSequence* pSeq_RArm = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostRArm );
		CKTDGParticleSystem::CParticleEventSequence* pSeq_LArm = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostLArm );

		if( pSeq_RFoot != NULL )
		{
			pSeq_RFoot->SetShowObject( false );
		}
		if( pSeq_LFoot != NULL )
		{
			pSeq_LFoot->SetShowObject( false );
		}
		if( pSeq_RArm != NULL )
		{
			pSeq_RArm->SetShowObject( false );
		}
		if( pSeq_LArm != NULL )
		{
			pSeq_LArm->SetShowObject( false );
		}
	}

}

void CX2GUEve::ENSI_INVISIBILITY_ON_FrameMove()
{

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_Eve_Sp_Invisible01", vBonePos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}

	float fAlphaBound = CalcInvisibilityAlphaValue();

	if( m_fInvisibilityAlpha > fAlphaBound )		
	{
		m_fInvisibilityAlpha = 1.f - (1.f - fAlphaBound) * m_pXSkinAnim->GetNowAnimationTime() / m_pXSkinAnim->GetMaxAnimationTime();
		if( m_fInvisibilityAlpha < fAlphaBound )
		{
			m_fInvisibilityAlpha = fAlphaBound;
		}
	}

	CommonFrameMove();
}


void CX2GUEve::ENSI_INVISIBILITY_ON_EventProcess()
{
	if( true == m_pXSkinAnimFuture->IsAnimationEnd() )
	{

		StateChange( USI_WAIT );	
	}

	CommonEventProcess();
}


// 투명 상태가 될 때 알파값을 계산해준다, 이 값에 따라 이브가 내 화면에 보일지 안 보일지 결정됨.
float CX2GUEve::CalcInvisibilityAlphaValue()
{
	float fAlphaBound = 0.f;

	if( true == IsMyUnit() )
	{
		fAlphaBound = 0.5f; 
	}
	else if( NULL != g_pX2Game &&
		NULL != g_pX2Game->GetMyUnit() )
	{
		if( g_pX2Game->GetMyUnit()->GetTeam() == GetTeam() )
		{
			fAlphaBound = 0.5f;
		}
#ifndef BALANCE_PATCH_20120329
		else if( CX2Unit::UT_EVE == g_pX2Game->GetMyUnit()->GetUnit()->GetType()
			&& CX2GameUnit::GUSI_DIE != g_pX2Game->GetMyUnit()->GetGameUnitState() )
		{
			fAlphaBound = 0.5f;
		}
#endif
	}

	return fAlphaBound;
}

void CX2GUEve::ENSI_INVISIBILITY_ON_End()
{
	m_fInvisibilityAlpha = CalcInvisibilityAlphaValue();
	m_timerInvisibility.restart();
	m_bInvisibility	= true;

	if( 0.f == m_fInvisibilityAlpha )
	{
		m_bAbsoluteInvisibility = true;
	}
	else
	{
		m_bAbsoluteInvisibility = false;
	}



	if( true == GetAbsoluteInvisibility() )
	{
		//{{ kimhc // 2010.6.16 // 같은 기능을 하는 함수가 존재하여 함수를 사용함
#ifdef	ENCHANT_BUG_TEST
		SetShowEnchantWeaponParticle( false );
#else	ENCHANT_BUG_TEST
		// 무기 속성 인챈트 파티클을 안보이게 한다
		SetShowEnchantedWeaponEffectAtHand( false );
		BOOST_TEST_FOREACH( CX2GameUnit::Weapon*, pWeapon, m_vecpWeapon )
		{
			pWeapon->SetEnchantParticleShow( false );
		}
#endif	ENCHANT_BUG_TEST
		//{{ kimhc // 2010.6.16 // 같은 기능을 하는 함수가 존재하여 함수를 사용함

		// 장비에 부착된 파티클 안보이게
		BOOST_TEST_FOREACH( CX2EqipPtr, pEquip, m_ViewEqipList )
		{
			if( pEquip != NULL )
				pEquip->SetShowAttachedParticle( false );
		}

#ifdef EVE_CLOAKING_ADJUST
		BOOST_FOREACH( Weapon* pWeapon, m_vecpWeapon )
		{
			if( NULL != pWeapon )
			{
				pWeapon->SetShowObject(false);
			}
		}
		if( NULL != m_pUnitShadow )
		{
			m_pUnitShadow->SetShowObject( false );
			D3DXVECTOR3 vecInvisiblityShadow = m_FrameDataNow.syncData.position;
			vecInvisiblityShadow.y += 400;
			m_pUnitShadow->UpdatePosition( vecInvisiblityShadow, m_FrameDataNow.unitCondition.landPosition, m_FrameDataNow.unitCondition.dirDegree );
		}

		SetShowViewList( false );

#endif //EVE_CLOAKING_ADJUST

	}

#ifdef SERV_SKILL_NOTE
	if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO5 ) == true )
	{
#ifdef BALANCE_PATCH_20120329
		ResetMPChangeRate( 3.f );
#else
		ResetMPChangeRate( 10.f );
#endif
	}			
#endif


#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	// 클로킹 상태에서 같은 팀원이 아니라면 생성을 막는다.
	if ( NULL != g_pX2Game->GetMyUnit() )
	{
		if ( true == m_bInvisibility && g_pX2Game->GetMyUnit()->GetTeam() != GetTeam() )
		{
			ClearManeuverCore();
		}
	}
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어

	CommonStateEnd();
}

void CX2GUEve::ENSI_COMBO_Z_Start()
{
	CommonStateStart();

	// To do..
#ifdef EVE_FIRST_CHANGE_JOB
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] = INVALID_MESH_INSTANCE_HANDLE;
#endif
}

void CX2GUEve::ENSI_COMBO_Z_End()
{
	// To do..
#ifdef EVE_FIRST_CHANGE_JOB
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] = INVALID_MESH_INSTANCE_HANDLE;
#endif

	CommonStateEnd();
}

void CX2GUEve::ENSI_COMBO_Z_FrameMove()
{
	//if( m_pXSkinAnim->EventTimer( 0.25f ) == true && EventCheck( 0.25f, false ) == true )
	//{
	//	m_DamageData.hitUnitList.resize(0);
	//}

#ifdef EVE_FIRST_CHANGE_JOB
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		/*GetUnit()->GetClass() == CX2Unit::UC_EVE_EXOTIC_GEAR &&*/ m_sEGQueensThrone.m_bEnable == true )
	{
		D3DXVECTOR3 vPos = GetPos();
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_COMBO_Z1", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] = pEffect->GetMainEffectHandle();
		}
	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetPos();
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
#endif EVE_FIRST_CHANGE_JOB

	CommonFrameMove();
}



void CX2GUEve::ENSI_COMBO_Z_EventProcess()
{
#ifdef EVE_ELECTRA
	CancelComboWhenChangedDirection(1);

	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	ELSE_IF_STATE_CHANGE_ON_EX_( 0, m_fEventTime[0].keyInputStart, m_fEventTime[0].keyInputEnd, m_fEventTime[0].stateChange, m_InputData.oneZ == true, ENSI_COMBO_ZZ )
		SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
		if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{	
			//m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}

		CommonEventProcess();


#else
	CancelComboWhenChangedDirection(1);



	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( SpecialAttackEventProcess() == true )
	{
	}
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.266f )
	{
		StateChange( ENSI_COMBO_ZZ );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	}
	else if( m_InputData.oneZ == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.266f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}
	//	else if( m_InputData.pureUp == true		|| m_InputData.pureDown == true 
	//		|| m_InputData.pureRight == true	|| m_InputData.pureLeft == true
	//#ifndef SKILL_SHORT_CUT_KEY_TEST
	//		|| m_InputData.pureC == true
	//#endif //SKILL_SHORT_CUT_KEY_TEST
	//		)
	//	{
	//		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.5f )
	//		{
	//			m_fCanNotAttackTime = 0.1f;
	//			StateChange( ENSI_WAIT );
	//		}
	//	}


	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		//m_fCanNotAttackTime = 0.1f;
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
#endif EVE_ELECTRA
}

//ENSI_COMBO_ZZ
void CX2GUEve::ENSI_COMBO_ZZ_Start()
{
	CommonStateStart();

	// To do..
#ifdef EVE_FIRST_CHANGE_JOB
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] = INVALID_MESH_INSTANCE_HANDLE;
#endif
}

void CX2GUEve::ENSI_COMBO_ZZ_End()
{
	// To do..
#ifdef EVE_FIRST_CHANGE_JOB
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] = INVALID_MESH_INSTANCE_HANDLE;
#endif

	CommonStateEnd();
}

void CX2GUEve::ENSI_COMBO_ZZ_FrameMove()
{
#ifdef EVE_FIRST_CHANGE_JOB
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		/*GetUnit()->GetClass() == CX2Unit::UC_EVE_EXOTIC_GEAR &&*/ m_sEGQueensThrone.m_bEnable == true )
	{
		D3DXVECTOR3 vPos = GetPos();
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_COMBO_Z2", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z2] = pEffect->GetMainEffectHandle();
		}
	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z2] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z2] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetPos();
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z2] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
#endif EVE_FIRST_CHANGE_JOB

	CommonFrameMove();
}

void CX2GUEve::ENSI_COMBO_ZZ_EventProcess()
{
#ifdef EVE_ELECTRA
	CancelComboWhenChangedDirection(1);

	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	ELSE_IF_STATE_CHANGE_ON_EX_( 0, m_fEventTime[0].keyInputStart, m_fEventTime[0].keyInputEnd, m_fEventTime[0].stateChange, m_InputData.oneZ == true, ENSI_COMBO_ZZZ )
		SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
		if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{	
			//m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}

		CommonEventProcess();


#else
	CancelComboWhenChangedDirection(1);

	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	//else if( m_InputData.pureDoubleRight == true || m_InputData.pureDoubleLeft == true )
	//{
	//	if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.7f )
	//	{
	//		StateChangeDashIfPossible();
	//	}
	//}
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.333f )
	{
		StateChange( ENSI_COMBO_ZZZ );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
		//m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
	}
	//else if( m_FrameDataFuture.stateParam.bEventFlagList[1] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.53f )
	//{
	//	StateChange( ENSI_COMBO_ZZX );
	//	m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	//	m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
	//}
	else if( m_InputData.oneZ == true && m_pXSkinAnimFuture->GetNowAnimationTime() <= 0.333f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
		//m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
	}
	//else if( m_InputData.oneX == true && m_pXSkinAnimFuture->GetNowAnimationTime() <= 0.5f )
	//{
	//	m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	//	m_FrameDataFuture.stateParam.bEventFlagList[1] = true;
	//}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_C
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.65f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}




	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		//m_fCanNotAttackTime = 0.1f;
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
#endif EVE_ELECTRA
}

// ENSI_COMBO_ZZZ
void CX2GUEve::ENSI_COMBO_ZZZ_Start()
{
	CommonStateStart();

	// To do..
#ifdef EVE_FIRST_CHANGE_JOB
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] = INVALID_MESH_INSTANCE_HANDLE;
#endif
}

void CX2GUEve::ENSI_COMBO_ZZZ_End()
{
	// To do..
#ifdef EVE_FIRST_CHANGE_JOB
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] = INVALID_MESH_INSTANCE_HANDLE;
#endif

	CommonStateEnd();
}

void CX2GUEve::ENSI_COMBO_ZZZ_FrameMove()
{
#ifdef EVE_FIRST_CHANGE_JOB
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		/*GetUnit()->GetClass() == CX2Unit::UC_EVE_EXOTIC_GEAR &&*/ m_sEGQueensThrone.m_bEnable == true )
	{
		D3DXVECTOR3 vPos = GetPos();
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_COMBO_Z3", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z3] = pEffect->GetMainEffectHandle();
		}
	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z3] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z3] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetPos();
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z3] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
#endif EVE_FIRST_CHANGE_JOB

	CommonFrameMove();
}

void CX2GUEve::ENSI_COMBO_ZZZ_EventProcess()
{
#ifdef EVE_ELECTRA
	m_bReAttackZ1Right = m_FrameDataFuture.syncData.bIsRight;
	m_fReAttackZ1Time = 0.2f;

	CancelComboWhenChangedDirection(4);

	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	ELSE_IF_STATE_CHANGE_ON_EX_( 2, m_fEventTime[2].keyInputStart, m_fEventTime[2].keyInputEnd, m_fEventTime[2].stateChange, (m_InputData.oneZ == true && m_InputData.pureDown == true), ENSI_COMBO_ZZZdownZ )
#ifdef SERV_EVE_BATTLE_SERAPH
		ELSE_IF_STATE_CHANGE_ON_EX_( 3, m_fEventTime[3].keyInputStart, m_fEventTime[3].keyInputEnd, m_fEventTime[3].stateChange, m_InputData.oneZ == true && 
		( GetUnit()->GetClass() == CX2Unit::UC_EVE_ELECTRA || GetUnit()->GetClass() == CX2Unit::UC_EVE_BATTLE_SERAPH ) &&
		( ( m_InputData.pureRight == true && m_FrameDataFuture.syncData.bIsRight == true ) || 
		( m_InputData.pureLeft == true && m_FrameDataFuture.syncData.bIsRight == false ) ), ENSI_EPR_COMBO_ZZZfrontZ )
#else
		ELSE_IF_STATE_CHANGE_ON_EX_( 3, m_fEventTime[3].keyInputStart, m_fEventTime[3].keyInputEnd, m_fEventTime[3].stateChange, m_InputData.oneZ == true && GetUnit()->GetClass() == CX2Unit::UC_EVE_ELECTRA &&
		( ( m_InputData.pureRight == true && m_FrameDataFuture.syncData.bIsRight == true ) || 
		( m_InputData.pureLeft == true && m_FrameDataFuture.syncData.bIsRight == false ) ), ENSI_EPR_COMBO_ZZZfrontZ )
#endif
		ELSE_IF_STATE_CHANGE_ON_EX_( 0, m_fEventTime[0].keyInputStart, m_fEventTime[0].keyInputEnd, m_fEventTime[0].stateChange, m_InputData.oneZ == true, ENSI_COMBO_ZZZZ )
		ELSE_IF_STATE_CHANGE_ON_EX_( 1, m_fEventTime[1].keyInputStart, m_fEventTime[1].keyInputEnd, m_fEventTime[1].stateChange, m_InputData.oneX == true, ENSI_COMBO_ZZZX )
		SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
		if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{	
			//m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
#ifdef FIX_EVE_ZZZ_COMBO_SKILL_SLOT_CHANGE
		CommonEventProcess();
#endif //FIX_EVE_ZZZ_COMBO_SKILL_SLOT_CHANGE
#else
	m_bReAttackZ1Right = m_FrameDataFuture.syncData.bIsRight;
	m_fReAttackZ1Time = 0.2f;

#ifdef EVE_ELECTRA
	CancelComboWhenChangedDirection(4);
#else
	CancelComboWhenChangedDirection(3);
#endif EVE_ELECTRA


	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.pureDoubleRight == true || m_InputData.pureDoubleLeft == true )
	{
		StateChangeDashIfPossible();
	}
	else if( SpecialAttackEventProcess() == true )
	{
	}
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.667f )
	{
		StateChange( ENSI_COMBO_ZZZZ );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
	}
	else if( m_FrameDataFuture.stateParam.bEventFlagList[1] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.667f )
	{
		StateChange( ENSI_COMBO_ZZZX );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
	}
	else if( m_FrameDataFuture.stateParam.bEventFlagList[2] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.667f )
	{
		StateChange( ENSI_COMBO_ZZZdownZ );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
	}
#ifdef EVE_ELECTRA
	else if( m_FrameDataFuture.stateParam.bEventFlagList[3] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.667f )
	{
		StateChange( ENSI_EPR_COMBO_ZZZfrontZ );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
	}
#endif EVE_ELECTRA
	//else if( CX2Unit::UC_RAVEN_SOUL_TAKER == GetUnit()->GetUnitData().m_UnitClass &&
	//	m_FrameDataFuture.stateParam.bEventFlagList[2] == true && 
	//	m_pXSkinAnimFuture->GetNowAnimationTime() > 0.5f )
	//{
	//	StateChange( ENSI_SOUL_TAKER_COMBO_ZZZupZ );
	//	m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	//	m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
	//	m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
	//}
	//else if( CX2Unit::UC_RAVEN_SOUL_TAKER == GetUnit()->GetUnitData().m_UnitClass &&
	//	m_InputData.oneZ == true && m_InputData.pureUp == true && 
	//	m_pXSkinAnimFuture->GetNowAnimationTime() < 0.65f )
	//{
	//	m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	//	m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
	//	m_FrameDataFuture.stateParam.bEventFlagList[2] = true;
	//}
	else if( m_InputData.oneZ == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.667f )
	{
		if( m_InputData.pureDown == true )
		{
			m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
			m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
			m_FrameDataFuture.stateParam.bEventFlagList[2] = true;
			m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
		}
#ifdef EVE_ELECTRA
		else if( CX2Unit::UC_EVE_ELECTRA == GetUnit()->GetUnitData().m_UnitClass )
		{
			m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
			m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
			m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
			m_FrameDataFuture.stateParam.bEventFlagList[3] = true;
		}
#endif EVE_ELECTRA
		else 
		{
			m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
			m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
			m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
			m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
		}
	}
	else if( m_InputData.oneX == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.667f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[1] = true;
		m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
	}
	else if( m_InputData.pureUp == true || m_InputData.pureDown == true		
		|| m_InputData.pureRight == true || m_InputData.pureLeft == true )
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.7f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}



	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		//m_fCanNotAttackTime = 0.1f;
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
#endif EVE_ELECTRA
}





//// ENSI_COMBO_ZZZZ
//void CX2GUEve::ENSI_COMBO_ZZZZ_FrameMoveFuture()
//{
//	if( m_pXSkinAnimFuture->EventTimer( 0.6f ) == true && EventCheck( 0.6f, false ) == true )
//	{
//		m_PhysicParam.nowSpeed.x = GetWalkSpeed() * 1.3f;
//	}
//
//	CommonFrameMoveFuture();
//}

void CX2GUEve::ENSI_COMBO_ZZZZ_Start()
{
	CommonStateStart();

	// To do..
#ifdef EVE_FIRST_CHANGE_JOB
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] = INVALID_MESH_INSTANCE_HANDLE;
#endif EVE_FIRST_CHANGE_JOB
}

void CX2GUEve::ENSI_COMBO_ZZZZ_End()
{
	// To do..
#ifdef EVE_FIRST_CHANGE_JOB
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z1] = INVALID_MESH_INSTANCE_HANDLE;
#endif EVE_FIRST_CHANGE_JOB

	CommonStateEnd();
}

void CX2GUEve::ENSI_COMBO_ZZZZ_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.5f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.5f ) == true && EventCheck( 0.5f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_DamageData.bReAttack		= false;
	}

#ifdef EVE_FIRST_CHANGE_JOB
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		/*GetUnit()->GetClass() == CX2Unit::UC_EVE_EXOTIC_GEAR &&*/ m_sEGQueensThrone.m_bEnable == true )
	{
		D3DXVECTOR3 vPos = GetBonePos(L"Dummy2_Lhand");
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_COMBO_Z4_01", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z4_01] = pEffect->GetMainEffectHandle();
		}

		vPos = GetBonePos(L"Dummy1_Rhand");
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_COMBO_Z4_02", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z4_02] = pEffect->GetMainEffectHandle();
		}
	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z4_01] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z4_01] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetBonePos(L"Dummy2_Lhand");
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z4_01] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z4_02] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z4_02] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetBonePos(L"Dummy1_Rhand");
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Combo_Z4_02] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
#endif EVE_FIRST_CHANGE_JOB

	CommonFrameMove();
}


void CX2GUEve::ENSI_COMBO_ZZZZ_EventProcess()
{
#ifdef EVE_ELECTRA
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER_CANNOT_ATTACKTIME( m_fWalkCancelAfter, 0.1f )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
		if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{	
			StateChange( USI_WAIT );
		}

		CommonEventProcess();


#else
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.85f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
#endif EVE_ELECTRA
}


void CX2GUEve::ENSI_COMBO_ZZZX_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger01" );
		D3DXVECTOR2 projPos = g_pKTDXApp->GetProj3DPos( vBonePos );
		g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"STR_ChalSSak", projPos.x, projPos.y, 0.f );

		//PlaySound( L"Eve_CheekSlap.ogg" );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_COMBO_ZZZX_EventProcess()
{
#ifdef EVE_ELECTRA
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER_CANNOT_ATTACKTIME( m_fWalkCancelAfter, 0.1f )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
		if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{	
			StateChange( USI_WAIT );
		}

		CommonEventProcess();

#else
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.pureUp == true || m_InputData.pureDown == true 
		|| m_InputData.pureRight == true || m_InputData.pureLeft == true )
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.85f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}


	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
#endif EVE_ELECTRA
}

//ENSI_COMBO_ZZZdownZ
void CX2GUEve::ENSI_COMBO_ZZZdownZ_StartFuture()
{
	CommonStateStartFuture();

	//{{ 09.01.21.hoons.
#ifdef EVE_FIRST_CHANGE_JOB
	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
			m_pXSkinAnimFuture->ChangeAnim( L"EG_ComboZ4Down", false );
			m_pXSkinAnimFuture->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;
	}
#endif EVE_FIRST_CHANGE_JOB
	//}} hoons
}

void CX2GUEve::ENSI_COMBO_ZZZdownZ_Start()
{
	CommonStateStart();

	m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ]		= INVALID_MESH_INSTANCE_HANDLE;

	//{{ 09.01.21.hoons.
#ifdef EVE_FIRST_CHANGE_JOB
	m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ_EG]	= INVALID_MESH_INSTANCE_HANDLE;

	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
			m_pXSkinAnim->ChangeAnim( L"EG_ComboZ4Down", false );
			m_pXSkinAnim->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;
	}
#endif EVE_FIRST_CHANGE_JOB
	//}} hoons
}


void CX2GUEve::ENSI_COMBO_ZZZdownZ_End()
{
	// 09.01.21.hoons. 전직이후에만 다음연계 콤보로 넘어갈수있기때문에
#ifdef EVE_FIRST_CHANGE_JOB
	m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ]		= INVALID_MESH_INSTANCE_HANDLE;
	m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ_EG]	= INVALID_MESH_INSTANCE_HANDLE;
#endif EVE_FIRST_CHANGE_JOB

	CommonStateEnd();
}




void CX2GUEve::ENSI_COMBO_ZZZdownZ_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.33f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.33f ) == true && EventCheck( 0.33f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//{{ 09.01.20.hoons.
#ifdef EVE_FIRST_CHANGE_JOB
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_EXOTIC_GEAR:
		case CX2Unit::UC_EVE_CODE_NEMESIS:
			{
				//앞쪽
				D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );


				CKTDGParticleSystem::CParticleEventSequence* pSeq = 
					g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_ComboZ5Down_Particle01", vBonePos );
				if( NULL != pSeq )
				{
					pSeq->SetAddRotate( GetRotateDegree() );
					pSeq->SetAxisAngle( GetRotateDegree() );
					pSeq->SetLandPosition( GetLandPosition().y );
				}

				CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_ZZZdownZ", GetPowerRate(), 
					vBonePos, GetRotateDegree(), GetRotateDegree() );

				if( NULL != pEffect )
				{
					m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ] = pEffect->GetMainEffectHandle();
				}

				UpDownCrashCameraNoReset( 5.f, 0.15f );

				//뒤쪽
				vBonePos = GetBonePos( L"Dummy2_Lhand" );

				D3DXVECTOR3 vAngle = GetRotateDegree();
				vAngle.y += 180.f;

				pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_ComboZ5Down_Particle01", vBonePos );
				if( NULL != pSeq )
				{
					pSeq->SetAddRotate( vAngle );
					pSeq->SetAxisAngle( vAngle );
					pSeq->SetLandPosition( GetLandPosition().y );
				}

				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_ZZZdownZ", GetPowerRate(), vBonePos, vAngle, vAngle );

				if( NULL != pEffect )
				{
					m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ_EG] = pEffect->GetMainEffectHandle();
				}
			}
			break;

		default:
			{
				D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );


				CKTDGParticleSystem::CParticleEventSequence* pSeq = 
					g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_ComboZ5Down_Particle01", vBonePos );
				if( NULL != pSeq )
				{
					pSeq->SetAddRotate( GetRotateDegree() );
					pSeq->SetAxisAngle( GetRotateDegree() );
					pSeq->SetLandPosition( GetLandPosition().y );
				}

				CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_ZZZdownZ", GetPowerRate(), 
					vBonePos, GetRotateDegree(), GetRotateDegree() );

				if( NULL != pEffect )
				{
					m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ] = pEffect->GetMainEffectHandle();
				}

				UpDownCrashCameraNoReset( 5.f, 0.15f );
			}
			break;
		}
#endif EVE_FIRST_CHANGE_JOB
		//}} hoons.
	}


	//{{ 09.01.20.hoons.
#ifdef EVE_FIRST_CHANGE_JOB
	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
			if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.33f && 
				INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ_EG] )
			{
				CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ_EG] );
				if( NULL != pMeshInst )
				{
					D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
					pMeshInst->SetPos( vBonePos );
				}
				else
				{
					m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ_EG] = INVALID_MESH_INSTANCE_HANDLE;
				}
			}
		}
		break;

	default:
		{
			if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.33f && 
				INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ] )
			{
				CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ] );
				if( NULL != pMeshInst )
				{
					D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );
					pMeshInst->SetPos( vBonePos );
				}
				else
				{
					m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ] = INVALID_MESH_INSTANCE_HANDLE;
				}
			}
		}
		break;
	}
#endif EVE_FIRST_CHANGE_JOB
	//}} hoons.

	CommonFrameMove();
}


void CX2GUEve::ENSI_COMBO_ZZZdownZ_EventProcess()
{
	CancelComboWhenChangedDirection(1);


	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
#ifdef SKILL_CANCEL_BY_HYPER_MODE // 김태환
	SKILL_CANCEL_AFTER( 0.01f )
#else // SKILL_CANCEL_BY_HYPER_MODE
	else if( SpecialAttackEventProcess() == true )
	{
	}
#endif //SKILL_CANCEL_BY_HYPER_MODE
	//{{ 09.01.21.hoons.
#ifdef EVE_FIRST_CHANGE_JOB
	// ZZZdownZ콤보로 연결되는 부분 일단 막음
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.53f )
	{
		StateChange( ENSI_COMBO_ZZZdownZZ );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	}
	else if( m_InputData.oneZ == true && m_InputData.pureDown == true &&
		m_pXSkinAnimFuture->GetNowAnimationTime() < 0.53f )
	{
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_EXOTIC_GEAR:
		case CX2Unit::UC_EVE_ARCHITECTURE:
		case CX2Unit::UC_EVE_CODE_NEMESIS:
		case CX2Unit::UC_EVE_CODE_EMPRESS:
			m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
			break;
		}
	}
#endif EVE_FIRST_CHANGE_JOB
	//}}
	else if( m_InputData.pureUp == true || m_InputData.pureDown == true 
		|| m_InputData.pureRight == true || m_InputData.pureLeft == true )
	{
		float fSkipTime = 0.55f;
		//if( GetUnit()->GetClass() == CX2Unit::UC_EVE_EXOTIC_GEAR )
		//	fSkipTime = 0.55f;

		if( m_pXSkinAnimFuture->GetNowAnimationTime() > fSkipTime )
		{
			StateChange( USI_WAIT );
		}
	}

	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

//ENSI_COMBO_ZZZdwonZZ

void CX2GUEve::ENSI_COMBO_ZZZdownZZ_Init()
{
	switch ( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_ARCHITECTURE:
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		XSkinMeshReadyInBackground( L"Eve_AT_ComboZ5a_Mesh.X" );
		break;
	}
}

void CX2GUEve::ENSI_COMBO_ZZZdownZZ_StartFuture()
{
	CommonStateStartFuture();

#ifdef EVE_FIRST_CHANGE_JOB
	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
			m_pXSkinAnimFuture->ChangeAnim( L"EG_ComboZ5Down", false );
			m_pXSkinAnimFuture->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;
	case CX2Unit::UC_EVE_ARCHITECTURE:
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
			m_pXSkinAnimFuture->ChangeAnim( L"AT_ComboZ5a", false );
			m_pXSkinAnimFuture->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;
	}
#endif EVE_FIRST_CHANGE_JOB
}

void CX2GUEve::ENSI_COMBO_ZZZdownZZ_Start()
{
	CommonStateStart();

#ifdef EVE_FIRST_CHANGE_JOB
	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
			m_pXSkinAnim->ChangeAnim( L"EG_ComboZ5Down", false );
			m_pXSkinAnim->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;
	case CX2Unit::UC_EVE_ARCHITECTURE:
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
			m_pXSkinAnim->ChangeAnim( L"AT_ComboZ5a", false );
			m_pXSkinAnim->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;
	}
#endif EVE_FIRST_CHANGE_JOB
}

void CX2GUEve::ENSI_COMBO_ZZZdownZZ_End()
{
	m_ahMajorMeshInstance[MajorMID_ComboZZZdownZ] = INVALID_MESH_INSTANCE_HANDLE;

	CommonStateEnd();
}

void CX2GUEve::ENSI_COMBO_ZZZdownZZ_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_ARCHITECTURE:
		case CX2Unit::UC_EVE_CODE_EMPRESS:
			{
				D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Footsteps" );

				g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_COMBO_ZZZdownZZ", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
			}
			break;

		case CX2Unit::UC_EVE_EXOTIC_GEAR:
		case CX2Unit::UC_EVE_CODE_NEMESIS:
			{
				//캐릭터 앞쪽
				D3DXVECTOR3 vBonePos	= GetBonePos( L"Dummy1_Rhand" );
				D3DXVECTOR3 vAngle		= GetRotateDegree();
				--vAngle.z += -30.f;

				CKTDGParticleSystem::CParticleEventSequence* pSeq = 
					g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_ComboZ5Down_Particle01", vBonePos );
				if( NULL != pSeq )
				{
					pSeq->SetAddRotate( vAngle );
					pSeq->SetAxisAngle( vAngle );
					pSeq->SetLandPosition( GetLandPosition().y );
				}

				g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_ZZZdownZZ", GetPowerRate(), vBonePos, vAngle, vAngle );

				UpDownCrashCameraNoReset( 5.f, 0.15f );

				//캐릭터 뒤쪽.
				vBonePos = GetBonePos( L"Dummy2_Lhand" );

				vAngle = GetRotateDegree();
				vAngle.y += 180.f;
				vAngle.z += -30.f;

				pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_ComboZ5Down_Particle01", vBonePos );
				if( NULL != pSeq )
				{
					pSeq->SetAddRotate( vAngle );
					pSeq->SetAxisAngle( vAngle );
					pSeq->SetLandPosition( GetLandPosition().y );
				}

				g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_ZZZdownZZ", GetPowerRate(), vBonePos, vAngle, vAngle );
			}
			break;
		}
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_COMBO_ZZZdownZZ_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.pureUp == true || m_InputData.pureDown == true 
		|| m_InputData.pureRight == true || m_InputData.pureLeft == true )
	{
		float fSkipTime = 0.7f;
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_ARCHITECTURE:
		case CX2Unit::UC_EVE_EXOTIC_GEAR:
		case CX2Unit::UC_EVE_CODE_NEMESIS:
		case CX2Unit::UC_EVE_CODE_EMPRESS:
			fSkipTime = 0.45f; // 1/3 감소
			break;
		}

		if( m_pXSkinAnimFuture->GetNowAnimationTime() > fSkipTime )
		{
			StateChange( USI_WAIT );
		}
	}
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
}



void CX2GUEve::ENSI_COMBO_X_FrameMove()
{

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
#ifdef EVE_ELECTRA
		if( FlushMp( 8.f * m_fMPConsumeRateElectronBall ) == true ) 
#else
		if( FlushMp( 15.f * m_fMPConsumeRateElectronBall ) == true ) 
#endif EVE_ELECTRA
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
			D3DXVECTOR3 vPos = GetPos();

			if( true == GetIsRight() )
			{
				vPos += GetDirVector() * 100.f;
			}
			else
			{
				vPos -= GetDirVector() * 100.f;
			}
			vPos.y += 120.f;

			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_ComboX1_FireImpact01", vPos );
#ifdef INHERIT_FORCEDOWNRATE
			CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_X_FIRE_BALL", GetPowerRate() * m_fAttackPowerRateElectronBall, 
				vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate );

			if( NULL != pEffect )
				pEffect->SetInheritForceDownRate(true);

#ifdef EVE_ELECTRA
			if( NULL != pEffect )
#ifdef SERV_EVE_BATTLE_SERAPH
				m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_COMBO_X_FIRE_BALL_AMPLIFY_FILTERED", 
				L"EVE_COMBO_X_FIRE_BALL_SPECTRUM_FILTERED", L"EVE_COMBO_X_FIRE_BALL_INDUCTION_FILTERED",
				L"EVE_COMBO_X_FIRE_BALL_FUSION_FILTERED" );
#else
				m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_COMBO_X_FIRE_BALL_FILTERED", L"EVE_COMBO_X_FIRE_BALL_FILTERED" );
#endif
#endif EVE_ELECTRA



#else
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_X_FIRE_BALL", GetPowerRate() * m_fAttackPowerRateElectronBall, 
				vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate );
#endif INHERIT_FORCEDOWNRATE

#ifdef EVE_ELECTRA
			PlaySound( L"Eve_FireShot1.ogg" );
#endif EVE_ELECTRA
		}
		else
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
			CreateNotEnoughMPEffect( vBonePos, 0.f, 0.f, 0.f );
		}
	}
#ifdef EVE_ELECTRA
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.02f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.02f ) == true && EventCheck( 0.02f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( 0, 1.1f, 280.f, 130.f, L"EveProtoPurityXXZPlane" );
	}
#endif EVE_ELECTRA


	CommonFrameMove();
}



void CX2GUEve::ENSI_COMBO_X_EventProcess()
{
#ifdef EVE_ELECTRA
	CancelComboWhenChangedDirection( 2 );

	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	ELSE_IF_STATE_CHANGE_ON_EX_( 0, m_fEventTime[0].keyInputStart, m_fEventTime[0].keyInputEnd, m_fEventTime[0].stateChange, m_InputData.oneX == true, ENSI_COMBO_XX )
		SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER_CANNOT_ATTACKTIME( m_fWalkCancelAfter, 0.2f )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
		if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{	
			StateChange( USI_WAIT );
		}

		CommonEventProcess();

#else
	CancelComboWhenChangedDirection( 2 );


	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( SpecialAttackEventProcess() == true )
	{
	}
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.47f )
	{
		StateChange( ENSI_COMBO_XX );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	}
	else if( m_InputData.oneX == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.47f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}
	else if( m_InputData.pureUp == true || m_InputData.pureDown == true 
		|| m_InputData.pureRight == true || m_InputData.pureLeft == true )
	{
#ifdef EVE_ELECTRA
		if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.4f )
		{
			if( m_InputData.pureUp == true )
			{
				m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
			}
			else if( m_InputData.pureDown == true )
			{
				m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
			}
		}
#endif EVE_ELECTRA


		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.75f )
		{
			m_fCanNotAttackTime = 0.2f;
			StateChange( USI_WAIT );
		}
	}


	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( USI_WAIT );
	}
	CommonEventProcess();
#endif EVE_ELECTRA
}


void CX2GUEve::ENSI_COMBO_XX_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );

#ifdef EVE_ELECTRA
		if( FlushMp( 8.f * m_fMPConsumeRateElectronBall ) == true ) 
#else
		if( FlushMp( 15.f * m_fMPConsumeRateElectronBall ) == true ) 
#endif EVE_ELECTRA
		{

#ifdef INHERIT_FORCEDOWNRATE
			CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_X_FIRE_BALL", GetPowerRate() * m_fAttackPowerRateElectronBall, 
				vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate );

			if( NULL != pEffect )
				pEffect->SetInheritForceDownRate(true);

#ifdef EVE_ELECTRA
			if( NULL != pEffect )
#ifdef SERV_EVE_BATTLE_SERAPH
				m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_COMBO_X_FIRE_BALL_AMPLIFY_FILTERED", 
				L"EVE_COMBO_X_FIRE_BALL_SPECTRUM_FILTERED", L"EVE_COMBO_X_FIRE_BALL_INDUCTION_FILTERED",
				L"EVE_COMBO_X_FIRE_BALL_FUSION_FILTERED" );
#else
				m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_COMBO_X_FIRE_BALL_FILTERED", L"EVE_COMBO_X_FIRE_BALL_FILTERED" );
#endif
#endif EVE_ELECTRA
#else

			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_X_FIRE_BALL", GetPowerRate() * m_fAttackPowerRateElectronBall, 
				vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate );
#endif INHERIT_FORCEDOWNRATE
#ifdef EVE_ELECTRA
			PlaySound( L"Eve_FireShot1.ogg" );
#endif EVE_ELECTRA
		}
		else
		{
			CreateNotEnoughMPEffect( vBonePos, 0.f, 0.f, 0.f );
		}

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 100.f;
		}
		else
		{
			vPos -= GetDirVector() * 100.f;
		}
		vPos.y += 120.f;

		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_ComboX1_FireImpact01", vPos );
	}

	CommonFrameMove();
}



void CX2GUEve::ENSI_COMBO_XX_EventProcess()
{
#ifdef EVE_ELECTRA
	CancelComboWhenChangedDirection( 6 );

	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if ( m_FrameDataFuture.stateParam.bEventFlagList[5] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.55f )
	{
		m_iSuccessiveHit_OneZ = 0;
		StateChange( ENSI_NS_COMBO_XXZ );
		m_FrameDataFuture.stateParam.bEventFlagList[5] = false;
	}
	else if ( m_InputData.oneZ == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.55f 
		&& GetUnit()->GetClass() == CX2Unit::UC_EVE_CODE_NEMESIS )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[5] = true;
	}
	ELSE_IF_STATE_CHANGE_ON_EX_( 4, m_fEventTime[4].keyInputStart, m_fEventTime[4].keyInputEnd, m_fEventTime[4].stateChange, m_InputData.oneX == true && m_InputData.pureDown == true && GetUnit()->GetClass() == CX2Unit::UC_EVE_CODE_EMPRESS, ENSI_EP_COMBO_XXdownX )
		ELSE_IF_STATE_CHANGE_ON_EX_( 2, m_fEventTime[2].keyInputStart, m_fEventTime[2].keyInputEnd, m_fEventTime[2].stateChange, m_InputData.oneX == true && m_InputData.pureDown == true, ENSI_COMBO_XXdownX )
		ELSE_IF_STATE_CHANGE_ON_EX_( 1, m_fEventTime[1].keyInputStart, m_fEventTime[1].keyInputEnd, m_fEventTime[1].stateChange, m_InputData.oneX == true &&
		( ( m_InputData.pureRight == true && m_FrameDataFuture.syncData.bIsRight == true ) || 
		( m_InputData.pureLeft == true && m_FrameDataFuture.syncData.bIsRight == false ) ), ENSI_COMBO_XXfrontX )
		ELSE_IF_STATE_CHANGE_ON_EX_( 0, m_fEventTime[0].keyInputStart, m_fEventTime[0].keyInputEnd, m_fEventTime[0].stateChange, m_InputData.oneX == true, ENSI_COMBO_XXX )
		ELSE_IF_STATE_CHANGE_ON_EX_( 3, m_fEventTime[3].keyInputStart, m_fEventTime[3].keyInputEnd, m_fEventTime[3].stateChange, m_InputData.oneZ == true && 
		(GetUnit()->GetClass() == CX2Unit::UC_EVE_CODE_EMPRESS || GetUnit()->GetClass() == CX2Unit::UC_EVE_ARCHITECTURE), ENSI_COMBO_XXZ4 )
#ifdef SERV_EVE_BATTLE_SERAPH
		ELSE_IF_STATE_CHANGE_ON_EX_( 6, m_fEventTime[5].keyInputStart, m_fEventTime[5].keyInputEnd, m_fEventTime[5].stateChange, m_InputData.oneZ == true && 
		( GetUnit()->GetClass() == CX2Unit::UC_EVE_ELECTRA || GetUnit()->GetClass() == CX2Unit::UC_EVE_BATTLE_SERAPH ), ENSI_EPR_COMBO_XXZ )
#else
		ELSE_IF_STATE_CHANGE_ON_EX_( 6, m_fEventTime[5].keyInputStart, m_fEventTime[5].keyInputEnd, m_fEventTime[5].stateChange, m_InputData.oneZ == true && 
		GetUnit()->GetClass() == CX2Unit::UC_EVE_ELECTRA, ENSI_EPR_COMBO_XXZ )
#endif
		SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER_CANNOT_ATTACKTIME( m_fWalkCancelAfter, 0.1f )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
		if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{	
			StateChange( USI_WAIT );
		}

		CommonEventProcess();
#else
	CancelComboWhenChangedDirection( 4 ); // oasis 3->4


	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( SpecialAttackEventProcess() == true )
	{
	}
	//{{ kimhc // 2010.1.26 // 이브 2차 전직 콤보
#ifdef	EVE_SECOND_CLASS_CHANGE
	else if ( m_FrameDataFuture.stateParam.bEventFlagList[5] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.55f )
	{
		m_iSuccessiveHit_OneZ = 0;
		StateChange( ENSI_NS_COMBO_XXZ );
		m_FrameDataFuture.stateParam.bEventFlagList[5] = false;
	}
#endif	EVE_SECOND_CLASS_CHANGE
	//}} kimhc // 2010.1.26 // 이브 2차 전직 콤보
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.55f )
	{
		StateChange( ENSI_COMBO_XXX );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
	}
	else if( m_FrameDataFuture.stateParam.bEventFlagList[1] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.55f )
	{
		StateChange( ENSI_COMBO_XXfrontX );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
	}
	else if( m_FrameDataFuture.stateParam.bEventFlagList[2] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.55f )
	{
		StateChange( ENSI_COMBO_XXdownX );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
	}
#ifdef EVE_FIRST_CHANGE_JOB
	else if( m_FrameDataFuture.stateParam.bEventFlagList[3] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.6f )
	{
		m_iSuccessiveHit_OneZ = 0;
		StateChange( ENSI_COMBO_XXZ4 );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
		m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
	}
#endif EVE_FIRST_CHANGE_JOB
#ifdef EVE_SECOND_CLASS_CHANGE
	// oasis907 : 김상윤 [2010.1.27] // 
	else if( m_FrameDataFuture.stateParam.bEventFlagList[4] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.6f )
	{
		StateChange( ENSI_EP_COMBO_XXdownX );
		m_FrameDataFuture.stateParam.bEventFlagList[4] = false;
	}
	//{{ kimhc // 2010.1.26 // 이브 2차 전직 콤보
	else if ( m_InputData.oneZ == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.55f 
		&& GetUnit()->GetClass() == CX2Unit::UC_EVE_CODE_NEMESIS )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[5] = true;
	}
	//}} kimhc // 2010.1.26 // 이브 2차 전직 콤보
#endif EVE_SECOND_CLASS_CHANGE

#ifdef EVE_ELECTRA
	else if( m_FrameDataFuture.stateParam.bEventFlagList[6] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.6f )
	{
		StateChange( ENSI_EPR_COMBO_XXZ );
		m_FrameDataFuture.stateParam.bEventFlagList[6] = false;
	}
#endif EVE_ELECTRA
	else if( m_InputData.oneX == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.55f )
	{
		if( m_InputData.pureDown == true )
		{
			// oasis907 : 김상윤 [2010.1.27] // 
			switch( GetUnit()->GetClass() )
			{
			case CX2Unit::UC_EVE_CODE_EMPRESS:
				m_FrameDataFuture.stateParam.bEventFlagList[4] = true;
				break;
			default:
				m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
				m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
				m_FrameDataFuture.stateParam.bEventFlagList[2] = true;
				m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
			}
		}
		else if( ( m_FrameDataFuture.syncData.bIsRight == true && m_InputData.pureRight == true ) ||
			( m_FrameDataFuture.syncData.bIsRight == false && m_InputData.pureLeft == true ) )
		{
			m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
			m_FrameDataFuture.stateParam.bEventFlagList[1] = true;
			m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
			m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
		}
		else
		{
			m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
			m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
			m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
			m_FrameDataFuture.stateParam.bEventFlagList[3] = false;
		}
	}
#ifdef EVE_FIRST_CHANGE_JOB
	else if( m_InputData.oneZ == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.6f )
	{
		switch ( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_ARCHITECTURE:
		case CX2Unit::UC_EVE_CODE_EMPRESS:
			{
				m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
				m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
				m_FrameDataFuture.stateParam.bEventFlagList[2] = false;
				m_FrameDataFuture.stateParam.bEventFlagList[3] = true;
			}
			break;
#ifdef EVE_ELECTRA
		case CX2Unit::UC_EVE_ELECTRA:
			{
				m_FrameDataFuture.stateParam.bEventFlagList[6] = true;
			}
			break;
#endif EVE_ELECTRA
		}
	}
#endif EVE_FIRST_CHANGE_JOB
	else if( m_InputData.pureUp == true || m_InputData.pureDown == true 
		|| m_InputData.pureRight == true || m_InputData.pureLeft == true )
	{
#ifdef EVE_ELECTRA
		if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.4f )
		{
			if( m_InputData.pureUp == true )
			{
				m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
			}
			else if( m_InputData.pureDown == true )
			{
				m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
			}
		}
#endif EVE_ELECTRA
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.9f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}



	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( USI_WAIT );
	}
	CommonEventProcess();
#endif EVE_ELECTRA
}

#ifdef EVE_FIRST_CHANGE_JOB

void CX2GUEve::ENSI_COMBO_XXZ4_Init()
{
	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_ARCHITECTURE:
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
			XSkinMeshReadyInBackground( L"Eve_AT_ComboX5a_mesh.X" );
			XSkinMeshReadyInBackground( L"Eve_Guardian_BladeWave01.X" );
			XSkinMeshReadyInBackground( L"DummyAttackBox_50x50x50.X" );
		}
		break;
	}
}

void CX2GUEve::ENSI_COMBO_XXZ4_FrameMove()
{

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) && EventCheck( 0.01f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{

		D3DXVECTOR3 vDamagePos = GetPos();

		vDamagePos.y += 125.f;
		if(GetIsRight() == true)
		{			
			vDamagePos += (GetDirVector() * 60.f);			
		}
		else
		{		
			vDamagePos -= (GetDirVector() * 60.f);			
		}								

		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_Eve_AT_ComboX5a_Guardian", GetPos(), GetRotateDegree(), GetRotateDegree() );
		//g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_GUARDIAN_EVE, 0, true, vBonePos, 
		//	GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_COMBO_XXZ4_START", GetPowerRate(), vDamagePos, GetRotateDegree(), GetRotateDegree() );		

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.07f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( (m_pXSkinAnim->EventTimer( 1.07f ) && EventCheck( 1.07f, false ) == true) )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 125.f;
		if(GetIsRight() == true)
		{			
			vPos.x += 60.f;
		}
		else
		{		
			vPos.x -= 60.f;
		}				

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Particle_Eve_AT_ComboX5a01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#if 0 
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( (m_pXSkinAnim->EventTimerOneshot( 0.333f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( (m_pXSkinAnim->EventTimer( 0.333f ) && EventCheck( 0.333f, false ) == true) )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{	

		D3DXVECTOR3 vDamagePos = GetPos();

		vDamagePos.y += 125.f;

		if(GetIsRight() == true)
		{			
			vDamagePos += (GetDirVector() * 60.f);			
		}
		else
		{		
			vDamagePos -= (GetDirVector() * 60.f);			
		}				

		g_pX2Game->GetDamageEffect()->CreateInstance( (CKTDGObject*) this,  this, L"EVE_AT_COMBO_XXZ4_1", GetPowerRate(), vDamagePos, GetRotateDegree(), GetRotateDegree() );		
	}	
#endif
	CommonFrameMove();
}

void CX2GUEve::ENSI_COMBO_XXZ4_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}		
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}
	//

	CommonEventProcess();
}
#endif EVE_FIRST_CHANGE_JOB

void CX2GUEve::ENSI_COMBO_XXX_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.2f ) && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine" );
		D3DXVECTOR3 vBonePos1 = vBonePos;
		D3DXVECTOR3 vBonePos2 = vBonePos;
		D3DXVECTOR3 vBonePos3 = vBonePos;
		if( true == GetIsRight() )
		{
			vBonePos1 += GetDirVector() * 10.f;
			vBonePos2 += GetDirVector() * -55.f;
			vBonePos3 += GetDirVector() * 85.f;
		}
		else
		{
			vBonePos1 -= GetDirVector() * 10.f;
			vBonePos2 -= GetDirVector() * -55.f;
			vBonePos3 -= GetDirVector() * 85.f;
		}
		vBonePos1.y += 50.f;
		vBonePos2.y += -80.f;
		vBonePos3.y += -80.f;

		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_AttackX3", vBonePos1 );
		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_AttackX3", vBonePos2 );
		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_AttackX3", vBonePos3 );


	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.23f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.23f ) && EventCheck( 0.23f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();

		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 10.f;
		}
		else
		{
			vPos -= GetDirVector() * 10.f;
		}
		vPos.y += 85.f;

		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_AttackX3_Triangle01", vPos );

	}
#ifdef EVE_ELECTRA
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.02f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.02f ) == true && EventCheck( 0.02f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( m_fPlaneZAngle, 2.0f, 240.f, 130.f);
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.m_fPlaneZAngle = m_fPlaneZAngle;
	}
#endif EVE_ELECTRA
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.43f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.43f ) && EventCheck( 0.43f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine" );

#ifdef EVE_ELECTRA
		if( FlushMp( 7.0f ) == true )
#else
		if( FlushMp( 10.0f ) == true )
#endif EVE_ELECTRA
		{
			D3DXVECTOR3 vBonePos = m_pXSkinAnim->GetCloneFramePosition( L"Bip01_Spine" );

#ifdef EVE_FIRST_CHANGE_JOB
			if(/*GetUnit()->GetClass() == CX2Unit::UC_EVE_EXOTIC_GEAR &&*/ m_sEGQueensThrone.m_bEnable == true)
			{
#ifdef SKILL_BALANCE_20110728
				g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_COMBO_XXX_TRIANGLE", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate );
#else
				g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_COMBO_XXX_TRIANGLE", GetPowerRate(), 
					vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );
#endif
			}
			else
			{
#ifdef SKILL_BALANCE_20110728
#ifdef EVE_ELECTRA
				CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_XXX_TRIANGLE", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate );

				if( NULL != pEffect )
					m_EveElectraSystem.AddEffectToSystem( pEffect );
#else
				g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_XXX_TRIANGLE", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate );
#endif EVE_ELECTRA



#else

				g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_XXX_TRIANGLE", GetPowerRate(), 
					vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );
#endif
			}
#else
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_XXX_TRIANGLE", GetPowerRate(), 
				vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );
#endif			

#ifdef EVE_ELECTRA
			PlaySound( L"Eve_FireShot2_Shot.ogg" );
#endif EVE_ELECTRA

		}
		else
		{
			CreateNotEnoughMPEffect( vBonePos, 0.f, 0.f, 0.f );
		}
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_COMBO_XXX_EventProcess()
{
#ifdef EVE_ELECTRA

	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER_CANNOT_ATTACKTIME( m_fWalkCancelAfter, 0.1f )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
		if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{	
			StateChange( USI_WAIT );
		}

		if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.4f )
		{
			if( m_InputData.pureUp == true )
			{
				m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
			}
			else if( m_InputData.pureDown == true )
			{
				m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
			}
		}
		CommonEventProcess();
#else

#ifdef EVE_ELECTRA
	if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.4f )
	{
		if( m_InputData.pureUp == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
		}
		else if( m_InputData.pureDown == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
		}
	}
#endif EVE_ELECTRA
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 1.f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}


	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
#endif EVE_ELECTRA
}




#ifdef EVE_ELECTRA
void CX2GUEve::ENSI_COMBO_XXfrontX_EventProcess()
{
	CancelComboWhenChangedDirection( 1 );


	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
#ifdef SKILL_CANCEL_BY_HYPER_MODE // 김태환
	SKILL_CANCEL_AFTER( 0.01f )
#else // SKILL_CANCEL_BY_HYPER_MODE
	else if( SpecialAttackEventProcess() == true )
	{
	}
#endif //SKILL_CANCEL_BY_HYPER_MODE
#ifdef SERV_EVE_BATTLE_SERAPH
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.57f )
#else
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.57f )
#endif
	{
		StateChange( ENSI_COMBO_XXfrontXX );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	}
	else if( m_InputData.oneX == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.26666f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.9f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}



	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( USI_WAIT );
	}
	CommonEventProcess();
}


void CX2GUEve::ENSI_COMBO_XXfrontXX_FrameMove()
{

#ifdef EVE_COMBO_TEST_TEST
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.2f ) == true && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos1 = GetBonePos( L"Dummy1_Rhand" );
		D3DXVECTOR3 vBonePos2 = GetBonePos( L"Dummy2_Lhand" );

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"WALLY_8TH_GUIDED_MISSILE_EXPLOSION", GetPowerRate(), 
			vBonePos1, GetRotateDegree(), GetRotateDegree() );

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"WALLY_8TH_GUIDED_MISSILE_EXPLOSION", GetPowerRate(), 
			vBonePos2, GetRotateDegree(), GetRotateDegree() );
	}

#else
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_DamageData.hitUnitList.resize(0);

		m_DamageData.reActType = CX2DamageManager::RT_DOWN;
		m_DamageData.backSpeed.y	= 1000.f;	
		m_DamageData.bReAttack		= false;
	}

#endif EVE_COMBO_TEST_TEST

	CommonFrameMove();
}

void CX2GUEve::ENSI_COMBO_XXfrontXX_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	SKILL_CANCEL_AFTER( 1.0f )

		if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{	
			StateChange( USI_WAIT );
		}

		CommonEventProcess();
}





void CX2GUEve::ENSI_COMBO_XXdownX_EventProcess()
{
	CancelComboWhenChangedDirection( 1 );


	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
#ifdef SKILL_CANCEL_BY_HYPER_MODE // 김태환
	SKILL_CANCEL_AFTER( 0.01f )
#else // SKILL_CANCEL_BY_HYPER_MODE
	else if( SpecialAttackEventProcess() == true )
	{
	}
#endif //SKILL_CANCEL_BY_HYPER_MODE
#ifdef SERV_EVE_BATTLE_SERAPH
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.57f )
#else
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.57f )
#endif
	{
		StateChange( ENSI_COMBO_XXdownXX );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	}
	else if( m_InputData.oneX == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.3f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.9f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}

	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( USI_WAIT );
	}
	CommonEventProcess();
}





void CX2GUEve::ENSI_COMBO_XXdownXX_FrameMove()
{

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_DamageData.hitUnitList.resize(0);

		m_DamageData.reActType = CX2DamageManager::RT_DOWN;
		m_DamageData.backSpeed.y	= 1000.f;	
		m_DamageData.bReAttack		= false;
	}


	CommonFrameMove();
}


void CX2GUEve::ENSI_COMBO_XXdownXX_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	SKILL_CANCEL_AFTER( 1.0f )

		if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{	
			StateChange( USI_WAIT );
		}
		CommonEventProcess();
}
#endif EVE_ELECTRA


// ENSI_DASH_COMBO_Z
void CX2GUEve::ENSI_DASH_COMBO_Z_Start()
{
	CommonStateStart();

	m_ahMajorMeshInstance[MajorMID_DashComboZ] = INVALID_MESH_INSTANCE_HANDLE;
#ifdef EVE_ELECTRA
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectElectraDashComboZ = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectElectraDashComboZ	= NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
#endif EVE_ELECTRA
}


void CX2GUEve::ENSI_DASH_COMBO_Z_End()
{
	m_ahMajorMeshInstance[MajorMID_DashComboZ] = INVALID_MESH_INSTANCE_HANDLE;

#ifdef EVE_ELECTRA
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( m_hEffectElectraDashComboZ != INVALID_DAMAGE_EFFECT_HANDLE )
        g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_hEffectElectraDashComboZ );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	g_pX2Game->GetDamageEffect()->DestroyInstance( m_EffectElectraDashComboZ );
    m_EffectElectraDashComboZ = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
#endif EVE_ELECTRA

	CommonStateEnd();
}



void CX2GUEve::ENSI_DASH_COMBO_Z_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if( false == GetAbsoluteInvisibility() )
		{
			D3DXVECTOR3 vRot = GetRotateDegree();
			if( false == GetIsRight() )
			{
				vRot.y -= 15.f;
			}
			else
			{
				vRot.y += 15.f;
			}

			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );
			if( true == GetIsRight() )
			{
				vBonePos += GetDirVector() * 90.f;
			}
			else
			{
				vBonePos -= GetDirVector() * 90.f;
			}

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DashWave01_Eve_DashAttack", vBonePos );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( vRot );
				pSeq->SetAxisAngle( vRot );
			}

			if( true == GetIsRight() )
			{
				vBonePos -= GetDirVector() * 60.f;
			}
			else
			{
				vBonePos += GetDirVector() * 60.f;
			}


			pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DashWave01_Eve_DashAttack_Small", vBonePos );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( vRot );
				pSeq->SetAxisAngle( vRot );
			}
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.2f ) == true && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );

		//{{ 09.01.21.hoons.
		CX2DamageEffect::CEffect* pEffect = NULL;
		switch( GetUnit()->GetClass() )
		{
#ifdef EVE_FIRST_CHANGE_JOB
		case CX2Unit::UC_EVE_EXOTIC_GEAR:
		case CX2Unit::UC_EVE_CODE_NEMESIS:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_Z", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
			break;
		case CX2Unit::UC_EVE_ARCHITECTURE:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_DASH_COMBO_Z", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
			break;

		case CX2Unit::UC_EVE_CODE_EMPRESS:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EP_DASH_COMBO_Z", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
			break;
#ifdef EVE_ELECTRA
		case CX2Unit::UC_EVE_ELECTRA:
#ifdef SERV_EVE_BATTLE_SERAPH
		case CX2Unit::UC_EVE_BATTLE_SERAPH:
#endif
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
            m_hEffectElectraDashComboZ = g_pX2Game->GetDamageEffect()->CreateInstanceHandle( 
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			m_EffectElectraDashComboZ = g_pX2Game->GetDamageEffect()->CreateInstance( 
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
                this, L"EVE_PR_DASH_COMBO_Z", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
			break;
#endif EVE_ELECTRA
#endif EVE_FIRST_CHANGE_JOB
		case CX2Unit::UC_EVE_NASOD:
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_DASH_COMBO_Z", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
			break;
		}
		//}} hoons.

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_DashComboZ] = pEffect->GetMainEffectHandle();
		}
	}

	if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.2f &&
		INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_DashComboZ] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_DashComboZ] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_DashComboZ] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}

#ifdef EVE_ELECTRA
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CX2DamageEffect::CEffect* pEffectElectraDashComboZ = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffectElectraDashComboZ ) )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	if( CX2DamageEffect::CEffect* pEffectElectraDashComboZ = ( g_pX2Game->GetDamageEffect()->IsLiveInstance( m_EffectElectraDashComboZ ) == true ) ? m_EffectElectraDashComboZ : NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	{
        if ( CKTDGXMeshPlayer::CXMeshInstance *pMeshInstance = pEffectElectraDashComboZ->GetMainEffect() )
        {
		    D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
		    pMeshInstance->SetPos( vBonePos );
        }
	}

#endif EVE_ELECTRA

	CommonFrameMove();
}




void CX2GUEve::ENSI_DASH_COMBO_Z_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
#ifdef EVE_COMBO_TEST_TEST
	else if( SpecialAttackEventProcess() == true )
	{
	}
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.6f )
	{
		StateChange( ENSI_DASH_COMBO_ZX );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	}
	else if( m_InputData.oneX == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.6f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}
#endif EVE_COMBO_TEST_TEST
#ifdef EVE_FIRST_CHANGE_JOB
	//{{ 09.01.21.hoons. 대쉬 Z 컴보는 전직캐릭터 2개다 사용
#ifdef SKILL_CANCEL_BY_HYPER_MODE // 김태환
	SKILL_CANCEL_AFTER( 0.01f )
#else // SKILL_CANCEL_BY_HYPER_MODE
	else if( SpecialAttackEventProcess() == true )
	{
	}
#endif //SKILL_CANCEL_BY_HYPER_MODE
	else if( m_FrameDataFuture.stateParam.bEventFlagList[1] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.33f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[1] = false;

		StateChange( ENSI_DASH_COMBO_ZZ );
	}
	else if( m_InputData.oneZ == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.33f )
	{
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_EXOTIC_GEAR:
		case CX2Unit::UC_EVE_CODE_NEMESIS:
			m_FrameDataFuture.stateParam.bEventFlagList[1] = true;
			break;
#ifdef EVE_SECOND_CLASS_CHANGE
			// oasis907 : 김상윤 [2010.1.27] // 
		case CX2Unit::UC_EVE_CODE_EMPRESS:
			m_FrameDataFuture.stateParam.bEventFlagList[3] = true;
			break;
#endif EVE_SECOND_CLASS_CHANGE
#ifdef EVE_ELECTRA
		case CX2Unit::UC_EVE_ELECTRA:
#ifdef SERV_EVE_BATTLE_SERAPH
		case CX2Unit::UC_EVE_BATTLE_SERAPH:
#endif
			m_FrameDataFuture.stateParam.bEventFlagList[4] = true;
			break;
#endif EVE_ELECTRA
		}
	}
	//}} hoons.
#endif EVE_FIRST_CHANGE_JOB

	//{{ kimhc // 2010.1.25 //	이브 2차 전직 대시 콤보
#ifdef	EVE_SECOND_CLASS_CHANGE
	else if ( m_FrameDataFuture.stateParam.bEventFlagList[2] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.33f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[2] = false;

		StateChange( ENSI_NS_DASH_COMBO_ZX );
	}
	else if ( m_InputData.oneX == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.33f )
	{
		switch ( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_CODE_NEMESIS:
			m_FrameDataFuture.stateParam.bEventFlagList[2] = true;
			break;
		}
	}
	//{{ oasis907 : 김상윤 [2010.1.27] // 
	else if ( m_FrameDataFuture.stateParam.bEventFlagList[3] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.33f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[3] = false;

		StateChange( ENSI_EP_DASH_COMBO_ZZ );
	}
	//}} oasis907 : 김상윤 [2010.1.27] // 
#endif	EVE_SECOND_CLASS_CHANGE
#ifdef EVE_ELECTRA
	else if ( m_FrameDataFuture.stateParam.bEventFlagList[4] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.33f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[4] = false;

		StateChange( ENSI_EPR_DASH_COMBO_ZZ );
	}
#endif EVE_ELECTRA
	//}} kimhc // 2010.1.25 //	이브 2차 전직 대시 콤보
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_C
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.7f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}


	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}
	CommonEventProcess();
}

#ifdef EVE_FIRST_CHANGE_JOB
// ENSI_DASH_COMBO_ZZ
void CX2GUEve::ENSI_DASH_COMBO_ZZ_Init()
{
	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_ARCHITECTURE:
		XSkinMeshReadyInBackground( L"Eve_AT_DashComboZ2_mesh.X" );
		break;
	}	
}

void CX2GUEve::ENSI_DASH_COMBO_ZZ_StartFuture()
{
	CommonStateStartFuture();

	//To do..
	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
			m_pXSkinAnimFuture->ChangeAnim( L"EG_DashComboZ2", false );
			m_pXSkinAnimFuture->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;

	case CX2Unit::UC_EVE_ARCHITECTURE:
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
			m_pXSkinAnimFuture->ChangeAnim( L"AT_DashComboZ2", false );
			m_pXSkinAnimFuture->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;
	}
}
void CX2GUEve::ENSI_DASH_COMBO_ZZ_Start()
{
	CommonStateStart();

	//To do..
	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
			m_pXSkinAnim->ChangeAnim( L"EG_DashComboZ2", false );
			m_pXSkinAnim->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;

	case CX2Unit::UC_EVE_ARCHITECTURE:
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
			m_pXSkinAnim->ChangeAnim( L"AT_DashComboZ2", false );
			m_pXSkinAnim->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;
	}
}
void CX2GUEve::ENSI_DASH_COMBO_ZZ_End()
{
	//To do..

	CommonStateEnd();
}
void CX2GUEve::ENSI_DASH_COMBO_ZZ_FrameMove()
{
	//To do..
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true ) 
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//if( false == GetAbsoluteInvisibility() )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Footsteps" );

			switch( GetUnit()->GetClass() )
			{
			case CX2Unit::UC_EVE_EXOTIC_GEAR:
			case CX2Unit::UC_EVE_CODE_NEMESIS:
				g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_ZZ", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
				break;
			case CX2Unit::UC_EVE_ARCHITECTURE:
			case CX2Unit::UC_EVE_CODE_EMPRESS:
				g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_DASH_COMBO_ZZ", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
				break;
			}
		}
	}

	CommonFrameMove();
}
void CX2GUEve::ENSI_DASH_COMBO_ZZ_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
#ifdef SKILL_CANCEL_BY_HYPER_MODE // 김태환
	SKILL_CANCEL_AFTER( 0.01f )
#else // SKILL_CANCEL_BY_HYPER_MODE
	else if( SpecialAttackEventProcess() == true )
	{
	}
#endif //SKILL_CANCEL_BY_HYPER_MODE
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && 
		( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.53f )/* ||
															 (m_pXSkinAnimFuture->GetNowAnimationTime() > 0.33f && GetUnit()->GetClass() == CX2Unit::UC_EVE_ARCHITECTURE) )*/ )
	{
		switch ( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_EXOTIC_GEAR:
		case CX2Unit::UC_EVE_CODE_NEMESIS:
			{
				StateChange( ENSI_DASH_COMBO_ZZZ );
				m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
			}
			break;
		}
	}	
	else if( m_InputData.oneZ == true && 
		(m_pXSkinAnimFuture->GetNowAnimationTime() < 0.53f/* || m_pXSkinAnimFuture->GetNowAnimationTime() < 0.33f*/) )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_C
	{
		float fSkipTime = 0.8f;

		switch ( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_EXOTIC_GEAR:
		case CX2Unit::UC_EVE_CODE_NEMESIS:
			fSkipTime = 0.6f; //1/3 감소
			break;
		}

		if( m_pXSkinAnimFuture->GetNowAnimationTime() > fSkipTime )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}


	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}
	CommonEventProcess();
}
// ENSI_DASH_COMBO_ZZZ
void CX2GUEve::ENSI_DASH_COMBO_ZZZ_StartFuture()
{
	CommonStateStartFuture();

	//To do..
	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
			m_pXSkinAnimFuture->ChangeAnim( L"EG_DashComboZ3", false );
			m_pXSkinAnimFuture->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;

	case CX2Unit::UC_EVE_ARCHITECTURE:
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
			m_pXSkinAnimFuture->ChangeAnim( L"AT_DashComboZ3", false );
			m_pXSkinAnimFuture->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;
	}
}
void CX2GUEve::ENSI_DASH_COMBO_ZZZ_Start()
{
	CommonStateStart();

	//To do..
	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
			m_pXSkinAnim->ChangeAnim( L"EG_DashComboZ3", false );
			m_pXSkinAnim->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;

	case CX2Unit::UC_EVE_ARCHITECTURE:
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
			m_pXSkinAnim->ChangeAnim( L"AT_DashComboZ3", false );
			m_pXSkinAnim->Play( CKTDGXSkinAnim::XAP_ONE_WAIT );
		} break;
	}

	m_ahMajorMeshInstance[MajorMID_DashComboZZZ] = INVALID_MESH_INSTANCE_HANDLE;
}
void CX2GUEve::ENSI_DASH_COMBO_ZZZ_End()
{
	//To do..

	m_ahMajorMeshInstance[MajorMID_DashComboZZZ] = INVALID_MESH_INSTANCE_HANDLE;

	CommonStateEnd();
}
void CX2GUEve::ENSI_DASH_COMBO_ZZZ_FrameMove()
{
	//To do..

	switch ( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true ) 
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			{
				//if( false == GetAbsoluteInvisibility() )
				{
					D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Footsteps" );

					g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_ZZZ01", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
					g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_ZZZ02", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
					g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_ZZZ03", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
					g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_ZZZ04", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
				}
			}
		}
		break;

	case CX2Unit::UC_EVE_ARCHITECTURE:
	case CX2Unit::UC_EVE_CODE_EMPRESS:
		{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.23f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			if( m_pXSkinAnim->EventTimer( 0.23f ) == true && EventCheck( 0.23f, false ) == true ) 
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			{
				D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );

				CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_DASH_COMBO_ZZZ", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );

				if( NULL != pEffect )
				{
					m_ahMajorMeshInstance[MajorMID_DashComboZZZ] = pEffect->GetMainEffectHandle();
				}
			}
		}
		break;
	}
	// 	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true &&
	// 		GetUnit()->GetClass() == CX2Unit::UC_EVE_EXOTIC_GEAR ) 
	// 	{
	// 		//if( false == GetAbsoluteInvisibility() )
	// 		{
	// 			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Footsteps" );
	// 
	// 			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_ZZZ01", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
	// 			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_ZZZ02", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
	// 			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_ZZZ03", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
	// 			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_ZZZ04", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
	// 		}
	// 	}

	// 	if( m_pXSkinAnim->EventTimer( 0.23f ) == true && EventCheck( 0.23f, false ) == true &&
	// 		GetUnit()->GetClass() == CX2Unit::UC_EVE_ARCHITECTURE ) 
	// 	{
	// 		D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );
	// 
	// 		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_DASH_COMBO_ZZZ", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
	// 
	// 		if( NULL != pEffect )
	// 		{
	// 			m_ahMajorMeshInstance[MajorMID_DashComboZZZ] = pEffect->GetMainEffectHandle();
	// 		}
	// 	}

	if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.2f &&
		INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_DashComboZZZ] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_DashComboZZZ] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_DashComboZZZ] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}

	CommonFrameMove();
}
void CX2GUEve::ENSI_DASH_COMBO_ZZZ_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	//else if( SpecialAttackEventProcess() == true )
	//{
	//}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXCAS
	{
		float fSkipTime = 1.5f;

		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_ARCHITECTURE:
		case CX2Unit::UC_EVE_CODE_NEMESIS:
			fSkipTime = 0.75f; //1/2 감소
			break;
		case CX2Unit::UC_EVE_EXOTIC_GEAR:
		case CX2Unit::UC_EVE_CODE_EMPRESS:
			fSkipTime = 1.f; //1/3 증가
			break;
		}

		if( m_pXSkinAnimFuture->GetNowAnimationTime() > fSkipTime )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}
#ifdef BALANCE_CODE_NEMESIS_20121213
	switch( GetUnit()->GetClass() )
	{
	case CX2Unit::UC_EVE_EXOTIC_GEAR:
	case CX2Unit::UC_EVE_CODE_NEMESIS:
		{
			if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
			{
				StateChange( USI_WAIT );
			}
			ELSE_IF_ZX_PRESSED_AFTER( m_fAttackCancelAfter )
			{
				StateChange( USI_WAIT );
			}
			SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
				BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
				WALK_CANCEL_AFTER( m_fWalkCancelAfter )
				DASH_CANCEL_AFTER( m_fDashCancelAfter )
		}
		break;
	default:
		if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{
			StateChange( USI_WAIT );
		}
		break;
	}
#else
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}
#endif //BALANCE_CODE_NEMESIS_20121213
	CommonEventProcess();
}
#endif EVE_FIRST_CHANGE_JOB



#ifdef EVE_COMBO_TEST_TEST
void CX2GUEve::ENSI_DASH_COMBO_ZX_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.27f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.27f ) == true && EventCheck( 0.27f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );

		CKTDGParticleSystem::CParticleEventSequence* pSeq = 
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_ComboZ5Down_Particle01", vBonePos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
			pSeq->SetLandPosition( GetLandPosition().y );
		}

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_ZZZdownZZ", GetPowerRate(), 
			vBonePos, GetRotateDegree(), GetRotateDegree() );

		UpDownCrashCameraNoReset( 5.f, 0.15f );
	}

	CommonFrameMove();
}


void CX2GUEve::ENSI_DASH_COMBO_ZX_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_InputData.pureUp == true || m_InputData.pureDown == true 
		|| m_InputData.pureRight == true || m_InputData.pureLeft == true )
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.7f )
		{
			StateChange( USI_WAIT );
		}
	}
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

#endif EVE_COMBO_TEST_TEST


// ENSI_DASH_COMBO_X
void CX2GUEve::ENSI_DASH_COMBO_X_FrameMove()
{

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 110.f;
		}
		else
		{
			vPos -= GetDirVector() * 110.f;
		}
		vPos.y += 30.f;

		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_DashAttackX_FireImpact01", vPos );

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.13f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.13f ) == true && EventCheck( 0.13f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos1 = GetBonePos( L"Dummy1_Rhand" );
		D3DXVECTOR3 vBonePos2 = GetBonePos( L"Dummy2_Lhand" );
		D3DXVECTOR3 vBonePos = vBonePos1 * 0.8f + vBonePos2 * 0.2f;
		D3DXVECTOR3 vDegree = GetRotateDegree();
		vDegree.z += 70.f;

#ifdef EVE_ELECTRA
		if( FlushMp( 8.f * m_fMPConsumeRateElectronBall ) == true )
#else
		if( FlushMp( 15.f * m_fMPConsumeRateElectronBall ) == true )
#endif EVE_ELECTRA
		{
			switch ( GetUnit()->GetClass() )
			{
			case CX2Unit::UC_EVE_EXOTIC_GEAR:
			case CX2Unit::UC_EVE_CODE_NEMESIS:
				{
#ifdef INHERIT_FORCEDOWNRATE
					CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_X_FIRE_BALL", GetPowerRate() * m_fAttackPowerRateElectronBall, 
						vBonePos, vDegree, vDegree, m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, 1.f );

					if( NULL != pEffect )
						pEffect->SetInheritForceDownRate(true);
#else
					g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_X_FIRE_BALL", GetPowerRate(), vBonePos, vDegree, vDegree );				// 마지막에 폭발하는 파볼
#endif INHERIT_FORCEDOWNRATE

#ifdef EVE_ELECTRA
					PlaySound( L"Eve_FireBigShot.ogg" );
#endif EVE_ELECTRA
				}
				break;

			default:
				{
#ifdef INHERIT_FORCEDOWNRATE
					CX2DamageEffect::CEffect* pEffect = NULL;
#ifdef EVE_ELECTRA
					pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_DASH_COMBO_X_FIRE_BALL", GetPowerRate() * m_fAttackPowerRateElectronBall, 
						vBonePos, vDegree, vDegree, m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, 1.f );
#else

					pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_DASH_COMBO_X_FIRE_BALL", GetPowerRate() * m_fAttackPowerRateElectronBall, 
						vBonePos, vDegree, vDegree, m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, 1.f );
					// oasis907 : 김상윤 [2011.5.3] 메가 일렉트론볼 연마의 사정거리 증가는 예외
#endif EVE_ELECTRA
					if( NULL != pEffect )
						pEffect->SetInheritForceDownRate(true);

#ifdef EVE_ELECTRA
					if( NULL != pEffect )
#ifdef SERV_EVE_BATTLE_SERAPH
						m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_DASH_COMBO_X_FIRE_BALL_AMPLIFY_FILTERED",
						L"EVE_DASH_COMBO_X_FIRE_BALL_SPECTRUM_FILTERED", L"EVE_DASH_COMBO_X_FIRE_BALL_INDUCTION_FILTERED",
						L"EVE_DASH_COMBO_X_FIRE_BALL_FUSION_FILTERED" );
#else
						m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_DASH_COMBO_X_FIRE_BALL_FILTERED", L"EVE_DASH_COMBO_X_FIRE_BALL_FILTERED" );
#endif
#endif EVE_ELECTRA

#else
					g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_DASH_COMBO_X_FIRE_BALL", GetPowerRate(), vBonePos, vDegree, vDegree );				// 폭발하지 않는 파볼
#endif INHERIT_FORCEDOWNRATE

#ifdef EVE_ELECTRA
					PlaySound( L"Eve_FireBigShot.ogg" );
#endif EVE_ELECTRA
				}
				break;
			}
		}
		else
		{
			CreateNotEnoughMPEffect( (vBonePos1+vBonePos2)*0.5f, 0.f, 0.f, vDegree.z );
		}
	}
#ifdef EVE_ELECTRA
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.066f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.066f ) == true && EventCheck( 0.066f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( 70.f, 2.0f, 140.f, 230.f );
	}
#endif EVE_ELECTRA

	CommonFrameMove();

}




void CX2GUEve::ENSI_DASH_COMBO_X_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
#ifdef EVE_FIRST_CHANGE_JOB
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.33f )
	{
		StateChange( ENSI_DASH_COMBO_XZ );
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	}
	else if( m_InputData.oneZ == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.33f )
	{
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_EXOTIC_GEAR:
		case CX2Unit::UC_EVE_CODE_NEMESIS:
			m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
			break;
		}
	}
#endif EVE_FIRST_CHANGE_JOB
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.43f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}


	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}
	CommonEventProcess();
}
#ifdef EVE_FIRST_CHANGE_JOB
// ENDSI_DASH_COMBO_XZ
void CX2GUEve::ENSI_DASH_COMBO_XZ_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Footsteps" );

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_XZ01", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_XZ02", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_XZ03", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_COMBO_XZ04", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
	}

	CommonFrameMove();
}
void CX2GUEve::ENSI_DASH_COMBO_XZ_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		float fSkipTime = 1.2f;
		switch ( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_EXOTIC_GEAR:
		case CX2Unit::UC_EVE_CODE_NEMESIS:
			fSkipTime = 0.935f; 
			break;
		}

		if( m_pXSkinAnimFuture->GetNowAnimationTime() > fSkipTime )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}


	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}
	CommonEventProcess();
}
#endif EVE_FIRST_CHANGE_JOB

// ENSI_JUMP_COMBO_Z
void CX2GUEve::ENSI_JUMP_COMBO_Z_Start()
{
	CommonStateStart();

	// to do..
#ifdef EVE_FIRST_CHANGE_JOB
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_01] = INVALID_MESH_INSTANCE_HANDLE;
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_02] = INVALID_MESH_INSTANCE_HANDLE;
#endif EVE_FIRST_CHANGE_JOB
}
void CX2GUEve::ENSI_JUMP_COMBO_Z_End()
{
	// to do.. 
#ifdef EVE_FIRST_CHANGE_JOB
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_01] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_01]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_01] = INVALID_MESH_INSTANCE_HANDLE;
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_02] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_02]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_02] = INVALID_MESH_INSTANCE_HANDLE;
#endif EVE_FIRST_CHANGE_JOB

	CommonStateEnd();
}
void CX2GUEve::ENSI_JUMP_COMBO_Z_FrameMove()
{
	// to do..
#ifdef EVE_FIRST_CHANGE_JOB
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		/*GetUnit()->GetClass() == CX2Unit::UC_EVE_EXOTIC_GEAR &&*/ m_sEGQueensThrone.m_bEnable == true )
	{
		D3DXVECTOR3 vPos = GetBonePos(L"Dummy2_Lhand");
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_JUMP_ATTACK_Z_01", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_01] = pEffect->GetMainEffectHandle();
		}
		vPos = GetBonePos(L"Dummy1_Rhand");
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_JUMP_ATTACK_Z_02", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_02] = pEffect->GetMainEffectHandle();
		}
	}


	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_01] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_01] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetBonePos(L"Dummy2_Lhand");
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_01] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_02] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_02] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetBonePos(L"Dummy1_Rhand");
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_Z_02] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
#endif EVE_FIRST_CHANGE_JOB

	CommonFrameMove();
}

void CX2GUEve::ENSI_JUMP_COMBO_Z_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		//if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true )
		//{
		//	m_fCanNotJumpTime = 0.2f;
		//}
		m_fCanNotAttackTime = 0.1f; // 제자리 점프하면서 계속해서 공격하는 것을 막기 위해서

		StateChange( USI_JUMP_LANDING );
	}
	CommonEventProcess();
}


// ENSI_JUMP_COMBO_X
void CX2GUEve::ENSI_JUMP_COMBO_X_Start()
{
	CommonStateStart();

	// to do..
#ifdef EVE_FIRST_CHANGE_JOB
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_01] = INVALID_MESH_INSTANCE_HANDLE;
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_02] = INVALID_MESH_INSTANCE_HANDLE;
#endif EVE_FIRST_CHANGE_JOB
}
void CX2GUEve::ENSI_JUMP_COMBO_X_End()
{
	// to do.. 
#ifdef EVE_FIRST_CHANGE_JOB
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_01] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_01]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_01] = INVALID_MESH_INSTANCE_HANDLE;
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_02] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_02]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_02] = INVALID_MESH_INSTANCE_HANDLE;
#endif EVE_FIRST_CHANGE_JOB

	CommonStateEnd();
}
void CX2GUEve::ENSI_JUMP_COMBO_X_FrameMove()
{
	// to do..
#ifdef EVE_FIRST_CHANGE_JOB
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		/*GetUnit()->GetClass() == CX2Unit::UC_EVE_EXOTIC_GEAR &&*/ m_sEGQueensThrone.m_bEnable == true )
	{
		D3DXVECTOR3 vPos = GetBonePos(L"Dummy2_Lhand");
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_JUMP_ATTACK_X_01", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_01] = pEffect->GetMainEffectHandle();
		}

		vPos = GetBonePos(L"Dummy1_Rhand");
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_JUMP_ATTACK_X_02", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_02] = pEffect->GetMainEffectHandle();
		}
	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_01] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_01] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetBonePos(L"Dummy2_Lhand");
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_01] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_02] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_02] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetBonePos(L"Dummy1_Rhand");
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Jump_Attack_X_02] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
#endif EVE_FIRST_CHANGE_JOB

	CommonFrameMove();
}

void CX2GUEve::ENSI_JUMP_COMBO_X_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		//if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true )
		//{
		//	m_fCanNotJumpTime = 0.2f;
		//}
		m_fCanNotAttackTime = 0.2f;

		StateChange( ENSI_JUMP_COMBO_X_LANDING );
	}

	CommonEventProcess();
}



void CX2GUEve::ENSI_JUMP_COMBO_X_LANDING_StartFuture()
{
	CommonStateStartFuture();

	m_iJumpFlyCount = 0;
	m_iDashJumpCount = 0;

	//m_PhysicParam.fDownAccel		= 0.f;
}

void CX2GUEve::ENSI_JUMP_COMBO_X_LANDING_Start()
{
	CommonStateStart();
	CreateStepDust();
}

void CX2GUEve::ENSI_JUMP_COMBO_X_LANDING_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	//else if( m_InputData.oneZ == true && (m_bReAttackZ1Right != m_FrameDataFuture.syncData.bIsRight || m_fReAttackZ1Time <= 0.0f) )
	//{
	//	StateChange( ENSI_COMBO_Z );
	//}
	//else if( m_InputData.oneX == true )
	//{
	//	StateChange( ENSI_COMBO_X );
	//}
	//else if( SpecialAttackEventProcess() == true )
	//{
	//}
	//else if( m_InputData.pureDoubleRight == true || m_InputData.pureDoubleLeft == true )
	//{
	//	StateChangeDashIfPossible();
	//}
	//else if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
	//{
	//	StateChange( ENSI_WALK );
	//}
	//else if( m_InputData.pureUp == true )
	//{
	//	StateChange( ENSI_JUMP_UP );
	//	m_PhysicParam.nowSpeed.y = GetJumpSpeed();
	//	m_FrameDataFuture.syncData.position.y += LINE_RADIUS;
	//}
	//#ifdef SKILL_SHORT_CUT_KEY_TEST
	//	else if( m_InputData.oneLCtr == true && m_FrameDataFuture.syncData.m_HyperModeCount > 0 && m_fRemainHyperModeTime <= 0.0f )
	//#else
	//	else if( m_InputData.oneA == true && m_FrameDataFuture.syncData.m_HyperModeCount > 0 && m_fRemainHyperModeTime <= 0.0f )
	//#endif
	//	{
	//		StateChange( ENSI_HYPER_MODE );
	//	}
	//#ifdef SKILL_SHORT_CUT_KEY_TEST
	//	else if( m_InputData.pureC == true && FlushMp(30.0f,false) == true ) //특수키 변환 작업중
	//#else
	//	else if( m_InputData.pureS == true && FlushMp(30.0f,false) == true )
	//#endif
	//	{
	//		//StateChange( ENSI_SUPER_DASH_READY ); 
	//	}
	//	else if( m_InputData.oneDown == true 
	//		&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, 
	//		LINE_RADIUS, 
	//		&m_FrameDataFuture.unitCondition.landPosition, 
	//		&m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
	//	{
	//		StateChange( ENSI_JUMP_DOWN );
	//		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	//	}
	//	else if( m_InputData.pureUp == true			|| m_InputData.pureDown == true 
	//		|| m_InputData.pureRight == true		|| m_InputData.pureLeft == true
	//		|| m_InputData.pureZ == true			|| m_InputData.pureX == true
	//#ifndef SKILL_SHORT_CUT_KEY_TEST
	//		|| m_InputData.pureC == true
	//#endif //SKILL_SHORT_CUT_KEY_TEST			
	//#ifdef SKILL_SHORT_CUT_KEY_TEST
	//		|| m_InputData.pureLCtr == true
	//		|| m_InputData.pureC == true  //특수키 변환 작업중
	//#else
	//		|| m_InputData.pureA == true
	//		|| m_InputData.pureS == true 
	//#endif
	//		)
	//	{
	//		StateChange( ENSI_WAIT, false );
	//	}



	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

// ENSI_DASH_JUMP_COMBO_Z
void CX2GUEve::ENSI_DASH_JUMP_COMBO_Z_Start()
{
	CommonStateStart();

	// to do..
#ifdef EVE_FIRST_CHANGE_JOB
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_01] = INVALID_MESH_INSTANCE_HANDLE;
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_02] = INVALID_MESH_INSTANCE_HANDLE;
#endif EVE_FIRST_CHANGE_JOB
}

void CX2GUEve::ENSI_DASH_JUMP_COMBO_Z_End()
{
	// to do..
#ifdef EVE_FIRST_CHANGE_JOB
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_01] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_01]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_01] = INVALID_MESH_INSTANCE_HANDLE;
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_02] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_02]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_02] = INVALID_MESH_INSTANCE_HANDLE;
#endif EVE_FIRST_CHANGE_JOB

	CommonStateEnd();
}
void CX2GUEve::ENSI_DASH_JUMP_COMBO_Z_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    //if( m_pXSkinAnim->EventTimerOneshot( 0) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	//if( m_pXSkinAnim->EventTimer( 0.135f ) == true && EventCheck( 0.135f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	//{
	//	m_DamageData.hitUnitList.resize(0);

	//	m_DamageData.reActType		= CX2DamageManager::RT_DOWN;
	//}
#ifdef EVE_FIRST_CHANGE_JOB
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		/*GetUnit()->GetClass() == CX2Unit::UC_EVE_EXOTIC_GEAR && */m_sEGQueensThrone.m_bEnable == true )
	{
		D3DXVECTOR3 vPos = GetBonePos(L"Dummy2_Lhand");
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_DASH_JUMP_COMBO_Z1_01", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_01] = pEffect->GetMainEffectHandle();
		}

		vPos = GetBonePos(L"Dummy1_Rhand");
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_DASH_JUMP_COMBO_Z1_02", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_02] = pEffect->GetMainEffectHandle();
		}
	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_01] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_01] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetBonePos(L"Dummy2_Lhand");
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_01] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_02] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_02] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetBonePos(L"Dummy1_Rhand");
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_Z_02] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
#endif EVE_FIRST_CHANGE_JOB

	CommonFrameMove();
}
void CX2GUEve::ENSI_DASH_JUMP_COMBO_Z_EventProcess()
{
	//#ifdef EVE_FIRST_CHANGE_JOB
	//	if( m_InputData.oneZ == true )
	//	{
	//		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	//	}
	//	if( m_InputData.oneX == true && m_FrameDataFuture.stateParam.bEventFlagList[0] == false )
	//	{
	//		switch( GetUnit()->GetClass() )
	//		{
	//		case CX2Unit::UC_EVE_EXOTIC_GEAR:
	//			m_FrameDataFuture.stateParam.bEventFlagList[1] = true;
	//			break;
	//		}
	//	}
	//#else
#ifdef EVE_ELECTRA
	if( m_InputData.oneZ == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.13333f )
#else
	if( m_InputData.oneZ == true )
#endif EVE_ELECTRA
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}
	//#endif EVE_FIRST_CHANGE_JOB

	if( true == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_LANDING );		// not dash_jump_landing 
	}
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.3f )
	{
		StateChange( ENSI_DASH_JUMP_COMBO_ZZ );
	}
	//#ifdef EVE_FIRST_CHANGE_JOB
	//	else if( m_FrameDataFuture.stateParam.bEventFlagList[1] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.3f )
	//	{
	//		StateChange( ENSI_DASH_JUMP_COMBO_ZX );
	//	}
	//#endif EVE_FIRST_CHANGE_JOB
#ifdef EVE_SECOND_CLASS_CHANGE
	// oasis907 : 김상윤 [2010.1.27] // 
	else if( m_FrameDataFuture.stateParam.bEventFlagList[1] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.266f )
	{
#ifdef SERV_EVE_BATTLE_SERAPH
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_CODE_EMPRESS:
			StateChange( ENSI_EP_JUMP_COMBO_ZX );
			break;
		case CX2Unit::UC_EVE_BATTLE_SERAPH:
			{
				m_iBoostAttackCount = 0;
				m_bBoostUpAttack = false;
				StateChangeBoostAttackIfPossible();
			}
			break;
		}
#else
		StateChange( ENSI_EP_JUMP_COMBO_ZX );
#endif
		m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
	}
	else if( m_InputData.oneX == true ) // 0.266f
	{
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_CODE_EMPRESS:
			m_FrameDataFuture.stateParam.bEventFlagList[1] = true;
			break;
#ifdef SERV_EVE_BATTLE_SERAPH
		case CX2Unit::UC_EVE_BATTLE_SERAPH:
			m_FrameDataFuture.stateParam.bEventFlagList[1] = true;
			break;
#endif
		}
	}
#endif EVE_SECOND_CLASS_CHANGE

	CommonEventProcess();
}
// ENSI_DASH_JUMP_COMBO_ZZ
void CX2GUEve::ENSI_DASH_JUMP_COMBO_ZZ_Start()
{
	CommonStateStart();

	// to do..
#ifdef EVE_FIRST_CHANGE_JOB
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_01] = INVALID_MESH_INSTANCE_HANDLE;
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_02] = INVALID_MESH_INSTANCE_HANDLE;
#endif EVE_FIRST_CHANGE_JOB
}

void CX2GUEve::ENSI_DASH_JUMP_COMBO_ZZ_End()
{
	// to do..
#ifdef EVE_FIRST_CHANGE_JOB
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_01] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_01]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_01] = INVALID_MESH_INSTANCE_HANDLE;
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_02] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_02]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_02] = INVALID_MESH_INSTANCE_HANDLE;
#endif EVE_FIRST_CHANGE_JOB

	CommonStateEnd();
}
void CX2GUEve::ENSI_DASH_JUMP_COMBO_ZZ_FrameMove()
{
	//if( m_pXSkinAnim->EventTimer( 0.135f ) == true && EventCheck( 0.135f, false ) == true )
	//{
	//	m_DamageData.hitUnitList.resize(0);

	//	m_DamageData.reActType		= CX2DamageManager::RT_DOWN;
	//}
#ifdef EVE_FIRST_CHANGE_JOB
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		/*GetUnit()->GetClass() == CX2Unit::UC_EVE_EXOTIC_GEAR && */m_sEGQueensThrone.m_bEnable == true )
	{
		D3DXVECTOR3 vPos = GetBonePos(L"Dummy2_Lhand");
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_DASH_JUMP_COMBO_Z2_01", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_01] = pEffect->GetMainEffectHandle();
		}

		vPos = GetBonePos(L"Dummy1_Rhand");
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_DASH_JUMP_COMBO_Z2_02", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_02] = pEffect->GetMainEffectHandle();
		}
	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_01] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_01] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetBonePos(L"Dummy2_Lhand");
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_01] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_02] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_02] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetBonePos(L"Dummy1_Rhand");
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZ_02] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
#endif EVE_FIRST_CHANGE_JOB

	CommonFrameMove();
}
void CX2GUEve::ENSI_DASH_JUMP_COMBO_ZZ_EventProcess()
{
#ifdef EVE_ELECTRA
	if( m_InputData.oneZ == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.1333f )
#else
	if( m_InputData.oneZ == true )
#endif EVE_ELECTRA
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}

	if( true == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_LANDING );		// not dash_jump_landing 
	}
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.333f )
	{
		StateChange( ENSI_DASH_JUMP_COMBO_ZZZ );
	}
#ifdef EVE_SECOND_CLASS_CHANGE
	// oasis907 : 김상윤 [2010.1.27] // 
	else if( m_FrameDataFuture.stateParam.bEventFlagList[1] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.266f )
	{
		StateChange( ENSI_EP_JUMP_COMBO_ZX );
		m_FrameDataFuture.stateParam.bEventFlagList[1] = false;
	}
	else if( m_InputData.oneX == true) // 0.266f
	{
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_CODE_EMPRESS:
			m_FrameDataFuture.stateParam.bEventFlagList[1] = true;
			break;
		}
	}
#endif EVE_SECOND_CLASS_CHANGE


	CommonEventProcess();
}
// ENSI_DASH_JUMP_COMBO_ZZZ
void CX2GUEve::ENSI_DASH_JUMP_COMBO_ZZZ_Start()
{
	CommonStateStart();

	// to do..
#ifdef EVE_FIRST_CHANGE_JOB
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_01] = INVALID_MESH_INSTANCE_HANDLE;
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_02] = INVALID_MESH_INSTANCE_HANDLE;
#endif EVE_FIRST_CHANGE_JOB
}

void CX2GUEve::ENSI_DASH_JUMP_COMBO_ZZZ_End()
{
	// to do..
#ifdef EVE_FIRST_CHANGE_JOB
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_01] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_01]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_01] = INVALID_MESH_INSTANCE_HANDLE;
	if( m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_02] != INVALID_MESH_INSTANCE_HANDLE )
		g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_02]);
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_02] = INVALID_MESH_INSTANCE_HANDLE;
#endif EVE_FIRST_CHANGE_JOB

	CommonStateEnd();
}
void CX2GUEve::ENSI_DASH_JUMP_COMBO_ZZZ_FrameMove()
{
	//if( m_pXSkinAnim->EventTimer( 0.135f ) == true && EventCheck( 0.135f, false ) == true )
	//{
	//	m_DamageData.hitUnitList.resize(0);

	//	m_DamageData.reActType		= CX2DamageManager::RT_DOWN;
	//}
#ifdef EVE_FIRST_CHANGE_JOB
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		/*GetUnit()->GetClass() == CX2Unit::UC_EVE_EXOTIC_GEAR && */m_sEGQueensThrone.m_bEnable == true )
	{
		D3DXVECTOR3 vPos = GetBonePos(L"Dummy2_Lhand");
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_DASH_JUMP_COMBO_Z3_01", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_01] = pEffect->GetMainEffectHandle();
		}

		vPos = GetBonePos(L"Dummy1_Rhand");
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_DASH_JUMP_COMBO_Z3_02", m_sEGQueensThrone.m_fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_02] = pEffect->GetMainEffectHandle();
		}
	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_01] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_01] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetBonePos(L"Dummy2_Lhand");
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_01] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_02] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_02] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vPos = GetBonePos(L"Dummy1_Rhand");
			pMeshInst->SetPos( vPos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Dash_Jump_Combo_ZZZ_02] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
#endif EVE_FIRST_CHANGE_JOB

	CommonFrameMove();
}
void CX2GUEve::ENSI_DASH_JUMP_COMBO_ZZZ_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		//if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true )
		//{
		//	m_fCanNotJumpTime = 0.2f;
		//}
		StateChange( USI_JUMP_LANDING );
	}

	CommonEventProcess();
}

#ifdef EVE_FIRST_CHANGE_JOB
// ENSI_DASH_JUMP_COMBO_ZX
void CX2GUEve::ENSI_DASH_JUMP_COMBO_ZX_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );

		CX2DamageEffect::CEffect* pEffect = NULL;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_DASH_JUMP_COMBO_ZX", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_DashJumpComboZX] = pEffect->GetMainEffectHandle();
		}
	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.01f && 
		INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_DashJumpComboZX] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_DashJumpComboZX] );
		if( NULL != pMeshInst )
		{
			//D3DXVECTOR3 vBonePos	= GetBonePos( L"Dummy2_Lhand" );
			//D3DXVECTOR3 vAngle		= ;
			//m_ahMajorMeshInstance[MajorMID_DashJumpComboZX]->SetPos( vBonePos );
			//m_ahMajorMeshInstance[MajorMID_DashJumpComboZX]->SetAngleDegree( vAngle );
			// 09.01.21.hoons.이부분의 메쉬는 pos,rotate 2가지다 실시간으로 셋팅이 되어야 하기때문에..
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pMultiAnimFrame = m_pXSkinAnim->GetCloneFrame( L"Dummy2_Lhand" );
			pMeshInst->SetUseDXMatrix( pMultiAnimFrame->combineMatrix );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_DashJumpComboZX] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}

	CommonFrameMove();
}
void CX2GUEve::ENSI_DASH_JUMP_COMBO_ZX_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_LANDING );
	}

	CommonEventProcess();
}
void CX2GUEve::ENSI_DASH_JUMP_COMBO_ZX_End()
{
	m_ahMajorMeshInstance[MajorMID_DashJumpComboZX] = INVALID_MESH_INSTANCE_HANDLE;

	CommonStateEnd();
}
#endif EVE_FIRST_CHANGE_JOB


void CX2GUEve::ENSI_DASH_JUMP_COMBO_X_Start()
{
	CommonStateStart();

	SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_DASH_JUMP_COMBO_X_01, INVALID_PARTICLE_SEQUENCE_HANDLE );
	SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_DASH_JUMP_COMBO_X_02, INVALID_PARTICLE_SEQUENCE_HANDLE );
#ifdef EVE_ELECTRA
	m_fPlaneZAngle = 0.f;
#endif EVE_ELECTRA
}

void CX2GUEve::ENSI_DASH_JUMP_COMBO_X_End()
{

	SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_DASH_JUMP_COMBO_X_01, INVALID_PARTICLE_SEQUENCE_HANDLE );
	SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_DASH_JUMP_COMBO_X_02, INVALID_PARTICLE_SEQUENCE_HANDLE );

	CommonStateEnd();
}


void CX2GUEve::ENSI_DASH_JUMP_COMBO_X_FrameMove()
{

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );

		if( true == GetIsRight() )
		{
			vBonePos += GetDirVector() * -30.f;
		}
		else
		{
			vBonePos -= GetDirVector() * -30.f;
		}
		vBonePos.y += 20.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq =
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_IllusionStrike03", vBonePos, 80, 80, -1, -1, 0.4f );
		if( NULL != pSeq )
		{
			//pSeq->SetAddRotate( GetRotateDegree() );		// billboard된 파티클은 이렇게 각도를 돌려버리면 billboard가 이상하게 된다.
			//pSeq->SetAxisAngle( GetRotateDegree() );

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_DASH_JUMP_COMBO_X_01, pSeq->GetHandle() );
		}
	}
#ifdef BALANCE_CODE_NEMESIS_20121213
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.266f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.266f ) == true && EventCheck( 0.266f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );

		if( true == GetIsRight() )
		{
			vBonePos += GetDirVector() * 10.f;
		}
		else
		{
			vBonePos -= GetDirVector() * 10.f;
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeq = 
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_DashJumpattackX01", vBonePos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_DASH_JUMP_COMBO_X_02, pSeq->GetHandle() );
		}

		vBonePos = GetBonePos( L"Bip01_Spine" );

#ifdef EVE_ELECTRA
		if( FlushMp( 8.0f * m_fMPConsumeRateElectronBall ) == true ) 
#else
		if( FlushMp( 15.0f * m_fMPConsumeRateElectronBall ) == true ) 
#endif EVE_ELECTRA
		{
#ifdef INHERIT_FORCEDOWNRATE
			CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_X_FIRE_BALL", GetPowerRate() * m_fAttackPowerRateElectronBall, 
				vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate );

			if( NULL != pEffect )
				pEffect->SetInheritForceDownRate(true);

#ifdef EVE_ELECTRA
			if( NULL != pEffect )
#ifdef SERV_EVE_BATTLE_SERAPH
				m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_COMBO_X_FIRE_BALL_AMPLIFY_FILTERED", 
				L"EVE_COMBO_X_FIRE_BALL_SPECTRUM_FILTERED", L"EVE_COMBO_X_FIRE_BALL_INDUCTION_FILTERED", L"EVE_COMBO_X_FIRE_BALL_FUSION_FILTERED" );
#else
				m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_COMBO_X_FIRE_BALL_FILTERED", L"EVE_COMBO_X_FIRE_BALL_FILTERED" );
#endif
#endif EVE_ELECTRA

#else
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_X_FIRE_BALL", GetPowerRate() * m_fAttackPowerRateElectronBall, 
				vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate );
#endif INHERIT_FORCEDOWNRATE

#ifdef EVE_ELECTRA
			PlaySound( L"Eve_FireShot1.ogg" );
#endif EVE_ELECTRA
		}
		else
		{
			CreateNotEnoughMPEffect( vBonePos, 0.f, 0.f, 0.f );
		}
	}
#else
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.266f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.266f ) == true && EventCheck( 0.266f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );

		if( true == GetIsRight() )
		{
			vBonePos += GetDirVector() * 10.f;
		}
		else
		{
			vBonePos -= GetDirVector() * 10.f;
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeq = 
			g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_DashJumpattackX01", vBonePos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_DASH_JUMP_COMBO_X_02, pSeq->GetHandle() );
		}

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine" );

#ifdef EVE_ELECTRA
		if( FlushMp( 8.0f * m_fMPConsumeRateElectronBall ) == true ) 
#else
		if( FlushMp( 15.0f * m_fMPConsumeRateElectronBall ) == true ) 
#endif EVE_ELECTRA
		{
#ifdef INHERIT_FORCEDOWNRATE
			CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_X_FIRE_BALL", GetPowerRate() * m_fAttackPowerRateElectronBall, 
				vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate );

			if( NULL != pEffect )
				pEffect->SetInheritForceDownRate(true);

#ifdef EVE_ELECTRA
			if( NULL != pEffect )
#ifdef SERV_EVE_BATTLE_SERAPH
				m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_COMBO_X_FIRE_BALL_AMPLIFY_FILTERED", 
				L"EVE_COMBO_X_FIRE_BALL_SPECTRUM_FILTERED", L"EVE_COMBO_X_FIRE_BALL_INDUCTION_FILTERED", L"EVE_COMBO_X_FIRE_BALL_FUSION_FILTERED" );
#else
				m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_COMBO_X_FIRE_BALL_FILTERED", L"EVE_COMBO_X_FIRE_BALL_FILTERED" );
#endif
#endif EVE_ELECTRA

#else
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_X_FIRE_BALL", GetPowerRate() * m_fAttackPowerRateElectronBall, 
				vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate );
#endif INHERIT_FORCEDOWNRATE

#ifdef EVE_ELECTRA
			PlaySound( L"Eve_FireShot1.ogg" );
#endif EVE_ELECTRA
		}
		else
		{
			CreateNotEnoughMPEffect( vBonePos, 0.f, 0.f, 0.f );
		}
	}
#endif //BALANCE_CODE_NEMESIS_20121213

#ifdef EVE_ELECTRA
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( m_fPlaneZAngle, 2.0f, 240.f, 130.f );
	}
#endif EVE_ELECTRA


	if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_DASH_JUMP_COMBO_X_01 ) )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = 
			g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_DASH_JUMP_COMBO_X_01 ) );

		if( NULL != pSeq )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );
			if( true == GetIsRight() )
			{
				vBonePos += GetDirVector() * -30.f;
			}
			else
			{
				vBonePos -= GetDirVector() * -30.f;
			}
			vBonePos.y += 20.f;

			pSeq->SetPosition( vBonePos );
		}
		else
		{
			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_DASH_JUMP_COMBO_X_01, INVALID_PARTICLE_SEQUENCE_HANDLE );
		}
	}






	if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_DASH_JUMP_COMBO_X_02) )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = 
			g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_DASH_JUMP_COMBO_X_02 ) );

		if( NULL != pSeq )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );

			if( true == GetIsRight() )
			{
				vBonePos += GetDirVector() * 10.f;
			}
			else
			{
				vBonePos -= GetDirVector() * 10.f;
			}

			pSeq->SetPosition( vBonePos );
		}
		else
		{
			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_DASH_JUMP_COMBO_X_02, INVALID_PARTICLE_SEQUENCE_HANDLE );
		}
	}



	CommonFrameMove();

}


void CX2GUEve::ENSI_DASH_JUMP_COMBO_X_EventProcess()
{
#ifdef EVE_FIRST_CHANGE_JOB
	if( m_InputData.oneX == true && m_FrameDataFuture.stateParam.bEventFlagList[1] == false )
	{
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_EXOTIC_GEAR:
		case CX2Unit::UC_EVE_ARCHITECTURE:
		case CX2Unit::UC_EVE_CODE_NEMESIS:
		case CX2Unit::UC_EVE_CODE_EMPRESS:
#ifdef SERV_EVE_BATTLE_SERAPH
		case CX2Unit::UC_EVE_BATTLE_SERAPH:
#endif
			m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
			break;
		}
	}
	if( m_InputData.oneZ == true && m_FrameDataFuture.stateParam.bEventFlagList[0] == false )
	{
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_ARCHITECTURE:
		case CX2Unit::UC_EVE_CODE_EMPRESS:
#ifdef SERV_EVE_BATTLE_SERAPH
		case CX2Unit::UC_EVE_BATTLE_SERAPH:
#endif
			m_FrameDataFuture.stateParam.bEventFlagList[1] = true;
			break;
		}
	}
#else
	if( m_InputData.oneZ == true )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}
#endif EVE_FIRST_CHANGE_JOB

	if( true == IsOnSomethingFuture() )
	{
		//if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true )
		//{
		//	m_fCanNotJumpTime = 0.2f;
		//}
		StateChange( USI_JUMP_LANDING );
	}

#ifdef EVE_FIRST_CHANGE_JOB
	else if( m_FrameDataFuture.stateParam.bEventFlagList[1] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.33f )
	{
#ifdef SERV_EVE_BATTLE_SERAPH
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_ARCHITECTURE:
		case CX2Unit::UC_EVE_CODE_EMPRESS:
			StateChange( ENSI_DASH_JUMP_COMBO_XZ );
			break;
		case CX2Unit::UC_EVE_BATTLE_SERAPH:
			StateChange( ENSI_EBS_DASH_JUMP_COMBO_XZ );
			break;
		}
#else
		StateChange( ENSI_DASH_JUMP_COMBO_XZ );
#endif

	}
#endif EVE_FIRST_CHANGE_JOB

	CommonEventProcess();
}

#ifdef EVE_FIRST_CHANGE_JOB
void CX2GUEve::ENSI_DASH_JUMP_COMBO_XZ_Init()
{
	XSkinMeshReadyInBackground( L"Eve_AT_DashJumpComboXa_Mesh_G.X" );
	XSkinMeshReadyInBackground( L"Eve_Guardian_BladeWave01.X" );

	//TextureReadyInBackground( L"AT_ComboX3a_Tex.tga" );
}

void CX2GUEve::ENSI_DASH_JUMP_COMBO_XZ_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{		
		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_ARCHITECTURE:
		case CX2Unit::UC_EVE_CODE_EMPRESS:
			{
				CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;
				D3DXVECTOR3 vBonePos = GetPos();
				vBonePos.y += 290.f;

				pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_Eve_AT_DashJumpComboXa_Guardian", GetPos(), GetRotateDegree(), GetRotateDegree() );							

				CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Particle_Eve_AT_Combo01", vBonePos );
				if( NULL != pSeq )
				{
					pSeq->SetAddRotate( GetRotateDegree() );
					pSeq->SetAxisAngle( GetRotateDegree() );
					pSeq->SetLandPosition( GetLandPosition().y );
				}

				//m_vSummonedUnitBonePos = pMeshInst->GetXSkinAnim()->GetCloneFramePosition(L"Bip01_Neck");
				//m_vSummonedUnitBonePos += vBonePos;									
			}
			break;
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_vSummonedUnitBonePos = GetPos();
		m_vSummonedUnitBonePos.y += 150.f;

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_DASH_JUMP_COMBO_XZ", GetPowerRate(), m_vSummonedUnitBonePos, GetRotateDegree(), GetRotateDegree() );

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.15f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.15f ) == true && EventCheck( 0.15f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;

		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_Eve_AT_DashJumpComboXa_BladeWave01", m_vSummonedUnitBonePos, GetRotateDegree(), GetRotateDegree() );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_DASH_JUMP_COMBO_XZ_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		//if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true )
		//{
		//	m_fCanNotJumpTime = 0.2f;
		//}
		StateChange( USI_JUMP_LANDING );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_DASH_JUMP_COMBO_XZ_End()
{
	CommonStateEnd();
}
#endif

void CX2GUEve::ENSI_SI1_ILLUSION_STRIKE_Init()
{
	XSkinMeshReadyInBackground( L"Eve_IllusionStrike_Mesh01.X" );
	XSkinMeshReadyInBackground( L"Eve_IllusionStrike_Mesh02.X" );
	XSkinMeshReadyInBackground( L"Eve_IllusionStrike_Mesh03.X" );
	XSkinMeshReadyInBackground( L"Eve_IllusionStrike_Mesh04.X" );
	XSkinMeshReadyInBackground( L"Eve_IllusionStrike_Mesh05.X" );
	XSkinMeshReadyInBackground( L"Eve_IllusionStrike_Mesh06.X" );

}

void CX2GUEve::ENSI_SI1_ILLUSION_STRIKE_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 0 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vBonePos1 = GetBonePos( L"Bip01_L_Finger2" );
		D3DXVECTOR3 vBonePos2 = GetBonePos( L"Bip01_R_Finger2" );

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_IllusionStrike01", vBonePos1 );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_01, pSeq->GetHandle() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_IllusionStrike02", vBonePos2 );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_02, pSeq->GetHandle() );
		}



		CKTDXDeviceXSkinMesh* pSkinMesh1 = NULL;
		CKTDXDeviceXSkinMesh* pSkinMesh2 = NULL;	
		CKTDXDeviceXET* pXET = NULL;

		// 현재 장착하고 있는 무기 아이템 메시가 어떤 것인지 가져온다. 
		for( int i = 0; i < (int)m_ViewEqipList.size(); i++ )
		{
			CX2EqipPtr pCX2Eqip = m_ViewEqipList[i];
			if ( pCX2Eqip == NULL )
				continue;

			if( CX2Unit::EP_WEAPON_HAND != pCX2Eqip->GetEqipPos() )
				continue;

			if( NULL != pCX2Eqip->GetItem() &&
				NULL != pCX2Eqip->GetItem()->GetItemTemplet() 
                )
			{
				if( true == pCX2Eqip->GetItem()->GetItemTemplet()->GetFashion() )
				{
					pSkinMesh1 = pCX2Eqip->GetNormalModel(0);
					pSkinMesh2 = pCX2Eqip->GetNormalModel(1);
					pXET = pCX2Eqip->GetNormalTexChangeXET();
					break;
				}
				else
				{
					pSkinMesh1 = pCX2Eqip->GetNormalModel(0);
					pSkinMesh2 = pCX2Eqip->GetNormalModel(1);
					pXET = pCX2Eqip->GetNormalTexChangeXET();
				}
			}
		}

		// 이펙트에 무기 메시를 갈아끼운다
		D3DXVECTOR3 vPos = GetPos();
		WCHAR wszText[128] = L"";
		for( int i=1; i<7; i++ )
		{
			StringCchPrintfW( wszText, ARRAY_SIZE(wszText), L"EVE_ILLUSION_STRIKE_0%d", i );

			CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*) this, wszText,
				GetPowerRate(), vPos, 
				GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );




            CKTDGXMeshPlayer::CXMeshInstance *pEffectMainEffect = ( pEffect != NULL ) ? pEffect->GetMainEffect() : NULL;
			if( NULL == pEffectMainEffect ||
				NULL == pEffectMainEffect->GetXSkinAnim() )
				continue;

			CKTDGXSkinAnim* pSkinAnim = pEffectMainEffect->GetXSkinAnim();
			switch( i )
			{
			case 1:
			case 2:
			case 3:
				{
					if( NULL != pSkinMesh1 )
					{
						pSkinAnim->RemoveModelXSkinMesh( pSkinAnim->GetAnimXSkinMesh() );
						pSkinAnim->AddModelXSkinMesh( pSkinMesh1, NULL, NULL, pXET, false );
					}
				} break;

			case 4:
			case 5:
			case 6:
				{
					if( NULL != pSkinMesh2 )
					{
						pSkinAnim->RemoveModelXSkinMesh( pSkinAnim->GetAnimXSkinMesh() );
						pSkinAnim->AddModelXSkinMesh( pSkinMesh2, NULL, NULL, pXET, false );
					}
				} break;
			}
		} // for(i)


	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.63f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.63f ) == true && EventCheck( 0.63f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 120.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_IllusionStrike03", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}


		SetEnableAttackBox( L"Creature2", true );
		SetEnableAttackBox( L"Creature1", false );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.f ) == true && EventCheck( 1.f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		SetEnableAttackBox( L"Creature2", false );
		SetEnableAttackBox( L"Creature1", true );

		m_DamageData.hitUnitList.resize(0);
		m_DamageData.reActType = CX2DamageManager::RT_DOWN;
		m_DamageData.backSpeed = D3DXVECTOR2( 1500.f, 1000.f );
	}


	if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_01 ) )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = 
			g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_01 ) );

		if( NULL != pSeq )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger2" );
			pSeq->SetPosition( vBonePos );
		}
		else
		{
			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_01, INVALID_PARTICLE_SEQUENCE_HANDLE );
		}
	}


	if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_02 ) )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = 
			g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_02 ) );

		if( NULL != pSeq )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
			pSeq->SetPosition( vBonePos );
		}
		else
		{
			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_02, INVALID_PARTICLE_SEQUENCE_HANDLE );
		}
	}



	CommonFrameMove();
}

void CX2GUEve::ENSI_SI1_ILLUSION_STRIKE_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI1_ILLUSION_STRIKE_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 0 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vBonePos1 = GetBonePos( L"Bip01_L_Finger2" );
		D3DXVECTOR3 vBonePos2 = GetBonePos( L"Bip01_R_Finger2" );

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_IllusionStrike01", vBonePos1 );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_01, pSeq->GetHandle() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_IllusionStrike02", vBonePos2 );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_02, pSeq->GetHandle() );
		}



		CKTDXDeviceXSkinMesh* pSkinMesh1 = NULL;
		CKTDXDeviceXSkinMesh* pSkinMesh2 = NULL;	
		CKTDXDeviceXET* pXET = NULL;

		// 현재 장착하고 있는 무기 아이템 메시가 어떤 것인지 가져온다. 
		for( int i = 0; i < (int)m_ViewEqipList.size(); i++ )
		{
			CX2EqipPtr pCX2Eqip = m_ViewEqipList[i];
			if ( pCX2Eqip == NULL )
				continue;

			if( CX2Unit::EP_WEAPON_HAND != pCX2Eqip->GetEqipPos() )
				continue;

			if( NULL != pCX2Eqip->GetItem() &&
				NULL != pCX2Eqip->GetItem()->GetItemTemplet() 
                )
			{
				if( true == pCX2Eqip->GetItem()->GetItemTemplet()->GetFashion() )
				{
					pSkinMesh1 = pCX2Eqip->GetNormalModel(0);
					pSkinMesh2 = pCX2Eqip->GetNormalModel(1);
					pXET = pCX2Eqip->GetNormalTexChangeXET();
					break;
				}
				else
				{
					pSkinMesh1 = pCX2Eqip->GetNormalModel(0);
					pSkinMesh2 = pCX2Eqip->GetNormalModel(1);
					pXET = pCX2Eqip->GetNormalTexChangeXET();
				}
			}
		}

		// 이펙트에 무기 메시를 갈아끼운다
		D3DXVECTOR3 vPos = GetPos();
		WCHAR wszText[128] = L"";
		for( int i=1; i<7; i++ )
		{
			StringCchPrintfW( wszText, ARRAY_SIZE(wszText), L"EVE_ILLUSION_STRIKE_0%d", i );

			CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*) this, wszText,
				GetPowerRate(), vPos, 
				GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );





            CKTDGXMeshPlayer::CXMeshInstance *pEffectMainEffect = ( pEffect != NULL ) ? pEffect->GetMainEffect() : NULL;
			if( NULL == pEffectMainEffect ||
				NULL == pEffectMainEffect->GetXSkinAnim() )
				continue;

			CKTDGXSkinAnim* pSkinAnim = pEffectMainEffect->GetXSkinAnim();
			switch( i )
			{
			case 1:
			case 2:
			case 3:
				{
					if( NULL != pSkinMesh1 )
					{
						pSkinAnim->RemoveModelXSkinMesh( pSkinAnim->GetAnimXSkinMesh() );
						pSkinAnim->AddModelXSkinMesh( pSkinMesh1, NULL, NULL, pXET, false );
					}
				} break;

			case 4:
			case 5:
			case 6:
				{
					if( NULL != pSkinMesh2 )
					{
						pSkinAnim->RemoveModelXSkinMesh( pSkinAnim->GetAnimXSkinMesh() );
						pSkinAnim->AddModelXSkinMesh( pSkinMesh2, NULL, NULL, pXET, false );
					}
				} break;
			}
		} // for(i)


	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.63f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.63f ) == true && EventCheck( 0.63f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 120.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_IllusionStrike03", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}


		SetEnableAttackBox( L"Creature2", true );
		SetEnableAttackBox( L"Creature1", false );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.f ) == true && EventCheck( 1.f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		SetEnableAttackBox( L"Creature2", false );
		SetEnableAttackBox( L"Creature1", true );

		m_DamageData.hitUnitList.resize(0);
		m_DamageData.reActType = CX2DamageManager::RT_DOWN;
		m_DamageData.backSpeed = D3DXVECTOR2( 1500.f, 1000.f );
	}


	if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_01 ) )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = 
			g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_01 ) );

		if( NULL != pSeq )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger2" );
			pSeq->SetPosition( vBonePos );
		}
		else
		{
			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_01, INVALID_PARTICLE_SEQUENCE_HANDLE );
		}
	}


	if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_02 ) )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = 
			g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_02 ) );

		if( NULL != pSeq )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Finger2" );
			pSeq->SetPosition( vBonePos );
		}
		else
		{
			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STRIKE_02, INVALID_PARTICLE_SEQUENCE_HANDLE );
		}
	}



	CommonFrameMove();
}

void CX2GUEve::ENSI_SI1_ILLUSION_STRIKE_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI2_ILLUSION_STINGER_Init()
{
	XSkinMeshReadyInBackground( L"Eve_Sp2a_IllusionStinger_Mesh01.X" );
	XSkinMeshReadyInBackground( L"Eve_Sp2a_IllusionStinger_Mesh02.X" );
}



void CX2GUEve::ENSI_SI2_ILLUSION_STINGER_Start()
{
	CommonStateStart();

	m_ahMajorMeshInstance[MajorMID_IllusionStinger01] = INVALID_MESH_INSTANCE_HANDLE;
	m_ahMajorMeshInstance[MajorMID_IllusionStinger02] = INVALID_MESH_INSTANCE_HANDLE;

	SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_01, INVALID_PARTICLE_SEQUENCE_HANDLE );
	SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_02, INVALID_PARTICLE_SEQUENCE_HANDLE );
}

void CX2GUEve::ENSI_SI2_ILLUSION_STINGER_End()
{
	m_ahMajorMeshInstance[MajorMID_IllusionStinger01] = INVALID_MESH_INSTANCE_HANDLE;
	m_ahMajorMeshInstance[MajorMID_IllusionStinger02] = INVALID_MESH_INSTANCE_HANDLE;

	SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_01, INVALID_PARTICLE_SEQUENCE_HANDLE );
	SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_02, INVALID_PARTICLE_SEQUENCE_HANDLE );

	CommonStateEnd();
}




void CX2GUEve::ENSI_SI2_ILLUSION_STINGER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 1 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_vecBoneILLUSIONSTINGER1 = GetBonePos( L"Dummy2_Lhand" );
		m_vecBoneILLUSIONSTINGER2 = GetBonePos( L"Dummy1_Rhand" );

		D3DXVECTOR3 vRotDegree = GetRotateDegree();

		CX2DamageEffect::CEffect* pDamageEffect1 = g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*) this, L"EVE_ILLUSION_STINGER_01",
			GetPowerRate(), m_vecBoneILLUSIONSTINGER1, 
			vRotDegree, vRotDegree, m_FrameDataNow.unitCondition.landPosition.y );


		CX2DamageEffect::CEffect* pDamageEffect2 = g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*) this, L"EVE_ILLUSION_STINGER_02",
			GetPowerRate(), m_vecBoneILLUSIONSTINGER2, 
			vRotDegree, vRotDegree, m_FrameDataNow.unitCondition.landPosition.y );


		if( NULL != pDamageEffect1 )
		{
			m_ahMajorMeshInstance[MajorMID_IllusionStinger01] = pDamageEffect1->GetMainEffectHandle();
		}

		if( NULL != pDamageEffect2 )
		{
			m_ahMajorMeshInstance[MajorMID_IllusionStinger02] = pDamageEffect2->GetMainEffectHandle();
		}

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.26f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.26f ) == true && EventCheck( 0.26f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger1Nub" );

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_IllusionStrike03", vBonePos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_01, pSeq->GetHandle() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger1Nub" );

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_IllusionStinger02", vBonePos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_02, pSeq->GetHandle() );
		}

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.5f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.5f ) == true && EventCheck( 0.5f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 140.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_IllusionStrike03", vPos );
		//pSeq->SetAxisAngle( GetRotateDegree() );
		//pSeq->SetLandPosition( m_FrameDataNow.unitCondition.landPosition.y );



		// 소닉 붐
		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -100.f;
		}
		else
		{
			vPos -= GetDirVector() * -100.f;
		}
		vPos.y += 100.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DashWave01_Eve_DashAttack", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}



		// 작은 소닉 붐
		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -150.f;
		}
		else
		{
			vPos -= GetDirVector() * -150.f;
		}
		vPos.y += 100.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DashWave01_Eve_DashAttack_Small", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		UpDownCrashCamera( 3.f, 0.2f );

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.6f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.6f ) == true && EventCheck( 0.6f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		const float fEffTime[] = 
		{
			0.833f - 0.6f,
			0.9f - 0.6f,
			0.933f - 0.6f,
			1.033f - 0.6f,
			1.1f - 0.6f,
			1.133f - 0.6f,
			1.133f - 0.6f,
			1.233f - 0.6f,
			1.3f - 0.6f,
			1.4f - 0.6f,
			1.5f - 0.6f,
			1.566f - 0.6f,
			1.6f - 0.6f,
			1.633f - 0.6f,
			1.7f - 0.6f,
		};

		D3DXVECTOR3 vEffPos[] = 
		{ 
			D3DXVECTOR3(	135,	117,	0		),
			D3DXVECTOR3(	183,	62,		-45		),
			D3DXVECTOR3(	249,	149,	38		),
			D3DXVECTOR3(	241,	74,		-31		),
			D3DXVECTOR3(	327,	138,	0		),
			D3DXVECTOR3(	196,	158,	15		),
			D3DXVECTOR3(	306,	52,		38		),
			D3DXVECTOR3(	381,	194,	0		),
			D3DXVECTOR3(	373,	98,		-45		),
			D3DXVECTOR3(	475,	74,		-27		),
			D3DXVECTOR3(	446,	132,	39		),
			D3DXVECTOR3(	375,	33,		17		),
			D3DXVECTOR3(	488,	162,	-50		),
			D3DXVECTOR3(	534,	118,	21		),
			D3DXVECTOR3(	600,	100,	0		),
		};

		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO8 ) == true )
		{
			for(int i=0; i<ARRAY_SIZE( vEffPos ); ++i)
				vEffPos[i].x = ( vEffPos[i].x - 135.f) * 0.8f + 135.f;
		}

		D3DXVECTOR3 vRotDegree = GetRotateDegree();

		for( int i=0; i<ARRAY_SIZE( vEffPos ); i++ )
		{
			D3DXVECTOR3 vPos = GetPos();
			vPos.y += vEffPos[i].y;
			vPos += GetZVector() * vEffPos[i].z;
			if( true == GetIsRight() )
			{
				vPos += GetDirVector() * vEffPos[i].x;
			}
			else
			{
				vPos -= GetDirVector() * vEffPos[i].x;
			}

			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO8 ) == true )
				g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*) this, L"EVE_ILLUSION_STINGER_EXPLOSION_MEMO",
				GetPowerRate(), vPos, vRotDegree, vRotDegree, m_FrameDataNow.unitCondition.landPosition.y, true, fEffTime[i] );
			else
				g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*) this, L"EVE_ILLUSION_STINGER_EXPLOSION",
				GetPowerRate(), vPos, vRotDegree, vRotDegree, m_FrameDataNow.unitCondition.landPosition.y, true, fEffTime[i] );			

		}

	}




	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_IllusionStinger01] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_IllusionStinger01] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
#ifdef ADD_MEMO_1ST_CLASS //김창한
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO8 ) == true )
			{
				D3DXVECTOR3 vecDir = vBonePos - m_vecBoneILLUSIONSTINGER1;
				vecDir *= 0.8f;
				vBonePos = m_vecBoneILLUSIONSTINGER1 + vecDir;
			}
#endif //ADD_MEMO_1ST_CLASS
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_IllusionStinger01] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}


	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_IllusionStinger02] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_IllusionStinger02] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );
#ifdef ADD_MEMO_1ST_CLASS //김창한
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO8 ) == true )
			{
				D3DXVECTOR3 vecDir = vBonePos - m_vecBoneILLUSIONSTINGER2;
				vecDir *= 0.8f;
				vBonePos = m_vecBoneILLUSIONSTINGER2 + vecDir;
			}
#endif //ADD_MEMO_1ST_CLASS
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_IllusionStinger02] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}

	if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_01 ) )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = 
			g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_01 ) );

		if( NULL != pSeq )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger1Nub" );
			pSeq->SetPosition( vBonePos );
		}
		else
		{
			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_01, INVALID_PARTICLE_SEQUENCE_HANDLE );
		}
	}

	if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_02 ) )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = 
			g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_02 ) );

		if( NULL != pSeq )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger1Nub" );
			pSeq->SetPosition( vBonePos );
		}
		else
		{
			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_02, INVALID_PARTICLE_SEQUENCE_HANDLE );
		}
	}


	CommonFrameMove();

}

void CX2GUEve::ENSI_SI2_ILLUSION_STINGER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}


void CX2GUEve::ENSI_SI2_ILLUSION_STINGER_HYPER_Start()
{
	CommonStateStart();

	m_ahMajorMeshInstance[MajorMID_IllusionStinger01] = INVALID_MESH_INSTANCE_HANDLE;
	m_ahMajorMeshInstance[MajorMID_IllusionStinger02] = INVALID_MESH_INSTANCE_HANDLE;

	SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_01, INVALID_PARTICLE_SEQUENCE_HANDLE );
	SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_02, INVALID_PARTICLE_SEQUENCE_HANDLE );

}

void CX2GUEve::ENSI_SI2_ILLUSION_STINGER_HYPER_End()
{
	m_ahMajorMeshInstance[MajorMID_IllusionStinger01] = INVALID_MESH_INSTANCE_HANDLE;
	m_ahMajorMeshInstance[MajorMID_IllusionStinger02] = INVALID_MESH_INSTANCE_HANDLE;

	SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_01, INVALID_PARTICLE_SEQUENCE_HANDLE );
	SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_02, INVALID_PARTICLE_SEQUENCE_HANDLE );

	CommonStateEnd();
}



void CX2GUEve::ENSI_SI2_ILLUSION_STINGER_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 1 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_vecBoneILLUSIONSTINGER1 = GetBonePos( L"Dummy2_Lhand" );
		m_vecBoneILLUSIONSTINGER2 = GetBonePos( L"Dummy1_Rhand" );

		D3DXVECTOR3 vRotDegree = GetRotateDegree();

		CX2DamageEffect::CEffect* pDamageEffect1 = g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*) this, L"EVE_ILLUSION_STINGER_01",
			GetPowerRate(), m_vecBoneILLUSIONSTINGER1, 
			vRotDegree, vRotDegree, m_FrameDataNow.unitCondition.landPosition.y );


		CX2DamageEffect::CEffect* pDamageEffect2 = g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*) this, L"EVE_ILLUSION_STINGER_02",
			GetPowerRate(), m_vecBoneILLUSIONSTINGER2, 
			vRotDegree, vRotDegree, m_FrameDataNow.unitCondition.landPosition.y );


		if( NULL != pDamageEffect1 )
		{
			m_ahMajorMeshInstance[MajorMID_IllusionStinger01] = pDamageEffect1->GetMainEffectHandle();
		}

		if( NULL != pDamageEffect2 )
		{
			m_ahMajorMeshInstance[MajorMID_IllusionStinger02] = pDamageEffect2->GetMainEffectHandle();
		}

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.26f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.26f ) == true && EventCheck( 0.26f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger1Nub" );

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_IllusionStrike03", vBonePos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_01, pSeq->GetHandle() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger1Nub" );

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_IllusionStinger02", vBonePos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_02, pSeq->GetHandle() );
		}

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.5f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.5f ) == true && EventCheck( 0.5f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 140.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_IllusionStrike03", vPos );
		//pSeq->SetAxisAngle( GetRotateDegree() );
		//pSeq->SetLandPosition( m_FrameDataNow.unitCondition.landPosition.y );



		// 소닉 붐
		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -100.f;
		}
		else
		{
			vPos -= GetDirVector() * -100.f;
		}
		vPos.y += 100.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DashWave01_Eve_DashAttack", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}



		// 작은 소닉 붐
		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -150.f;
		}
		else
		{
			vPos -= GetDirVector() * -150.f;
		}
		vPos.y += 100.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"DashWave01_Eve_DashAttack_Small", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		UpDownCrashCamera( 3.f, 0.2f );

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.6f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.6f ) == true && EventCheck( 0.6f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		const float fEffTime[] = 
		{
			0.833f - 0.6f,
			0.9f - 0.6f,
			0.933f - 0.6f,
			1.033f - 0.6f,
			1.1f - 0.6f,
			1.133f - 0.6f,
			1.133f - 0.6f,
			1.233f - 0.6f,
			1.3f - 0.6f,
			1.4f - 0.6f,
			1.5f - 0.6f,
			1.566f - 0.6f,
			1.6f - 0.6f,
			1.633f - 0.6f,
			1.7f - 0.6f,
		};

		D3DXVECTOR3 vEffPos[] = 
		{ 
			D3DXVECTOR3(	135,	117,	0		),
			D3DXVECTOR3(	183,	62,		-45		),
			D3DXVECTOR3(	249,	149,	38		),
			D3DXVECTOR3(	241,	74,		-31		),
			D3DXVECTOR3(	327,	138,	0		),
			D3DXVECTOR3(	196,	158,	15		),
			D3DXVECTOR3(	306,	52,		38		),
			D3DXVECTOR3(	381,	194,	0		),
			D3DXVECTOR3(	373,	98,		-45		),
			D3DXVECTOR3(	475,	74,		-27		),
			D3DXVECTOR3(	446,	132,	39		),
			D3DXVECTOR3(	375,	33,		17		),
			D3DXVECTOR3(	488,	162,	-50		),
			D3DXVECTOR3(	534,	118,	21		),
			D3DXVECTOR3(	600,	100,	0		),
		};

		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO8 ) == true )
		{
			for(int i=0; i<ARRAY_SIZE( vEffPos ); ++i)
				vEffPos[i].x = ( vEffPos[i].x - 135.f) * 0.8f + 135.f;
		}

		D3DXVECTOR3 vRotDegree = GetRotateDegree();

		for( int i=0; i<ARRAY_SIZE( vEffPos ); i++ )
		{
			D3DXVECTOR3 vPos = GetPos();
			vPos.y += vEffPos[i].y;
			vPos += GetZVector() * vEffPos[i].z;
			if( true == GetIsRight() )
			{
				vPos += GetDirVector() * vEffPos[i].x;
			}
			else
			{
				vPos -= GetDirVector() * vEffPos[i].x;
			}

			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO8 ) == true )
				g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*) this, L"EVE_ILLUSION_STINGER_EXPLOSION_MEMO",
				GetPowerRate(), vPos, vRotDegree, vRotDegree, m_FrameDataNow.unitCondition.landPosition.y, true, fEffTime[i] );
			else
				g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*) this, L"EVE_ILLUSION_STINGER_EXPLOSION",
				GetPowerRate(), vPos, vRotDegree, vRotDegree, m_FrameDataNow.unitCondition.landPosition.y, true, fEffTime[i] );	
		}

	}




	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_IllusionStinger01] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_IllusionStinger01] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
#ifdef ADD_MEMO_1ST_CLASS //김창한
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO8 ) == true )
			{
				D3DXVECTOR3 vecDir = vBonePos - m_vecBoneILLUSIONSTINGER1;
				vecDir *= 0.8f;
				vBonePos = m_vecBoneILLUSIONSTINGER1 + vecDir;
			}
#endif //ADD_MEMO_1ST_CLASS
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_IllusionStinger01] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}


	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_IllusionStinger02] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_IllusionStinger02] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );
#ifdef ADD_MEMO_1ST_CLASS //김창한
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO8 ) == true )
			{
				D3DXVECTOR3 vecDir = vBonePos - m_vecBoneILLUSIONSTINGER2;
				vecDir *= 0.8f;
				vBonePos = m_vecBoneILLUSIONSTINGER2 + vecDir;
			}
#endif //ADD_MEMO_1ST_CLASS
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_IllusionStinger02] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}

	if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_01 ) )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = 
			g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_01 ) );

		if( NULL != pSeq )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger1Nub" );
			pSeq->SetPosition( vBonePos );
		}
		else
		{
			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_01, INVALID_PARTICLE_SEQUENCE_HANDLE );
		}
	}


	if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_02 ) )
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = 
			g_pX2Game->GetMajorParticle()->GetInstanceSequence( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_02 ) );

		if( NULL != pSeq )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger1Nub" );
			pSeq->SetPosition( vBonePos );
		}
		else
		{
			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_ILLUSION_STINGER_02, INVALID_PARTICLE_SEQUENCE_HANDLE );
		}
	}


	CommonFrameMove();
}

void CX2GUEve::ENSI_SI2_ILLUSION_STINGER_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI3_GENERATE_BLACKHOLE_Init()
{
	XSkinMeshReadyInBackground( L"Eve_Sp3aA_GBH_Mesh01.X" );
	XSkinMeshReadyInBackground( L"Eve_Sp3aA_GBH_Mesh02.X" );
	XSkinMeshReadyInBackground( L"Eve_Sp3aA_GBH_Mesh03.X" );

	TextureReadyInBackground( L"Black_Circle01.tga" );
	TextureReadyInBackground( L"SpreadLight02_Gray.tga" );
	TextureReadyInBackground( L"Eve_Sp3a_BackPack01.tga" );
}

void CX2GUEve::ENSI_SI3_GENERATE_BLACKHOLE_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos1 = GetBonePos( L"Bip01_Spine1" );
		D3DXVECTOR3 vBonePos2 = GetBonePos( L"Dummy2_Lhand" );
		D3DXVECTOR3 vBonePos3 = GetBonePos( L"Dummy1_Rhand" );

		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;

		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_Eve_Sp3aA_GBH01", vBonePos1, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
		{
			m_ahMajorMeshInstance[MajorMID_GenBlackHole01] = pMeshInst->GetHandle();
		}
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_Eve_Sp3aA_GBH02", vBonePos2, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
		{
			m_ahMajorMeshInstance[MajorMID_GenBlackHole02] = pMeshInst->GetHandle();
		}
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_Eve_Sp3aA_GBH03", vBonePos3, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
		{
			m_ahMajorMeshInstance[MajorMID_GenBlackHole03] = pMeshInst->GetHandle();
		}

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;


		// 경사진 라인맵에서 이펙트 위치가 라인따라 올라 가버리는 문제 때문에
		D3DXVECTOR3 vDirVector = GetDirVector();
		if( 0.f != vDirVector.y )
		{
			vDirVector.y = 0.f;
			D3DXVec3Normalize( &vDirVector, &vDirVector );
		}

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += vDirVector * 220.f;
		}
		else
		{
			vPos -= vDirVector * 220.f;
		}
		vPos.y += 120.f;


		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Black_Circle_Eve_Sp3a_GBH03", vPos );
		//if( NULL != pSeq ) // 빌보드 파티클의 경우 아래 코드 실행하면 안됨
		//{
		//	pSeq->SetAddRotate( GetRotateDegree() );
		//	pSeq->SetAxisAngle( GetRotateDegree() );
		//}

		float fPowerRate = GetPowerRate();
#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO1 ) == true )
		{
			fPowerRate *= 1.1f;
		}
#endif

		CX2DamageEffect::CEffect *pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*) this, L"EVE_GENERATE_BLACKHOLE",
			fPowerRate, vPos, 
			GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );

#ifdef SERV_SKILL_NOTE
		if(pEffect != NULL && GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO1 ) == true )
		{
			pEffect->GetBlackHoleData()->m_fDraggingRange *= 1.3f;
			pEffect->GetBlackHoleData()->m_fDraggingSpeed *= 1.3f;			
		}
#endif
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.2f ) == true && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vDirVector = GetDirVector();
		if( 0.f != vDirVector.y )
		{
			vDirVector.y = 0.f;
			D3DXVec3Normalize( &vDirVector, &vDirVector );
		}


		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += vDirVector * 220.f;
		}
		else
		{
			vPos -= vDirVector * 220.f;
		}
		vPos.y += 120.f;


		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Condenselight_Eve_Sp3a_GBH01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Condenselight_Eve_Sp3a_GBH02", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Condenselight_Eve_Sp3a_GBH03", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Spreadlight_Eve_Sp3a_GBH02", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Spinliner_Eve_Sp3a_GBH01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"BackLight_Light_Eve_GBH01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.57f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.57f ) == true && EventCheck( 0.57f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		UpDownCrashCamera( 4.f, 3.5f );	
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 2.65f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 2.65f ) == true && EventCheck( 2.65f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vDirVector = GetDirVector();
		if( 0.f != vDirVector.y )
		{
			vDirVector.y = 0.f;
			D3DXVec3Normalize( &vDirVector, &vDirVector );
		}

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += vDirVector * 220.f;
		}
		else
		{
			vPos -= vDirVector * 220.f;
		}
		vPos.y += 120.f;


		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_Sp3a_GBH01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"SpreadLight_Eve_Sp3a_GBH01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"SpreadLight_Eve_Sp3a_GBH03", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Particle_Eve_Sp3a_GBH02", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}


	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 3.27f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 3.27f ) == true && EventCheck( 3.27f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		UpDownCrashCamera( 10.f, 0.4f );	
	}





	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_GenBlackHole01] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_GenBlackHole01] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_GenBlackHole01] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}


	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_GenBlackHole02] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_GenBlackHole02] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_GenBlackHole02] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}

	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_GenBlackHole03] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_GenBlackHole03] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_GenBlackHole03] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}




	CommonFrameMove();
}

void CX2GUEve::ENSI_SI3_GENERATE_BLACKHOLE_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI3_GENERATE_BLACKHOLE_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos1 = GetBonePos( L"Bip01_Spine1" );
		D3DXVECTOR3 vBonePos2 = GetBonePos( L"Dummy2_Lhand" );
		D3DXVECTOR3 vBonePos3 = GetBonePos( L"Dummy1_Rhand" );


		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;

		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_Eve_Sp3aA_GBH01", vBonePos1, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
		{
			m_ahMajorMeshInstance[MajorMID_GenBlackHole01] = pMeshInst->GetHandle();
		}
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_Eve_Sp3aA_GBH02", vBonePos2, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
		{
			m_ahMajorMeshInstance[MajorMID_GenBlackHole02] = pMeshInst->GetHandle();
		}
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_Eve_Sp3aA_GBH03", vBonePos3, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
		{
			m_ahMajorMeshInstance[MajorMID_GenBlackHole03] = pMeshInst->GetHandle();
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;


		D3DXVECTOR3 vDirVector = GetDirVector();
		if( 0.f != vDirVector.y )
		{
			vDirVector.y = 0.f;
			D3DXVec3Normalize( &vDirVector, &vDirVector );
		}

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += vDirVector * 220.f;
		}
		else
		{
			vPos -= vDirVector * 220.f;
		}
		vPos.y += 120.f;


		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Black_Circle_Eve_Sp3a_GBH03", vPos );
		//if( NULL != pSeq ) // 빌보드 파티클의 경우 아래 코드 실행하면 안됨
		//{
		//	pSeq->SetAddRotate( GetRotateDegree() );
		//	pSeq->SetAxisAngle( GetRotateDegree() );
		//}

		float fPowerRate = GetPowerRate();
#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO1 ) == true )
		{
			fPowerRate *= 1.1f;
		}
#endif
		CX2DamageEffect::CEffect *pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*) this, L"EVE_GENERATE_BLACKHOLE_HYPER",
			fPowerRate, vPos, 
			GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );

#ifdef SERV_SKILL_NOTE
		if(pEffect != NULL && GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO1 ) == true )
		{
			pEffect->GetBlackHoleData()->m_fDraggingRange *= 1.3f;
			pEffect->GetBlackHoleData()->m_fDraggingSpeed *= 1.3f;
		}
#endif
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.2f ) == true && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vDirVector = GetDirVector();
		if( 0.f != vDirVector.y )
		{
			vDirVector.y = 0.f;
			D3DXVec3Normalize( &vDirVector, &vDirVector );
		}


		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += vDirVector * 220.f;
		}
		else
		{
			vPos -= vDirVector * 220.f;
		}
		vPos.y += 120.f;


		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Condenselight_Eve_Sp3a_GBH01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Condenselight_Eve_Sp3a_GBH02", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Condenselight_Eve_Sp3a_GBH03", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Spreadlight_Eve_Sp3a_GBH02", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Spinliner_Eve_Sp3a_GBH01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"BackLight_Light_Eve_GBH01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.57f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.57f ) == true && EventCheck( 0.57f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		UpDownCrashCamera( 4.f, 3.5f );	
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 2.65f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 2.65f ) == true && EventCheck( 2.65f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vDirVector = GetDirVector();
		if( 0.f != vDirVector.y )
		{
			vDirVector.y = 0.f;
			D3DXVec3Normalize( &vDirVector, &vDirVector );
		}

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += vDirVector * 220.f;
		}
		else
		{
			vPos -= vDirVector * 220.f;
		}
		vPos.y += 120.f;


		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_Sp3a_GBH01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"SpreadLight_Eve_Sp3a_GBH01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"SpreadLight_Eve_Sp3a_GBH03", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Particle_Eve_Sp3a_GBH02", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}


	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 3.27f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 3.27f ) == true && EventCheck( 3.27f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		UpDownCrashCamera( 10.f, 0.4f );	
	}





	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_GenBlackHole01] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_GenBlackHole01] );
		if( NULL != pMeshInst )

		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_GenBlackHole01] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}


	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_GenBlackHole02] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_GenBlackHole02] );
		if( NULL != pMeshInst )

		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_GenBlackHole02] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}

	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_GenBlackHole03] )
	{

		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_GenBlackHole03] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_GenBlackHole03] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SI3_GENERATE_BLACKHOLE_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}







void CX2GUEve::ENSI_SI1_DIMENSION_LINK_Init()
{
	XSkinMeshReadyInBackground( L"Spin_Liner02.X" );
	TextureReadyInBackground( L"Eve_Sp1a_SumonCircle01.tga" );
	TextureReadyInBackground( L"MagicsquareLight02_Red.tga" );



	XSkinMeshReadyInBackground( L"Motion_Nasod_Watch.X" );

}

void CX2GUEve::ENSI_SI1_DIMENSION_LINK_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 0 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.2f ) == true && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -110.f;
		}
		else
		{
			vPos -= GetDirVector() * -110.f;
		}

		vPos.y += 110.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp1a_Spinliner01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotDegree1 = GetRotateDegree();
			D3DXVECTOR3 vRotDegree2 = GetRotateDegree();
			vRotDegree1 += D3DXVECTOR3( -180, 20, 90 );
			vRotDegree2 += D3DXVECTOR3( 180, 20, 90 );

			CKTDGParticleSystem::CParticleEvent_Rotate* pEventRotate = new CKTDGParticleSystem::CParticleEvent_Rotate();
			pEventRotate->SetActualTime( CMinMax<float>( 0.f, 0.f ) );
			pEventRotate->SetRotate( CMinMax<D3DXVECTOR3>( vRotDegree1, vRotDegree2 ) );

			pSeq->m_EventList.push_back( pEventRotate );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -100.f;
		}
		else
		{
			vPos -= GetDirVector() * -100.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp1a_Magicsquare01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotateDegree = GetRotateDegree();
			vRotateDegree += D3DXVECTOR3( 0, -70, -45 );

			pSeq->SetAddRotate( vRotateDegree );
			pSeq->SetAxisAngle( vRotateDegree );
		}


		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 90.f;
		}
		else
		{
			vPos -= GetDirVector() * 90.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp1a_PinLight01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}





		// 기존에 소환된 몬스터가 있으면 자폭 시키고 다시 소환한다
		SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE );
#ifdef SERV_SKILL_NOTE
		SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE_MEMO );
#endif


		// 새로운 몬스터 소환
		if( true == g_pX2Game->IsHost() )
		{
			vPos = GetPos();
			//if( true == GetIsRight() )
			//{
			//	vPos += GetDirVector() * 40.f;
			//}
			//else
			//{
			//	vPos -= GetDirVector() * 40.f;
			//}


			int iNewLineIndex = m_FrameDataNow.syncData.lastTouchLineIndex;
			D3DXVECTOR3 vNewPos( 0, 0, 0 );
			if( NULL != g_pX2Game->GetLineMap() )
			{
				vNewPos = g_pX2Game->GetLineMap()->GetLandPosition( vPos, LINE_RADIUS, &iNewLineIndex );
				if( -1 != iNewLineIndex )
				{
					vPos.x = vNewPos.x;
					vPos.y = max( vPos.y, vNewPos.y );
					vPos.z = vNewPos.z;
				}
			}


			int iHyperMode = 0;
#ifdef SERV_SKILL_NOTE
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO2 ) == true )
			{
#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
				// 이브 소환물 스크립트가 하나로 통일되고 키코드 값을 통해 메모 여부가 결정됨
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_NASOD_WATCH_EVE, iHyperMode, true, vPos, 
					GetIsRight(), 0.f, true, 1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
#else // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_NASOD_WATCH_EVE_MEMO, iHyperMode, true, vPos, 
					GetIsRight(), 0.f, true, 1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
				
			}
			else
			{
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_NASOD_WATCH_EVE, iHyperMode, true, vPos, 
					GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
			}
#else
			g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_NASOD_WATCH_EVE, iHyperMode, true, vPos, 
				GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
#endif
		}

		m_fSummonedLifeTime = 20.f;
		m_timerSummoned.restart();

	}

	CommonFrameMove();

}

void CX2GUEve::ENSI_SI1_DIMENSION_LINK_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI1_DIMENSION_LINK_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 0 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.2f ) == true && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -110.f;
		}
		else
		{
			vPos -= GetDirVector() * -110.f;
		}

		vPos.y += 110.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp1a_Spinliner01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotDegree1 = GetRotateDegree();
			D3DXVECTOR3 vRotDegree2 = GetRotateDegree();
			vRotDegree1 += D3DXVECTOR3( -180, 20, 90 );
			vRotDegree2 += D3DXVECTOR3( 180, 20, 90 );

			CKTDGParticleSystem::CParticleEvent_Rotate* pEventRotate = new CKTDGParticleSystem::CParticleEvent_Rotate();
			pEventRotate->SetActualTime( CMinMax<float>( 0.f, 0.f ) );
			pEventRotate->SetRotate( CMinMax<D3DXVECTOR3>( vRotDegree1, vRotDegree2 ) );

			pSeq->m_EventList.push_back( pEventRotate );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -100.f;
		}
		else
		{
			vPos -= GetDirVector() * -100.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp1a_Magicsquare01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotateDegree = GetRotateDegree();
			vRotateDegree += D3DXVECTOR3( 0, -70, -45 );

			pSeq->SetAddRotate( vRotateDegree );
			pSeq->SetAxisAngle( vRotateDegree );
		}


		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 90.f;
		}
		else
		{
			vPos -= GetDirVector() * 90.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp1a_PinLight01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}





		// 기존에 소환된 몬스터가 있으면 자폭 시키고 다시 소환한다
		SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE );
#ifdef SERV_SKILL_NOTE
		SetSelfDestructSummonedNPC( CX2UnitManager::NUI_NASOD_WATCH_EVE_MEMO );
#endif


		// 새로운 몬스터 소환
		if( true == g_pX2Game->IsHost() )
		{
			vPos = GetPos();
			//if( true == GetIsRight() )
			//{
			//	vPos += GetDirVector() * 40.f;
			//}
			//else
			//{
			//	vPos -= GetDirVector() * 40.f;
			//}


			int iNewLineIndex = m_FrameDataNow.syncData.lastTouchLineIndex;
			D3DXVECTOR3 vNewPos( 0, 0, 0 );
			if( NULL != g_pX2Game->GetLineMap() )
			{
				vNewPos = g_pX2Game->GetLineMap()->GetLandPosition( vPos, LINE_RADIUS, &iNewLineIndex );
				if( -1 != iNewLineIndex )
				{
					vPos.x = vNewPos.x;
					vPos.y = max( vPos.y, vNewPos.y );
					vPos.z = vNewPos.z;
				}
			}



			int iHyperMode = 1;
#ifdef SERV_SKILL_NOTE
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO2 ) == true )
			{
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_NASOD_WATCH_EVE_MEMO, iHyperMode, true, vPos, 
					GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
			}
			else
			{
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_NASOD_WATCH_EVE, iHyperMode, true, vPos, 
					GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
			}
#else
			g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_NASOD_WATCH_EVE, iHyperMode, true, vPos, 
				GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
#endif

		}

		m_fSummonedLifeTime = 20.f;
		m_timerSummoned.restart();

	}

	CommonFrameMove();


}

void CX2GUEve::ENSI_SI1_DIMENSION_LINK_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI2_DIMENSION_LINK_BLADER_Init()
{
	XSkinMeshReadyInBackground( L"Spin_Liner02.X" );
	TextureReadyInBackground( L"Eve_Sp1a_SumonCircle01.tga" );
	TextureReadyInBackground( L"MagicsquareLight02_Red.tga" );



	XSkinMeshReadyInBackground( L"Motion_Wally9th_Eve.x" );

}

void CX2GUEve::ENSI_SI2_DIMENSION_LINK_BLADER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 1 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -130.f;
		}
		else
		{
			vPos -= GetDirVector() * -130.f;
		}
		vPos.y += 110.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_Spinliner01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotDegree1 = GetRotateDegree();
			D3DXVECTOR3 vRotDegree2 = GetRotateDegree();
			vRotDegree1 += D3DXVECTOR3( -180, 20, 90 );
			vRotDegree2 += D3DXVECTOR3( 180, 20, 90 );

			CKTDGParticleSystem::CParticleEvent_Rotate* pEventRotate = new CKTDGParticleSystem::CParticleEvent_Rotate();
			pEventRotate->SetActualTime( CMinMax<float>( 0.f, 0.f ) );
			pEventRotate->SetRotate( CMinMax<D3DXVECTOR3>( vRotDegree1, vRotDegree2 ) );

			pSeq->m_EventList.push_back( pEventRotate );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.5f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.5f ) == true && EventCheck( 0.5f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -120.f;
		}
		else
		{
			vPos -= GetDirVector() * -120.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_Magicsquare01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotateDegree = GetRotateDegree();
			vRotateDegree += D3DXVECTOR3( 0, -70, -45 );

			pSeq->SetAddRotate( vRotateDegree );
			pSeq->SetAxisAngle( vRotateDegree );
		}


		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 70.f;
		}
		else
		{
			vPos -= GetDirVector() * 70.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_PinLight01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.8f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.8f ) == true && EventCheck( 0.8f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 110.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_Light01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}



		if( true == g_pX2Game->IsHost() )
		{
			vPos = GetPos();
			//if( true == GetIsRight() )
			//{
			//	vPos += GetDirVector() * 100.f;
			//}
			//else
			//{
			//	vPos -= GetDirVector() * 100.f;
			//}		



			int iNewLineIndex = m_FrameDataNow.syncData.lastTouchLineIndex;
			D3DXVECTOR3 vNewPos( 0, 0, 0 );
			if( NULL != g_pX2Game->GetLineMap() )
			{
				vNewPos = g_pX2Game->GetLineMap()->GetLandPosition( vPos, LINE_RADIUS, &iNewLineIndex );
				if( -1 != iNewLineIndex )
				{
					vPos.x = vNewPos.x;
					vPos.y = max( vPos.y, vNewPos.y );
					vPos.z = vNewPos.z;

				}
			}



			int iHyperMode = 0;
			g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_WALLY_9TH_EVE, iHyperMode, true, vPos, 
				GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
		}

	}

	CommonFrameMove();

}

void CX2GUEve::ENSI_SI2_DIMENSION_LINK_BLADER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI2_DIMENSION_LINK_BLADER_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 1 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -130.f;
		}
		else
		{
			vPos -= GetDirVector() * -130.f;
		}
		vPos.y += 110.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_Spinliner01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotDegree1 = GetRotateDegree();
			D3DXVECTOR3 vRotDegree2 = GetRotateDegree();
			vRotDegree1 += D3DXVECTOR3( -180, 20, 90 );
			vRotDegree2 += D3DXVECTOR3( 180, 20, 90 );

			CKTDGParticleSystem::CParticleEvent_Rotate* pEventRotate = new CKTDGParticleSystem::CParticleEvent_Rotate();
			pEventRotate->SetActualTime( CMinMax<float>( 0.f, 0.f ) );
			pEventRotate->SetRotate( CMinMax<D3DXVECTOR3>( vRotDegree1, vRotDegree2 ) );

			pSeq->m_EventList.push_back( pEventRotate );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.5f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.5f ) == true && EventCheck( 0.5f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -120.f;
		}
		else
		{
			vPos -= GetDirVector() * -120.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_Magicsquare01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotateDegree = GetRotateDegree();
			vRotateDegree += D3DXVECTOR3( 0, -70, -45 );

			pSeq->SetAddRotate( vRotateDegree );
			pSeq->SetAxisAngle( vRotateDegree );
		}


		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 70.f;
		}
		else
		{
			vPos -= GetDirVector() * 70.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_PinLight01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.8f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.8f ) == true && EventCheck( 0.8f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 110.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_Light01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}



		if( true == g_pX2Game->IsHost() )
		{
			vPos = GetPos();
			//if( true == GetIsRight() )
			//{
			//	vPos += GetDirVector() * 100.f;
			//}
			//else
			//{
			//	vPos -= GetDirVector() * 100.f;
			//}		



			int iNewLineIndex = m_FrameDataNow.syncData.lastTouchLineIndex;
			D3DXVECTOR3 vNewPos( 0, 0, 0 );
			if( NULL != g_pX2Game->GetLineMap() )
			{
				vNewPos = g_pX2Game->GetLineMap()->GetLandPosition( vPos, LINE_RADIUS, &iNewLineIndex );
				if( -1 != iNewLineIndex )
				{
					vPos.x = vNewPos.x;
					vPos.y = max( vPos.y, vNewPos.y );
					vPos.z = vNewPos.z;

				}
			}



			int iHyperMode = 1;
			g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_WALLY_9TH_EVE, iHyperMode, true, vPos, 
				GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
		}

	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SI2_DIMENSION_LINK_BLADER_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI3_DIMENSION_LINK_GUARDIAN_Init()
{
	XSkinMeshReadyInBackground( L"Spin_Liner02.X" );
	TextureReadyInBackground( L"Eve_Sp1a_SumonCircle01.tga" );
	TextureReadyInBackground( L"MagicsquareLight02_Red.tga" );

	XSkinMeshReadyInBackground( L"Motion_Nasod_Element_Fire_Eve.x" );
}

void CX2GUEve::ENSI_SI3_DIMENSION_LINK_GUARDIAN_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.5f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.5f ) == true && EventCheck( 0.5f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 140.f;
		}
		else
		{
			vPos -= GetDirVector() * 140.f;
		}
		vPos.y += 2.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp3a_Magicsquare01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.6f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.6f ) == true && EventCheck( 0.6f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 140.f;
		}
		else
		{
			vPos -= GetDirVector() * 140.f;
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp3a_Spinliner01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}


		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 140.f;
		}
		else
		{
			vPos -= GetDirVector() * 140.f;
		}
		vPos.y += 230.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp3a_PinLight01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.66f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.66f ) == true && EventCheck( 0.66f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 140.f;
		}
		else
		{
			vPos -= GetDirVector() * 140.f;
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp3a_Light01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}



		if( true == g_pX2Game->IsHost() )
		{


			vPos = GetPos();
			if( true == GetIsRight() )
			{
				vPos += GetDirVector() * 150.f;
			}
			else
			{
				vPos -= GetDirVector() * 150.f;
			}		


			int iNewLineIndex = m_FrameDataNow.syncData.lastTouchLineIndex;
			D3DXVECTOR3 vNewPos( 0, 0, 0 );
			if( NULL != g_pX2Game->GetLineMap() )
			{
				vNewPos = g_pX2Game->GetLineMap()->GetLandPosition( vPos, LINE_RADIUS, &iNewLineIndex );
				if( -1 != iNewLineIndex )
				{
					vPos.x = vNewPos.x;
					vPos.y = max( vPos.y, vNewPos.y );
					vPos.z = vNewPos.z;
				}
			}


			int iHyperMode = 0;
			g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_NASOD_ELEMENT_FIRE_EVE, iHyperMode, true, vPos, 
				GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
		}

	}

	CommonFrameMove();

}

void CX2GUEve::ENSI_SI3_DIMENSION_LINK_GUARDIAN_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI3_DIMENSION_LINK_GUARDIAN_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.5f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.5f ) == true && EventCheck( 0.5f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 140.f;
		}
		else
		{
			vPos -= GetDirVector() * 140.f;
		}
		vPos.y += 2.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp3a_Magicsquare01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.6f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.6f ) == true && EventCheck( 0.6f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 140.f;
		}
		else
		{
			vPos -= GetDirVector() * 140.f;
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp3a_Spinliner01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}


		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 140.f;
		}
		else
		{
			vPos -= GetDirVector() * 140.f;
		}
		vPos.y += 230.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp3a_PinLight01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.66f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.66f ) == true && EventCheck( 0.66f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 140.f;
		}
		else
		{
			vPos -= GetDirVector() * 140.f;
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp3a_Light01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}



		if( true == g_pX2Game->IsHost() )
		{


			vPos = GetPos();
			if( true == GetIsRight() )
			{
				vPos += GetDirVector() * 150.f;
			}
			else
			{
				vPos -= GetDirVector() * 150.f;
			}		



			int iNewLineIndex = m_FrameDataNow.syncData.lastTouchLineIndex;
			D3DXVECTOR3 vNewPos( 0, 0, 0 );
			if( NULL != g_pX2Game->GetLineMap() )
			{
				vNewPos = g_pX2Game->GetLineMap()->GetLandPosition( vPos, LINE_RADIUS, &iNewLineIndex );
				if( -1 != iNewLineIndex )
				{
					vPos.x = vNewPos.x;
					vPos.y = max( vPos.y, vNewPos.y );
					vPos.z = vNewPos.z;
				}
			}



			int iHyperMode = 1;
			g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_NASOD_ELEMENT_FIRE_EVE, iHyperMode, true, vPos, 
				GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
		}

	}

	CommonFrameMove();

}

void CX2GUEve::ENSI_SI3_DIMENSION_LINK_GUARDIAN_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

/** @function : COMMON_BUFF_FrameMove
@brief : 공통적으로 쓰는 버프 스킬의 FrameMove
*/
/*virtual*/ void CX2GUEve::COMMON_BUFF_FrameMove()
{
#ifndef UPGRADE_SKILL_SYSTEM_2013 // 공통 스킬 개편, 김종훈
	// 각성 인지 아닌지에 따라 World색 변경
	ChangeWorldColorByHyperMode();
	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 0 );
#endif // UPGRADE_SKILL_SYSTEM_2013 // 공통 스킬 개편, 김종훈


#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.83f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.83f ) == true && EventCheck( 0.83f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		PlayCommonBuffMinorParticle();
		UpDownCrashCamera( 30.0f, 0.4f );
		g_pKTDXApp->GetDGManager()->ClearScreen();

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.85f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.85f ) == true && EventCheck( 0.85f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		int	iSkillSlotIndex = 0;
		bool bSlotB = false;

		if ( true == GetSkillSlotIndexUsed( iSkillSlotIndex, bSlotB ) )
		{
			const CX2Unit::UnitData* pUnitData = &GetUnit()->GetUnitData();

			const CX2UserSkillTree::SkillSlotData* pSkillSlotData = pUnitData->m_UserSkillTree.GetSkillSlot( iSkillSlotIndex, bSlotB );
			CX2SkillTree::SKILL_ID eSkillID = CX2SkillTree::SI_NONE;

			if( NULL != pSkillSlotData )
				eSkillID = pSkillSlotData->m_eID;

			ProcessAcceleraterBuff( eSkillID, IsHyperState() );
		}
	}

	CommonFrameMove();
}

// 소환된 몬스터가 있으면 자폭 시킨다
void CX2GUEve::SetSelfDestructSummonedNPC( CX2UnitManager::NPC_UNIT_ID eNPCID /*= CX2UnitManager::NUI_NONE*/ )
{
	if( NULL == g_pX2Game )
		return; 


	for( int i=0; i<g_pX2Game->GetUnitNum(); i++ )
	{
		CX2GameUnit* pUnit = g_pX2Game->GetUnit( i );
		if( NULL == pUnit )
			continue;

		if( CX2GameUnit::GUT_NPC != pUnit->GetGameUnitType() )
			continue;


		CX2GUNPC *pNPC = (CX2GUNPC*) pUnit;
		if( CX2UnitManager::NUI_NONE != eNPCID &&
			pNPC->GetNPCTemplet().m_nNPCUnitID != eNPCID )
		{
			continue;
		}

		if( pNPC->GetNowHp() <= 0.f )
			continue;

		// 이미 자폭중이면 
		if( true == pNPC->GetSelfDestruction() )
			continue;


		if( NULL != pNPC->GetNPCAI() &&
			CX2NPCAI::NAT_ALLY == pNPC->GetNPCAI()->GetAIType() )
		{
			CX2AllyNPCAI* pAllyAI = (CX2AllyNPCAI*) pNPC->GetNPCAI();
			if( GetUnitUID() == pAllyAI->GetAllyUnitUID() )
			{
#ifdef NEW_SKILL_2010_11
				switch ( eNPCID )
				{
				case CX2UnitManager::NUI_NASOD_WATCH_EVE:
#ifdef SERV_SKILL_NOTE
				case CX2UnitManager::NUI_NASOD_WATCH_EVE_MEMO:
#endif
					pNPC->StartSelfDestruction( 3.f );
					pNPC->AttachParticle_LUA( true, "CountDown3", "Bip01_Head", D3DXVECTOR3( 0, 80, 0 ) );
					break;
				case CX2UnitManager::NUI_ATOMIC_SHIELD_EVE:
					pNPC->StartSelfDestruction( 0.f );
					break;
#ifdef FINALITY_SKILL_SYSTEM //김창한
				case CX2UnitManager::NUI_SI_HA_FERDINAND:
					{	
						pNPC->StartSelfDestruction( 0.f );
						ResetLinkOverChargeIllusion();
					}
					break;
#endif //FINALITY_SKILL_SYSTEM
				}
#else
				pNPC->StartSelfDestruction( 3.f );
				pNPC->AttachParticle_LUA( true, "CountDown3", "Bip01_Head", D3DXVECTOR3( 0, 80, 0 ) );
#endif NEW_SKILL_2010_11
				//}} JHKang / 강정훈 / 2010/11/29
			}
		}
	}
}


// 소환된 몬스터 캐릭터 위치로 데려온다
void CX2GUEve::CallSummonedNPC( CX2UnitManager::NPC_UNIT_ID eNPCID /*= CX2UnitManager::NUI_NONE*/ )
{
	if( NULL == g_pX2Game )
		return; 


	for( int i=0; i<g_pX2Game->GetUnitNum(); i++ )
	{
		CX2GameUnit* pUnit = g_pX2Game->GetUnit( i );
		if( NULL == pUnit )
			continue;

		if( CX2GameUnit::GUT_NPC != pUnit->GetGameUnitType() )
			continue;

		CX2GUNPC *pNPC = (CX2GUNPC*) pUnit;

		if( CX2UnitManager::NUI_NONE != eNPCID &&
			pNPC->GetNPCTemplet().m_nNPCUnitID != eNPCID )
		{
			continue;
		}

		if( pNPC->GetNowHp() <= 0.f )
			continue;

		if( NULL != pNPC->GetNPCAI() &&
			CX2NPCAI::NAT_ALLY == pNPC->GetNPCAI()->GetAIType() )
		{
			CX2AllyNPCAI* pAllyAI = (CX2AllyNPCAI*) pNPC->GetNPCAI();
			if( GetUnitUID() == pAllyAI->GetAllyUnitUID() )
			{
				D3DXVECTOR3 vPos = GetPos();
				pNPC->SetPosition( vPos, GetIsRight() );
			}
		}
	}
}

void CX2GUEve::ResetMegaEletronCharge()
{
	if( m_sMegaElectronBallData.m_bEnable == true )
		m_sMegaElectronBallData.Reset(false, &AccessFutureFrameData());
}

#ifdef EVE_FIRST_CHANGE_JOB
void CX2GUEve::ENSI_SI1_AT_SURFACE_CUTING_Init()
{
	XSkinMeshReadyInBackground( L"Motion_Guardian_Eve.x" );
}

void CX2GUEve::ENSI_SI1_AT_SURFACE_CUTING_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 0 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.2f ) == true && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -110.f;
		}
		else
		{
			vPos -= GetDirVector() * -110.f;
		}

		vPos.y += 110.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp1a_Spinliner01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotDegree1 = GetRotateDegree();
			D3DXVECTOR3 vRotDegree2 = GetRotateDegree();
			vRotDegree1 += D3DXVECTOR3( -180, 20, 90 );
			vRotDegree2 += D3DXVECTOR3( 180, 20, 90 );

			CKTDGParticleSystem::CParticleEvent_Rotate* pEventRotate = new CKTDGParticleSystem::CParticleEvent_Rotate();
			pEventRotate->SetActualTime( CMinMax<float>( 0.f, 0.f ) );
			pEventRotate->SetRotate( CMinMax<D3DXVECTOR3>( vRotDegree1, vRotDegree2 ) );

			pSeq->m_EventList.push_back( pEventRotate );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -100.f;
		}
		else
		{
			vPos -= GetDirVector() * -100.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp1a_Magicsquare01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotateDegree = GetRotateDegree();
			vRotateDegree += D3DXVECTOR3( 0, -70, -45 );

			pSeq->SetAddRotate( vRotateDegree );
			pSeq->SetAxisAngle( vRotateDegree );
		}


		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 90.f;
		}
		else
		{
			vPos -= GetDirVector() * 90.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp1a_PinLight01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}


		// 새로운 몬스터 소환
		if( true == g_pX2Game->IsHost() )
		{
			vPos = GetPos();
			//if( true == GetIsRight() )
			//{
			//	vPos += GetDirVector() * 40.f;
			//}
			//else
			//{
			//	vPos -= GetDirVector() * 40.f;
			//}


			int iNewLineIndex = m_FrameDataNow.syncData.lastTouchLineIndex;
			D3DXVECTOR3 vNewPos( 0, 0, 0 );
			if( NULL != g_pX2Game->GetLineMap() )
			{
				vNewPos = g_pX2Game->GetLineMap()->GetLandPosition( vPos, LINE_RADIUS, &iNewLineIndex );
				if( -1 != iNewLineIndex )
				{
					vPos.x = vNewPos.x;
					vPos.y = max( vPos.y, vNewPos.y );
					vPos.z = vNewPos.z;
				}
			}




			int iHyperMode = 0;
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO10 ) == true )
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_GUARDIAN_SP1_EVE_MEMO, iHyperMode, true, vPos, 
				GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
			else
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_GUARDIAN_SP1_EVE, iHyperMode, true, vPos, 
				GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
		}

		m_fSummonedLifeTime = 20.f;
		m_timerSummoned.restart();

	}

	CommonFrameMove();


}

void CX2GUEve::ENSI_SI1_AT_SURFACE_CUTING_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI1_AT_SURFACE_CUTING_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 0 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.2f ) == true && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -110.f;
		}
		else
		{
			vPos -= GetDirVector() * -110.f;
		}

		vPos.y += 110.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp1a_Spinliner01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotDegree1 = GetRotateDegree();
			D3DXVECTOR3 vRotDegree2 = GetRotateDegree();
			vRotDegree1 += D3DXVECTOR3( -180, 20, 90 );
			vRotDegree2 += D3DXVECTOR3( 180, 20, 90 );

			CKTDGParticleSystem::CParticleEvent_Rotate* pEventRotate = new CKTDGParticleSystem::CParticleEvent_Rotate();
			pEventRotate->SetActualTime( CMinMax<float>( 0.f, 0.f ) );
			pEventRotate->SetRotate( CMinMax<D3DXVECTOR3>( vRotDegree1, vRotDegree2 ) );

			pSeq->m_EventList.push_back( pEventRotate );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -100.f;
		}
		else
		{
			vPos -= GetDirVector() * -100.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp1a_Magicsquare01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotateDegree = GetRotateDegree();
			vRotateDegree += D3DXVECTOR3( 0, -70, -45 );

			pSeq->SetAddRotate( vRotateDegree );
			pSeq->SetAxisAngle( vRotateDegree );
		}


		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 90.f;
		}
		else
		{
			vPos -= GetDirVector() * 90.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp1a_PinLight01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}


		// 새로운 몬스터 소환
		if( true == g_pX2Game->IsHost() )
		{
			vPos = GetPos();
			//if( true == GetIsRight() )
			//{
			//	vPos += GetDirVector() * 40.f;
			//}
			//else
			//{
			//	vPos -= GetDirVector() * 40.f;
			//}


			int iNewLineIndex = m_FrameDataNow.syncData.lastTouchLineIndex;
			D3DXVECTOR3 vNewPos( 0, 0, 0 );
			if( NULL != g_pX2Game->GetLineMap() )
			{
				vNewPos = g_pX2Game->GetLineMap()->GetLandPosition( vPos, LINE_RADIUS, &iNewLineIndex );
				if( -1 != iNewLineIndex )
				{
					vPos.x = vNewPos.x;
					vPos.y = max( vPos.y, vNewPos.y );
					vPos.z = vNewPos.z;
				}
			}



			int iHyperMode = 1;
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO10 ) == true )
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_GUARDIAN_SP1_EVE_MEMO, iHyperMode, true, vPos, 
				GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
			else
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_GUARDIAN_SP1_EVE, iHyperMode, true, vPos, 
				GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );

		}

		m_fSummonedLifeTime = 20.f;
		m_timerSummoned.restart();

	}

	CommonFrameMove();

}

void CX2GUEve::ENSI_SI1_AT_SURFACE_CUTING_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI2_AT_SONIC_WAVE_Init()
{
	XSkinMeshReadyInBackground(L"Motion_Guardian_Eve.x");
}

void CX2GUEve::ENSI_SI2_AT_SONIC_WAVE_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 1 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.2f ) == true && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 170.f;
		}
		else
		{
			vPos -= GetDirVector() * 170.f;
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp3a_Magicsquare01", vPos );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 110.f;

		if( true == g_pX2Game->IsHost() )
		{
			vPos = GetPos();
			if( true == GetIsRight() )
			{
				vPos -= GetDirVector() * 50.f;
			}
			else
			{
				vPos += GetDirVector() * 50.f;
			}		



			int iNewLineIndex = m_FrameDataNow.syncData.lastTouchLineIndex;
			D3DXVECTOR3 vNewPos( 0, 0, 0 );
			if( NULL != g_pX2Game->GetLineMap() )
			{
				vNewPos = g_pX2Game->GetLineMap()->GetLandPosition( vPos, LINE_RADIUS, &iNewLineIndex );
				if( -1 != iNewLineIndex )
				{
					vPos.x = vNewPos.x;
					vPos.y = max( vPos.y, vNewPos.y );
					vPos.z = vNewPos.z;

				}
			}




			int iHyperMode = 0;
#ifdef SERV_SKILL_NOTE
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO4 ) == true )
			{
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_GUARDIAN_SP2_EVE_MEMO, iHyperMode, true, vPos, 
					GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
			}
			else
			{
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_GUARDIAN_SP2_EVE, iHyperMode, true, vPos, 
					GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
			}
#else
			g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_GUARDIAN_SP2_EVE, iHyperMode, true, vPos, 
				GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
#endif
		}

	}

	CommonFrameMove();
}
void CX2GUEve::ENSI_SI2_AT_SONIC_WAVE_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}
void CX2GUEve::ENSI_SI2_AT_SONIC_WAVE_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 1 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.2f ) == true && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 220.f;
		}
		else
		{
			vPos -= GetDirVector() * 220.f;
		}

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp3a_Magicsquare01", vPos );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 110.f;

		if( true == g_pX2Game->IsHost() )
		{
			vPos = GetPos();
			//if( true == GetIsRight() )
			//{
			//	vPos += GetDirVector() * 100.f;
			//}
			//else
			//{
			//	vPos -= GetDirVector() * 100.f;
			//}		



			int iNewLineIndex = m_FrameDataNow.syncData.lastTouchLineIndex;
			D3DXVECTOR3 vNewPos( 0, 0, 0 );
			if( NULL != g_pX2Game->GetLineMap() )
			{
				vNewPos = g_pX2Game->GetLineMap()->GetLandPosition( vPos, LINE_RADIUS, &iNewLineIndex );
				if( -1 != iNewLineIndex )
				{
					vPos.x = vNewPos.x;
					vPos.y = max( vPos.y, vNewPos.y );
					vPos.z = vNewPos.z;

				}
			}




			int iHyperMode = 1;
#ifdef SERV_SKILL_NOTE
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO4 ) == true )
			{
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_GUARDIAN_SP2_EVE_MEMO, iHyperMode, true, vPos, 
					GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
			}
			else
			{
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_GUARDIAN_SP2_EVE, iHyperMode, true, vPos, 
					GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
			}
#else
			g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_GUARDIAN_SP2_EVE, iHyperMode, true, vPos, 
				GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID() );
#endif
		}

	}

	CommonFrameMove();
}
void CX2GUEve::ENSI_SI2_AT_SONIC_WAVE_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI3_AT_GENOCIDE_RIPPER_Init()
{
	XSkinMeshReadyInBackground( L"Eve_AT_sp3a_GCR_Guardian01.X" );
	XSkinMeshReadyInBackground( L"Eve_AT_sp3a_GCR_Guardian02.X" );
	XSkinMeshReadyInBackground( L"Eve_AT_sp3a_GCR_Guardian03.X" );
	XSkinMeshReadyInBackground( L"Eve_AT_sp3a_GCR_Guardian04.X" );
	XSkinMeshReadyInBackground( L"Eve_AT_sp3a_GCR_Guardian05.X" );
	XSkinMeshReadyInBackground( L"Eve_AT_sp3a_GCR_Guardian06.X" );
	XSkinMeshReadyInBackground( L"Eve_AT_sp3a_GCR_Guardian07.X" );
	XSkinMeshReadyInBackground( L"Spin_Liner02.X" );

	TextureReadyInBackground( L"GroundShockWave02.tga" );
	TextureReadyInBackground( L"MagicsquareLight02_Red.tga" );	
}

void CX2GUEve::ENSI_SI3_AT_GENOCIDE_RIPPER_Start()
{
	CommonStateStart();

	D3DXVECTOR3 vPos = GetPos();
	CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;
	pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp3a_Magicsquare01", vPos );
	if( NULL != pSeq )
	{
		pSeq->SetAddRotate( GetRotateDegree() );
		pSeq->SetAxisAngle( GetRotateDegree() );
	}
	pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp3a_Light01", vPos );
	if( NULL != pSeq )
	{
		pSeq->SetAddRotate( GetRotateDegree() );
		pSeq->SetAxisAngle( GetRotateDegree() );
	}
	pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_AT_Sp3a_GCR_PinLight01", vPos );
	if( NULL != pSeq )
	{
		pSeq->SetAddRotate( GetRotateDegree() );
		pSeq->SetAxisAngle( GetRotateDegree() );
	}
	pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_AT_Sp3a_GCR_Spinliner01", vPos );
	if( NULL != pSeq )
	{
		pSeq->SetAddRotate( GetRotateDegree() );
		pSeq->SetAxisAngle( GetRotateDegree() );
	}	

	m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] = INVALID_MESH_INSTANCE_HANDLE;
}

void CX2GUEve::ENSI_SI3_AT_GENOCIDE_RIPPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 2 );

	float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();

#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimerOneshot( 0.533f ) )
#else //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.533f ) == true && EventCheck( 0.533f, false ) == true )
#endif //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 375.f;
		}
		else
		{
			vPos -= GetDirVector() * 375.f;
		}
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Genocide_Ripper", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );	
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimerOneshot( 1.783f ) )
#else //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 1.783f ) == true && EventCheck( 1.783f, false ) == true )
#endif //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 375.f;
		}
		else
		{
			vPos -= GetDirVector() * 375.f;
		}
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Genocide_Ripper_Final", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );	
	}
#else // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
	// 제노사이드 리퍼, 모든 이펙트가 Script 내의 EffectSet 으로 변경됨
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.533f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.533f ) == true && EventCheck( 0.533f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 250.f;
		}
		else
		{
			vPos -= GetDirVector() * 250.f;
		}

		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_1", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{			
			m_ahMajorMeshInstance[MajorMID_AT_SP3] = pEffect->GetMainEffectHandle();
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.567f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.567f ) == true && EventCheck( 0.567f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if(m_ahMajorMeshInstance[MajorMID_AT_SP3] != INVALID_MESH_INSTANCE_HANDLE)
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_AT_SP3] );
			D3DXVECTOR3 vPosP = GetPos(); 
			if(pMeshInst != NULL)
				vPosP = pMeshInst->GetBonePos(L"ATTACK_SPHERE1_GUi");

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.666f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.666f ) == true && EventCheck( 0.666f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 250.f;
		}
		else
		{
			vPos -= GetDirVector() * 250.f;
		}
		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_2", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_AT_SP3] = pEffect->GetMainEffectHandle();
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.7f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.7f ) == true && EventCheck( 0.7f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if(m_ahMajorMeshInstance[MajorMID_AT_SP3] != INVALID_MESH_INSTANCE_HANDLE)
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_AT_SP3] );
			D3DXVECTOR3 vPosP = GetPos(); 
			if(pMeshInst != NULL)
				vPosP = pMeshInst->GetBonePos(L"ATTACK_SPHERE2_GUi");

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.866f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.866f ) == true && EventCheck( 0.866f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 250.f;
		}
		else
		{
			vPos -= GetDirVector() * 250.f;
		}
		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_3", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_AT_SP3] = pEffect->GetMainEffectHandle();
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.9f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.9f ) == true && EventCheck( 0.9f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if(m_ahMajorMeshInstance[MajorMID_AT_SP3] != INVALID_MESH_INSTANCE_HANDLE)
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_AT_SP3] );
			D3DXVECTOR3 vPosP = GetPos(); 
			if(pMeshInst != NULL)
				vPosP = pMeshInst->GetBonePos(L"ATTACK_SPHERE3_GUi");

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.033f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.033f ) == true && EventCheck( 1.033f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 250.f;
		}
		else
		{
			vPos -= GetDirVector() * 250.f;
		}
		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_4", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_AT_SP3] = pEffect->GetMainEffectHandle();
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.064f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.064f ) == true && EventCheck( 1.064f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if(m_ahMajorMeshInstance[MajorMID_AT_SP3] != INVALID_MESH_INSTANCE_HANDLE)
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_AT_SP3] );
			D3DXVECTOR3 vPosP = GetPos();
			if(pMeshInst != NULL)
				vPosP = pMeshInst->GetBonePos(L"ATTACK_SPHERE4_GUi");

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.2f ) == true && EventCheck( 1.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 250.f;
		}
		else
		{
			vPos -= GetDirVector() * 250.f;
		}
		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_5", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_AT_SP3] = pEffect->GetMainEffectHandle();
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.231f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.231f ) == true && EventCheck( 1.231f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if(m_ahMajorMeshInstance[MajorMID_AT_SP3] != INVALID_MESH_INSTANCE_HANDLE)
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_AT_SP3] );
			D3DXVECTOR3 vPosP = GetPos(); 
			if(pMeshInst != NULL)
				vPosP = pMeshInst->GetBonePos(L"ATTACK_SPHERE5_GUi");

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.366f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.366f ) == true && EventCheck( 1.366f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 250.f;
		}
		else
		{
			vPos -= GetDirVector() * 250.f;
		}
		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_6", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_AT_SP3] = pEffect->GetMainEffectHandle();
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.397f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.397f ) == true && EventCheck( 1.397f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if(m_ahMajorMeshInstance[MajorMID_AT_SP3] != INVALID_MESH_INSTANCE_HANDLE)
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_AT_SP3] );
			D3DXVECTOR3 vPosP = GetPos(); 
			if(pMeshInst != NULL)
				vPosP = pMeshInst->GetBonePos(L"ATTACK_SPHERE6_GUi");

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.466f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.466f ) == true && EventCheck( 1.466f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_7", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( pEffect->GetMainEffectHandle() );
			if(pMeshInst != NULL)
			{
				D3DXVECTOR3 vPosP = GetPos();
				if( true == GetIsRight() )
				{
					vPosP -= GetDirVector() * 50.f;
				}
				else
				{
					vPosP += GetDirVector() * 50.f;
				}
				vPosP.y += 500.f;

				CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
				if( NULL != pSeq )
				{
					pSeq->SetAddRotate( GetRotateDegree() );
					pSeq->SetAxisAngle( GetRotateDegree() );
				}
			}			
		}
	}	
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.84f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.84f ) == true && EventCheck( 1.84f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 270.f;
		}
		else
		{
			vPos -= GetDirVector() * 270.f;
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Stone_Raven_EarthBreaker03", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_8", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );

		UpDownCrashCamera( 30.0f, 0.4f );
	}	
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.9f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.9f ) == true && EventCheck( 1.9f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 270.f;
		}
		else
		{
			vPos -= GetDirVector() * 270.f;
		}
        CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Raven_EarthBreaker01_Mesh", vPos, GetRotateDegree(), GetRotateDegree() );

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Stone_Raven_EarthBreaker02", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}	
	}	
	// 텔레포트 이펙트
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 3.66f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 3.66f ) == true && EventCheck( 3.66f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{		
		D3DXVECTOR3 vPos = GetPos();		
		if(GetIsRight() == true)
			vPos += GetDirVector() * 100.f;
		else
			vPos -= GetDirVector() * 100.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}
		CKTDGParticleSystem::CParticleEventSequence* pSeq1 = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P02", vPos );
		if( NULL != pSeq1 )
		{
			pSeq1->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}
		CKTDGParticleSystem::CParticleEventSequence* pSeq2 = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P03", vPos );
		if( NULL != pSeq2 )
		{
			pSeq2->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 3.76f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 3.76f ) == true && EventCheck( 3.76f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
			vPos += GetDirVector() * 100.f;
		else
			vPos -= GetDirVector() * 100.f;

		vPos.y += 50.f;
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 3.79f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 3.79f ) == true && EventCheck( 3.79f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
			vPos += GetDirVector() * 100.f;
		else
			vPos -= GetDirVector() * 100.f;

		vPos.y += 100.f;
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 3.92f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 3.92f ) == true && EventCheck( 3.92f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
			vPos += GetDirVector() * 100.f;
		else
			vPos -= GetDirVector() * 100.f;

		vPos.y += 200.f;
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 4.05f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 4.05f ) == true && EventCheck( 4.05f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
			vPos += GetDirVector() * 100.f;
		else
			vPos -= GetDirVector() * 100.f;

		vPos.y += 300.f;
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 4.18f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 4.18f ) == true && EventCheck( 4.18f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
			vPos += GetDirVector() * 100.f;
		else
			vPos -= GetDirVector() * 100.f;

		vPos.y += 450.f;
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}		
	}
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편

	CommonFrameMove();
}
void CX2GUEve::ENSI_SI3_AT_GENOCIDE_RIPPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}
void CX2GUEve::ENSI_SI3_AT_GENOCIDE_RIPPER_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.04f, 2 );

	float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();


#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.533f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.533f ) == true && EventCheck( 0.533f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 375.f;
		}
		else
		{
			vPos -= GetDirVector() * 375.f;
		}
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Genocide_Ripper_Hyper", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );	
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimerOneshot( 1.783f ) )
#else //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.783f ) == true && EventCheck( 1.783f, false ) == true )
#endif //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 375.f;
		}
		else
		{
			vPos -= GetDirVector() * 375.f;
		}
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Genocide_Ripper_Hyper_Dummy", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );	
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimerOneshot( 0.666f ) )
#else //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.666f ) == true && EventCheck( 0.666f, false ) == true )
#endif //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 375.f;
		}
		else
		{
			vPos -= GetDirVector() * 375.f;
		}
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Genocide_Ripper_Hyper_Dummy", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );	
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimerOneshot( 0.866f ) )
#else //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.866f ) == true && EventCheck( 0.866f, false ) == true )
#endif //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 375.f;
		}
		else
		{
			vPos -= GetDirVector() * 375.f;
		}
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Genocide_Ripper_Hyper_Dummy", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );	
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimerOneshot( 1.033f ) )
#else //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.033f ) == true && EventCheck( 1.033f, false ) == true )
#endif //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 375.f;
		}
		else
		{
			vPos -= GetDirVector() * 375.f;
		}
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Genocide_Ripper_Hyper_Dummy", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );	
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimerOneshot( 1.333f ) )
#else //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.333f ) == true && EventCheck( 1.333f, false ) == true )
#endif //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 375.f;
		}
		else
		{
			vPos -= GetDirVector() * 375.f;
		}
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Genocide_Ripper_Hyper_Dummy", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );	
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimerOneshot( 1.783f ) )
#else //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.783f ) == true && EventCheck( 1.783f, false ) == true )
#endif //X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 375.f;
		}
		else
		{
			vPos -= GetDirVector() * 375.f;
		}
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Genocide_Ripper_Final_Hyper", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );	
	}
#else // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
	if( m_pXSkinAnim->EventTimer( 0.533f ) == true && EventCheck( 0.533f, false ) == true )
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 250.f;
		}
		else
		{
			vPos -= GetDirVector() * 250.f;
		}

		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_HYPER_1", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{			
			m_ahMajorMeshInstance[MajorMID_AT_SP3] = pEffect->GetMainEffectHandle();
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.567f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.567f ) == true && EventCheck( 0.567f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if(m_ahMajorMeshInstance[MajorMID_AT_SP3] != INVALID_MESH_INSTANCE_HANDLE)
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_AT_SP3] );
			D3DXVECTOR3 vPosP = GetPos(); 
			if(pMeshInst != NULL)
				vPosP = pMeshInst->GetBonePos(L"ATTACK_SPHERE1_GUi");

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.666f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.666f ) == true && EventCheck( 0.666f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 250.f;
		}
		else
		{
			vPos -= GetDirVector() * 250.f;
		}
		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_HYPER_2", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_AT_SP3] = pEffect->GetMainEffectHandle();
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.7f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.7f ) == true && EventCheck( 0.7f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if(m_ahMajorMeshInstance[MajorMID_AT_SP3] != INVALID_MESH_INSTANCE_HANDLE)
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_AT_SP3] );
			D3DXVECTOR3 vPosP = GetPos(); 
			if(pMeshInst != NULL)
				vPosP = pMeshInst->GetBonePos(L"ATTACK_SPHERE2_GUi");

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.866f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.866f ) == true && EventCheck( 0.866f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 250.f;
		}
		else
		{
			vPos -= GetDirVector() * 250.f;
		}
		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_HYPER_3", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_AT_SP3] = pEffect->GetMainEffectHandle();
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.9f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.9f ) == true && EventCheck( 0.9f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if(m_ahMajorMeshInstance[MajorMID_AT_SP3] != INVALID_MESH_INSTANCE_HANDLE)
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_AT_SP3] );
			D3DXVECTOR3 vPosP = GetPos(); 
			if(pMeshInst != NULL)
				vPosP = pMeshInst->GetBonePos(L"ATTACK_SPHERE3_GUi");

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.033f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.033f ) == true && EventCheck( 1.033f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 250.f;
		}
		else
		{
			vPos -= GetDirVector() * 250.f;
		}
		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_HYPER_4", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_AT_SP3] = pEffect->GetMainEffectHandle();
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.064f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.064f ) == true && EventCheck( 1.064f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if(m_ahMajorMeshInstance[MajorMID_AT_SP3] != INVALID_MESH_INSTANCE_HANDLE)
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_AT_SP3] );
			D3DXVECTOR3 vPosP = GetPos();
			if(pMeshInst != NULL)
				vPosP = pMeshInst->GetBonePos(L"ATTACK_SPHERE4_GUi");

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.2f ) == true && EventCheck( 1.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 250.f;
		}
		else
		{
			vPos -= GetDirVector() * 250.f;
		}
		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_HYPER_5", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_AT_SP3] = pEffect->GetMainEffectHandle();
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.231f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.231f ) == true && EventCheck( 1.231f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if(m_ahMajorMeshInstance[MajorMID_AT_SP3] != INVALID_MESH_INSTANCE_HANDLE)
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_AT_SP3] );
			D3DXVECTOR3 vPosP = GetPos(); 
			if(pMeshInst != NULL)
				vPosP = pMeshInst->GetBonePos(L"ATTACK_SPHERE5_GUi");

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.366f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.366f ) == true && EventCheck( 1.366f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 250.f;
		}
		else
		{
			vPos -= GetDirVector() * 250.f;
		}
		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_HYPER_6", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_AT_SP3] = pEffect->GetMainEffectHandle();
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.397f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.397f ) == true && EventCheck( 1.397f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if(m_ahMajorMeshInstance[MajorMID_AT_SP3] != INVALID_MESH_INSTANCE_HANDLE)
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_AT_SP3] );
			D3DXVECTOR3 vPosP = GetPos(); 
			if(pMeshInst != NULL)
				vPosP = pMeshInst->GetBonePos(L"ATTACK_SPHERE6_GUi");

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.466f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.466f ) == true && EventCheck( 1.466f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_HYPER_7", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( pEffect->GetMainEffectHandle() );
			if(pMeshInst != NULL)
			{
				D3DXVECTOR3 vPosP = GetPos();
				if( true == GetIsRight() )
				{
					vPosP -= GetDirVector() * 50.f;
				}
				else
				{
					vPosP += GetDirVector() * 50.f;
				}
				vPosP.y += 500.f;

				CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_AT_Sp3a_GCR", vPosP );
				if( NULL != pSeq )
				{
					pSeq->SetAddRotate( GetRotateDegree() );
					pSeq->SetAxisAngle( GetRotateDegree() );
				}
			}			
		}
	}	
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.84f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.84f ) == true && EventCheck( 1.84f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 270.f;
		}
		else
		{
			vPos -= GetDirVector() * 270.f;
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Stone_Raven_EarthBreaker03", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		CX2DamageEffect::CEffect* pEffect;
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_GENOCIDE_RIPPER_HYPER_8", GetPowerRate() * fStatAtkRateOfSummoned, vPos, GetRotateDegree(), GetRotateDegree() );

		UpDownCrashCamera( 30.0f, 0.4f );

	}	
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.9f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.9f ) == true && EventCheck( 1.9f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
		{
			vPos += GetDirVector() * 270.f;
		}
		else
		{
			vPos -= GetDirVector() * 270.f;
		}
        CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Raven_EarthBreaker01_Mesh", vPos, GetRotateDegree(), GetRotateDegree() );

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Stone_Raven_EarthBreaker02", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
	// 텔레포트 이펙트
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 3.66f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 3.66f ) == true && EventCheck( 3.66f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{		
		D3DXVECTOR3 vPos = GetPos();		
		if(GetIsRight() == true)
			vPos += GetDirVector() * 100.f;
		else
			vPos -= GetDirVector() * 100.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}
		CKTDGParticleSystem::CParticleEventSequence* pSeq1 = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P02", vPos );
		if( NULL != pSeq1 )
		{
			pSeq1->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}
		CKTDGParticleSystem::CParticleEventSequence* pSeq2 = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P03", vPos );
		if( NULL != pSeq2 )
		{
			pSeq2->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 3.76f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 3.76f ) == true && EventCheck( 3.76f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
			vPos += GetDirVector() * 100.f;
		else
			vPos -= GetDirVector() * 100.f;

		vPos.y += 50.f;
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 3.79f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 3.79f ) == true && EventCheck( 3.79f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
			vPos += GetDirVector() * 100.f;
		else
			vPos -= GetDirVector() * 100.f;

		vPos.y += 100.f;
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 3.92f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 3.92f ) == true && EventCheck( 3.92f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
			vPos += GetDirVector() * 100.f;
		else
			vPos -= GetDirVector() * 100.f;

		vPos.y += 200.f;
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 4.05f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 4.05f ) == true && EventCheck( 4.05f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
			vPos += GetDirVector() * 100.f;
		else
			vPos -= GetDirVector() * 100.f;

		vPos.y += 300.f;
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}		
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 4.18f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 4.18f ) == true && EventCheck( 4.18f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if(GetIsRight() == true)
			vPos += GetDirVector() * 100.f;
		else
			vPos -= GetDirVector() * 100.f;

		vPos.y += 450.f;
		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMinorParticle()->CreateSequence( (CKTDGObject*) this,  L"RespawnLanding_P04", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetScaleFactor(D3DXVECTOR3(2.f, 2.f, 2.f));
		}		
	}
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
	CommonFrameMove();
}
void CX2GUEve::ENSI_SI3_AT_GENOCIDE_RIPPER_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

//////////////////////////////////////////////////////////////////////////
// begin : EXOTIC GEAR SP
void CX2GUEve::ENSI_SI1_EG_HORNET_STING_Init()
{
	XSkinMeshReadyInBackground( L"EG_SP1a_HornetSting_Bomb.X" );
	XSkinMeshReadyInBackground( L"EG_SP1a_HornetSting_Cannon.X" );
	TextureReadyInBackground( L"Eve_EG_SP1_HornetSting_Piece00.tga" );

}

void CX2GUEve::ENSI_SI1_EG_HORNET_STING_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.02f, 0 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.06f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.06f ) == true && EventCheck( 0.06f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetPos();
        CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;
		pMeshInst  = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_Eve_EG_SP1a_HornetSting_Cannon", vBonePos, GetRotateDegree(), GetRotateDegree() );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.47f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.47f ) == true && EventCheck( 0.47f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger1" );

		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Flare_EG_SP1a_HornetSting_01", vBonePos );
		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Expl_EG_SP1a_HornetSting_01", vBonePos );
		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Explosion_Eve_EG_Sp1a_HS02", vBonePos );

		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO9 ) == true )
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP1A_HORNETSTING_BOMB_MEMO", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
		else
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP1A_HORNETSTING_BOMB", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SI1_EG_HORNET_STING_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI1_EG_HORNET_STING_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.02f, 0 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.06f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.06f ) == true && EventCheck( 0.06f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetPos();
        CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_Eve_EG_SP1a_HornetSting_Cannon", vBonePos, GetRotateDegree(), GetRotateDegree() );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.47f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.47f ) == true && EventCheck( 0.47f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetPos();
		vBonePos.x -= 20.f;
		vBonePos.y += 130.f;

		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Flare_EG_SP1a_HornetSting_01", vBonePos );

		vBonePos = GetPos();
		vBonePos.x += 10.f;
		vBonePos.y += 145.f;

		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Expl_EG_SP1a_HornetSting_01", vBonePos );

		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Expl_EG_SP1a_HornetSting_02", vBonePos );

		vBonePos = GetBonePos( L"Bip01_L_Finger0" );

		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO9 ) == true )
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP1A_HORNETSTING_BOMB_MEMO", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
		else
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP1A_HORNETSTING_BOMB", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );
	}


	CommonFrameMove();
}

void CX2GUEve::ENSI_SI1_EG_HORNET_STING_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

// ENSI_SP2_EXPLOSION_IMPACT
void CX2GUEve::ENSI_SI2_EG_EXPLOSION_IMPACT_Init()
{
	XSkinMeshReadyInBackground( L"EG_SP2a_ExplosionImpact_Mesh.X" );
}

void CX2GUEve::ENSI_SI2_EG_EXPLOSION_IMPACT_Start()
{
	m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] = INVALID_MESH_INSTANCE_HANDLE;

	CommonStateStart();
}

void CX2GUEve::ENSI_SI2_EG_EXPLOSION_IMPACT_End()
{
	m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] = INVALID_MESH_INSTANCE_HANDLE;

	CommonStateEnd();
}

void CX2GUEve::ENSI_SI2_EG_EXPLOSION_IMPACT_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.02f, 1 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.06f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.06f ) == true && EventCheck( 0.06f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos(L"Bip01_R_Hand");

		CX2DamageEffect::CEffect* pEffect;
#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_MEMO", GetPowerRate(),
				vBonePos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT", GetPowerRate(),
				vBonePos, GetRotateDegree(), GetRotateDegree() );
		}
#else
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT", GetPowerRate(),
			vBonePos, GetRotateDegree(), GetRotateDegree() );
#endif

		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] = pEffect->GetMainEffectHandle();
		}

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.88f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.88f ) == true && EventCheck( 1.88f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//if( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] != INVALID_MESH_INSTANCE_HANDLE )
		//{
		//	CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] );
		//	if( NULL != pMeshInst )
		//	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 100.f;
		if( true == GetIsRight() )
			vPos += GetDirVector() * 691.f;
		else
			vPos -= GetDirVector() * 691.f;

#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate() * 1.1f,
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
#else				
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree() );
#endif

		UpDownCrashCameraNoReset( 15.0f, 0.3f );
		//	}
		//	else
		//	{
		//		m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] = INVALID_MESH_INSTANCE_HANDLE;
		//	}
		//}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.96f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.96f ) == true && EventCheck( 1.96f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE

	{
		//if( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] != INVALID_MESH_INSTANCE_HANDLE )
		//{
		//	CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] );
		//	if( NULL != pMeshInst )
		//	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 100.f;
		if( true == GetIsRight() )
			vPos += GetDirVector() * 590.f;
		else
			vPos -= GetDirVector() * 590.f;

#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate() * 1.1f,
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
#else
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree() );
#endif

		UpDownCrashCameraNoReset( 15.0f, 0.3f );
		//	}
		//	else
		//	{
		//		m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] = INVALID_MESH_INSTANCE_HANDLE;
		//	}
		//}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 2.04f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 2.04f ) == true && EventCheck( 2.04f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//if( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] != INVALID_MESH_INSTANCE_HANDLE )
		//{
		//	CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] );
		//	if( NULL != pMeshInst )
		//	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 100.f;
		if( true == GetIsRight() )
			vPos += GetDirVector() * 480.f;
		else
			vPos -= GetDirVector() * 480.f;


#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate() * 1.1f,
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
#else
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree() );
#endif

		UpDownCrashCameraNoReset( 15.0f, 0.3f );
		//	}
		//	else
		//	{
		//		m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] = INVALID_MESH_INSTANCE_HANDLE;
		//	}
		//}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 2.12f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 2.12f ) == true && EventCheck( 2.12f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//if( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] != INVALID_MESH_INSTANCE_HANDLE )
		//{
		//	CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] );
		//	if( NULL != pMeshInst )
		//	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 100.f;
		if( true == GetIsRight() )
			vPos += GetDirVector() * 370.f;
		else
			vPos -= GetDirVector() * 370.f;

#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate() * 1.1f,
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
#else
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree() );
#endif

		UpDownCrashCameraNoReset( 15.0f, 0.3f );
		//	}
		//	else
		//	{
		//		m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] = INVALID_MESH_INSTANCE_HANDLE;
		//	}
		//}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 2.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 2.2f ) == true && EventCheck( 2.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//if( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] != INVALID_MESH_INSTANCE_HANDLE )
		//{
		//	CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] );
		//	if( NULL != pMeshInst )
		//	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 100.f;
		if( true == GetIsRight() )
			vPos += GetDirVector() * 250.f;
		else
			vPos -= GetDirVector() * 250.f;

#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate() * 1.1f,
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
#else
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree() );
#endif

		UpDownCrashCameraNoReset( 15.0f, 0.3f );
		//	}
		//	else
		//	{
		//		m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] = INVALID_MESH_INSTANCE_HANDLE;
		//	}
		//}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 2.28f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 2.28f ) == true && EventCheck( 2.28f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//if( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] != INVALID_MESH_INSTANCE_HANDLE )
		//{
		//	CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] );
		//	if( NULL != pMeshInst )
		//	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 100.f;
		if( true == GetIsRight() )
			vPos += GetDirVector() * 140.f;
		else
			vPos -= GetDirVector() * 140.f;

#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate() * 1.1f,
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
#else
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree() );
#endif

		UpDownCrashCameraNoReset( 15.0f, 0.3f );
	}

	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos(L"Bip01_R_Hand");
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SI2_EG_EXPLOSION_IMPACT_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI2_EG_EXPLOSION_IMPACT_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.02f, 1 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.06f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.06f ) == true && EventCheck( 0.06f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos(L"Bip01_R_Hand");

		CX2DamageEffect::CEffect* pEffect;
#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_MEMO", GetPowerRate(),
				vBonePos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT", GetPowerRate(),
				vBonePos, GetRotateDegree(), GetRotateDegree() );
		}
#else
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT", GetPowerRate(),
			vBonePos, GetRotateDegree(), GetRotateDegree() );
#endif
		if( NULL != pEffect )
		{
			m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] = pEffect->GetMainEffectHandle();
		}

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.88f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.88f ) == true && EventCheck( 1.88f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//if( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] != INVALID_MESH_INSTANCE_HANDLE )
		//{
		//	CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] );
		//	if( NULL != pMeshInst )
		//	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 100.f;
		if( true == GetIsRight() )
			vPos += GetDirVector() * 691.f;
		else
			vPos -= GetDirVector() * 691.f;

#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate() * 1.1f,
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
#else
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree() );
#endif

		UpDownCrashCameraNoReset( 15.0f, 0.3f );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.96f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.96f ) == true && EventCheck( 1.96f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{

		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 100.f;
		if( true == GetIsRight() )
			vPos += GetDirVector() * 590.f;
		else
			vPos -= GetDirVector() * 590.f;

#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate() * 1.1f,
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
#else
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree() );
#endif

		UpDownCrashCameraNoReset( 15.0f, 0.3f );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 2.04f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 2.04f ) == true && EventCheck( 2.04f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 100.f;
		if( true == GetIsRight() )
			vPos += GetDirVector() * 480.f;
		else
			vPos -= GetDirVector() * 480.f;

#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate() * 1.1f,
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
#else
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree() );
#endif

		UpDownCrashCameraNoReset( 15.0f, 0.3f );

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 2.12f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 2.12f ) == true && EventCheck( 2.12f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 100.f;
		if( true == GetIsRight() )
			vPos += GetDirVector() * 370.f;
		else
			vPos -= GetDirVector() * 370.f;

#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate() * 1.1f,
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
#else
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree() );
#endif

		UpDownCrashCameraNoReset( 15.0f, 0.3f );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 2.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 2.2f ) == true && EventCheck( 2.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 100.f;
		if( true == GetIsRight() )
			vPos += GetDirVector() * 250.f;
		else
			vPos -= GetDirVector() * 250.f;

#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate() * 1.1f,
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
#else
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree() );
#endif

		UpDownCrashCameraNoReset( 15.0f, 0.3f );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 2.28f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 2.28f ) == true && EventCheck( 2.28f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 100.f;
		if( true == GetIsRight() )
			vPos += GetDirVector() * 140.f;
		else
			vPos -= GetDirVector() * 140.f;

#ifdef SERV_SKILL_NOTE
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO3 ) == true )
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate() * 1.1f,
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
		else
		{
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
				vPos, GetRotateDegree(), GetRotateDegree() );
		}
#else
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP2A_EXPLOSION_IMPACT_EXP", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree() );
#endif

		UpDownCrashCameraNoReset( 15.0f, 0.3f );
	}

	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_ExplosionImpact01] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos(L"Bip01_R_Hand");
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SI2_EG_EXPLOSION_IMPACT_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

// ENSI_SI3_QUEENS_THRONE
void CX2GUEve::ENSI_SI3_EG_QUEENS_THRONE_Init()
{
	XMeshReadyInBackground( L"Eve_EG_Sp3a_QT_Text01.Y" );
	XSkinMeshReadyInBackground( L"Mesh_UpLight01.X" );
	XSkinMeshReadyInBackground( L"EG_SP3a_QueensThrone_Wing.X" );
	XSkinMeshReadyInBackground( L"EG_SP3a_QueensThrone_Wing_Weapon1.X" );
	XSkinMeshReadyInBackground( L"EG_SP3a_QueensThrone_Wing_Weapon2.X" );
	XSkinMeshReadyInBackground( L"EG_SP3a_QueensThrone_Wing_Weapon3.X" );
	XSkinMeshReadyInBackground( L"EG_SP3a_QueensThrone_Wing_Weapon4.X" );
	TextureReadyInBackground( L"GroundShockWave02.tga" );
	TextureReadyInBackground( L"QT_Text01.tga" );

}

void CX2GUEve::ENSI_SI3_EG_QUEENS_THRONE_Start()
{
	CommonStateStart();

	m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] = INVALID_MESH_INSTANCE_HANDLE;
}

void CX2GUEve::ENSI_SI3_EG_QUEENS_THRONE_End()
{
	m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] = INVALID_MESH_INSTANCE_HANDLE;

	CommonStateEnd();
}

void CX2GUEve::ENSI_SI3_EG_QUEENS_THRONE_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.02f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.06f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.06f ) == true && EventCheck( 0.06f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetPos();
        CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;
		pMeshInst  = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_Eve_EG_Sp3a_QT_UpLight01", vBonePos, GetRotateDegree(), GetRotateDegree() );

		D3DXVECTOR3 vBonePos1 = GetBonePos( L"Bip01_Spine1" );

		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_EG_SP3a_QueensThrone_Wing", vBonePos1, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] = pMeshInst->GetHandle();
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();

		vPos.x -= 20.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_Eve_EG_QT02", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		vPos = GetPos();
		vPos.x -= 20.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_EG_QT01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		vPos = GetPos();
		vPos.x -= 20.f;
		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_EG_Sp3a_QT_Spinliner01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.5f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.5f ) == true && EventCheck( 0.5f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{		
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();

		vPos.y += 80.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_EG_Sp3a_QT_Text01", vPos );

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.3f ) == true && EventCheck( 1.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetBonePos(L"Bip01_Pelvis");

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_Eve_EG_QT01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		vPos = GetBonePos(L"Bip01_Pelvis");
		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_EG_QT01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_QT_START_SHOCKWAVE", GetPowerRate(), vPos, GetRotateDegree(), GetRotateDegree() );

		vPos = GetPos();
		vPos.y += 80.f;
		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_EG_Sp3a_QT_Text02", vPos );

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.4f ) == true && EventCheck( 1.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();

		vPos.x -= 15.f;
		vPos.y += 155.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LED_Eve_EG_QT_Eye01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		vPos = GetPos();
		vPos.x -= 15.f;
		vPos.y += 155.f;
		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LED_Eve_EG_QT_Eye02", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
		vPos = GetPos();
		vPos.x -= 15.f;
		vPos.y += 155.f;
		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LED_Eve_EG_QT_Eye03", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		UpDownCrashCameraNoReset( 20.f, 0.3f );
	}

	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}

	//3필 준비를 마치고 버프를 시작함.
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 1.9f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 1.9f ) == true && EventCheck( 1.9f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//준비 이펙트를 위해 붙어있던 날개를 지운다.
		if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] )
		{
			g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing]);
		}

		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );

		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;

		m_sEGQueensThrone.Reset();
		m_sEGQueensThrone.m_bEnable = true;

#ifdef ADD_MEMO_1ST_CLASS //김창한
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO17 ) == true && m_sEGQueensThrone.m_dMaxLifeTime < 35.f )
			m_sEGQueensThrone.m_dMaxLifeTime += 5;
#endif //ADD_MEMO_1ST_CLASS

		// 날개를 붙인다.(4조각)
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_EG_SP3a_QueensThrone_Wing_Weapon_01", vBonePos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
        {
			m_sEGQueensThrone.m_ahMajorMeshInstance[0] = pMeshInst->GetHandle();
        }
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_EG_SP3a_QueensThrone_Wing_Weapon_02", vBonePos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
        {
			m_sEGQueensThrone.m_ahMajorMeshInstance[1] = pMeshInst->GetHandle();
        }
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_EG_SP3a_QueensThrone_Wing_Weapon_03", vBonePos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
		{
			m_sEGQueensThrone.m_ahMajorMeshInstance[2] = pMeshInst->GetHandle();

			//날개에 붙는 파티클 붙여놓기.
			m_sEGQueensThrone.m_ahMajorParticleInstance[EG_QueensThroneData::PP_WING] = 
				g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Booster_Eve_EG_Sp3a_GCR01", pMeshInst->GetBonePos(L"Dummy01") );
		}
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_EG_SP3a_QueensThrone_Wing_Weapon_04", vBonePos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
        {
			m_sEGQueensThrone.m_ahMajorMeshInstance[3] = pMeshInst->GetHandle();
        }

		m_sEGQueensThrone.m_TimerElapsedTime.restart();
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SI3_EG_QUEENS_THRONE_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SI3_EG_QUEENS_THRONE_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.02f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.06f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.06f ) == true && EventCheck( 0.06f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetPos();
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_Eve_EG_Sp3a_QT_UpLight01", vBonePos, GetRotateDegree(), GetRotateDegree() );
		D3DXVECTOR3 vBonePos1 = GetBonePos( L"Bip01_Spine1" );



		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_EG_SP3a_QueensThrone_Wing", vBonePos1, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] = pMeshInst->GetHandle();
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();

		vPos.x -= 20.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_Eve_EG_QT02", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		vPos = GetPos();
		vPos.x -= 20.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Light_Eve_EG_QT01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		vPos = GetPos();
		vPos.x -= 20.f;
		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_EG_Sp3a_QT_Spinliner01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.5f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.5f ) == true && EventCheck( 0.5f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{		
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();

		vPos.y += 80.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_EG_Sp3a_QT_Text01", vPos );

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.3f ) == true && EventCheck( 1.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetBonePos(L"Bip01_Pelvis");

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_Eve_EG_QT01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		vPos = GetBonePos(L"Bip01_Pelvis");
		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"ShockWave_Eve_EG_QT01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EG_SP3A_QT_START_SHOCKWAVE", GetPowerRate(), vPos, GetRotateDegree(), GetRotateDegree() );

		vPos = GetPos();
		vPos.y += 80.f;
		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_EG_Sp3a_QT_Text02", vPos );

	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.4f ) == true && EventCheck( 1.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();

		vPos.x -= 15.f;
		vPos.y += 155.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LED_Eve_EG_QT_Eye01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		vPos = GetPos();
		vPos.x -= 15.f;
		vPos.y += 155.f;
		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LED_Eve_EG_QT_Eye02", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
		vPos = GetPos();
		vPos.x -= 15.f;
		vPos.y += 155.f;
		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LED_Eve_EG_QT_Eye03", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}

		UpDownCrashCameraNoReset( 20.f, 0.3f );
	}

	if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] );
		if( NULL != pMeshInst )
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );
			pMeshInst->SetPos( vBonePos );
		}
		else
		{
			m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}

	//3필 준비를 마치고 버프를 시작함.
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 1.9f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 1.9f ) == true && EventCheck( 1.9f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//준비 이펙트를 위해 붙어있던 날개를 지운다.
		if( INVALID_MESH_INSTANCE_HANDLE != m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing] )
		{
			g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle(m_ahMajorMeshInstance[MajorMID_EG_SP3_Wing]);
		}

		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Spine1" );

		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;

		m_sEGQueensThrone.Reset();
		m_sEGQueensThrone.m_bEnable = true;

#ifdef ADD_MEMO_1ST_CLASS //김창한
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO17 ) == true && m_sEGQueensThrone.m_dMaxLifeTime < 35.f )
			m_sEGQueensThrone.m_dMaxLifeTime += 5;
#endif //ADD_MEMO_1ST_CLASS

		// 날개를 붙인다.(4조각)
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_EG_SP3a_QueensThrone_Wing_Weapon_01", vBonePos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
        {
			m_sEGQueensThrone.m_ahMajorMeshInstance[0] = pMeshInst->GetHandle();
        }
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_EG_SP3a_QueensThrone_Wing_Weapon_02", vBonePos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
        {
			m_sEGQueensThrone.m_ahMajorMeshInstance[1] = pMeshInst->GetHandle();
        }
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_EG_SP3a_QueensThrone_Wing_Weapon_03", vBonePos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
		{
			m_sEGQueensThrone.m_ahMajorMeshInstance[2] = pMeshInst->GetHandle();

			//날개에 붙는 파티클 붙여놓기.
			m_sEGQueensThrone.m_ahMajorParticleInstance[EG_QueensThroneData::PP_WING] = 
				g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"Booster_Eve_EG_Sp3a_GCR01", pMeshInst->GetBonePos(L"Dummy01") );
		}
		pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"Mesh_EG_SP3a_QueensThrone_Wing_Weapon_04", vBonePos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pMeshInst )
        {
			m_sEGQueensThrone.m_ahMajorMeshInstance[3] = pMeshInst->GetHandle();
        }

		m_sEGQueensThrone.m_TimerElapsedTime.restart();
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SI3_EG_QUEENS_THRONE_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

// end : EXOTIC GEAR SP
//////////////////////////////////////////////////////////////////////////

void CX2GUEve::EG_QueensThroneData::Reset()
{
	m_bEnable				= false;
	m_iSelectBoneNameID		= 0;

	for( int i = 0; i < ARRAY_SIZE(m_ahMajorMeshInstance); ++i )
	{
		if( m_ahMajorMeshInstance[i] != INVALID_MESH_INSTANCE_HANDLE )
			g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle( m_ahMajorMeshInstance[i] );

		m_ahMajorMeshInstance[i] = INVALID_MESH_INSTANCE_HANDLE;
	}
	for( int i = 0; i < ARRAY_SIZE(m_ahMajorParticleInstance); ++i )
	{
		if( m_ahMajorParticleInstance[i] != INVALID_PARTICLE_SEQUENCE_HANDLE )
			g_pX2Game->GetMajorParticle()->DestroyInstanceHandle(m_ahMajorParticleInstance[i]);
		m_ahMajorParticleInstance[i] = INVALID_PARTICLE_SEQUENCE_HANDLE;
	}
}
#endif EVE_FIRST_CHANGE_JOB


// ENSI_SI_A_EN_CONVERSION
void CX2GUEve::ENSI_A_EN_CONVERSION_Init()
{
}

void CX2GUEve::ENSI_A_EN_CONVERSION_Start()
{
	CommonStateStart();

	// HP 를 소모해 주고 MP를 채워줌.
	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EN_CONVERSION );
	if( NULL == pSkillTemplet )
	{
		StateChange( USI_WAIT );
		return;
	}

	float fTemp = 0.f;

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	if ( NULL == GetUnit() )
		return;

	const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

	const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( CX2SkillTree::SI_A_EN_CONVERSION ) );	/// 스킬 레벨

	// HP 감소.
	fTemp = static_cast<float>(GetMaxHp() * pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_HP_REL_TO_MP_ABS_1, iSkillTempletLevel) );
#else // UPGRADE_SKILL_UI
	// HP 감소.
	fTemp = static_cast<float>(GetMaxHp() * pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_HP_REL_TO_MP_ABS_1) );
#endif // UPGRADE_SKILL_UI
	
#ifdef SERV_SKILL_NOTE
	if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO6 ) == true )
	{
		if( GetRandomFloat() > 0.3f )
		{
			UpNowHp( -fTemp );
		}
	}
	else
	{
		UpNowHp( -fTemp );
	}
#else
	UpNowHp( -fTemp );
#endif

	fTemp = 0.f;

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	// MP 증가.
	fTemp = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_HP_REL_TO_MP_ABS_2, iSkillTempletLevel );
#else // UPGRADE_SKILL_SYSTEM_2013
	// MP 증가.
	fTemp = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_HP_REL_TO_MP_ABS_2 );
#endif // UPGRADE_SKILL_SYSTEM_2013
	UpNowMp( fTemp );

}

void CX2GUEve::ENSI_A_EN_CONVERSION_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_C
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 1.f )
		{
			StateChange( USI_WAIT );
		}
	}
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
}
// ENSI_SI_A_EN_MEGA_ELECTRONBALL
void CX2GUEve::ENSI_A_EN_MEGA_ELECTRONBALL_Init()
{
}

void CX2GUEve::ENSI_A_EN_MEGA_ELECTRONBALL_StartFuture()
{
	CommonStateStartFuture();

	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed.x = 0.f;
	m_PhysicParam.nowSpeed.y = 0.f;
}

void CX2GUEve::ENSI_A_EN_MEGA_ELECTRONBALL_Start()
{
	CommonStateStart();

	//차지 시간을 책정 차지랭크 설정.
	// 1. 소모 MP
	// 2. 데미지 배율
	// 3. 크리 배율
	// 에 적용됨.
	if( (m_sMegaElectronBallData.m_dMaxTime * 0.5) >= m_sMegaElectronBallData.m_timerElapsedTime.elapsed() )
		m_sMegaElectronBallData.m_ChargeRank = CR_RANK_1;
	else if( m_sMegaElectronBallData.m_dMaxTime >= m_sMegaElectronBallData.m_timerElapsedTime.elapsed() )
		m_sMegaElectronBallData.m_ChargeRank = CR_RANK_2;
	else if( m_sMegaElectronBallData.m_dMaxTime < m_sMegaElectronBallData.m_timerElapsedTime.elapsed() )
		m_sMegaElectronBallData.m_ChargeRank = CR_RANK_3;
	//최대 예외처리
	else
		m_sMegaElectronBallData.m_ChargeRank = CR_RANK_1;

	//m_sMegaElectronBallData.Reset();

	//g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_Condense_power.ogg" );
	//g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_FullCharge.ogg" );

#ifdef EVE_ELECTRA
	m_fPlaneZAngle	= 0.f;
#endif EVE_ELECTRA
}
void CX2GUEve::ENSI_A_EN_MEGA_ELECTRONBALL_FrameMoveFuture()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 0.66f )
	{			
		m_bDisableGravity = false;
	}

	CommonFrameMoveFuture();
}
void CX2GUEve::ENSI_A_EN_MEGA_ELECTRONBALL_FrameMove()
{
#ifdef EVE_ELECTRA
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.22f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.22f ) == true && EventCheck( 0.22f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( m_fPlaneZAngle, 2.0f, 240.f, 130.f );
	}
#endif EVE_ELECTRA

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.23f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.23f ) == true && EventCheck( 0.23f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		// MP 소모
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EN_MEGA_ELECTRONBALL );

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		if ( NULL == GetUnit() )
			return;

		const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

		const int iSkillLevel = max( 1, userSkillTree.GetSkillLevel( CX2SkillTree::SI_A_EN_MEGA_ELECTRONBALL ) );	/// 스킬 레벨
	#endif // UPGRADE_SKILL_UI

		float fMPOrg = 15.f;
		float fMPConsumption = 0.f;
		float fPowerRate = 1.f;
		float fScale = 0.f;		// 스케일은 만약 2배가 된다면 2.f 식으로 전달되어야함.(메인,페시브 이펙트 안에서 OrgSize * fScale 로 계산을 하기때문)
		float fRange = 1.f;

		if( NULL != pSkillTemplet )
		{
			switch( m_sMegaElectronBallData.m_ChargeRank )
			{
			case CR_RANK_1: 
				{
					fMPConsumption	= fMPOrg; 
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
					fPowerRate		= GetPowerRate();
#else //UPGRADE_SKILL_SYSTEM_2013
					fPowerRate		= 1.f;
#endif //UPGRADE_SKILL_SYSTEM_2013
					fScale			= 1.f;
					fRange			= 1.f;
				}
				break;
			case CR_RANK_2: 
				{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
					fMPConsumption	= fMPOrg + ((pSkillTemplet->GetSkillMPConsumptionValue( iSkillLevel ) - fMPOrg) / 2.f); 
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
					fPowerRate		= GetPowerRate() * 1.5f;
#else //UPGRADE_SKILL_SYSTEM_2013
					fPowerRate		= 1.f + ((GetPowerRate()-1) / 2.f);
#endif //UPGRADE_SKILL_SYSTEM_2013
					fScale			= 1.f + ((pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_SIZE, iSkillLevel ) - 1) / 2.f );
					fRange			= 1.f + ((pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_RANGE_REL, iSkillLevel ) - 1) / 2.f );
	#else // UPGRADE_SKILL_SYSTEM_2013
					fMPConsumption	= fMPOrg + ((pSkillTemplet->m_fMPConsumption - fMPOrg) / 2.f); 
					fPowerRate		= 1.f + ((GetPowerRate()-1) / 2.f);
					fScale			= 1.f + ((pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_SIZE ) - 1) / 2.f );
					fRange			= 1.f + ((pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_RANGE_REL ) - 1) / 2.f );
	#endif // UPGRADE_SKILL_SYSTEM_2013
				}
				break;
			case CR_RANK_3: 
				{
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
					fMPConsumption	= pSkillTemplet->GetSkillMPConsumptionValue( iSkillLevel );
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
					fPowerRate		= GetPowerRate() * 2.f;
#else //UPGRADE_SKILL_SYSTEM_2013
					fPowerRate		= GetPowerRate();
#endif //UPGRADE_SKILL_SYSTEM_2013
					fScale			= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_SIZE, iSkillLevel );
					fRange			= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_RANGE_REL, iSkillLevel );	
#else // UPGRADE_SKILL_SYSTEM_2013
					fMPConsumption	= pSkillTemplet->m_fMPConsumption;
					fPowerRate		= GetPowerRate(); 
					fScale			= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_SIZE );
					fRange			= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_RANGE_REL );	
#endif // UPGRADE_SKILL_SYSTEM_2013				
				}
				break;
			}
		}
		else
		{
			fMPConsumption = 20.f;
		}

		switch( GetUnit()->GetClass() )
		{
		case CX2Unit::UC_EVE_ARCHITECTURE:
		case CX2Unit::UC_EVE_CODE_EMPRESS:
			fMPConsumption *= m_fMPConsumeRateElectronBall;
			break;
		}

		if( FlushMp( fMPConsumption ) == true ) 
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Hand" );

			CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_SI_A_EN_MEB01", vBonePos );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
			vBonePos.x += 10.f;
			pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_SI_A_EN_MEB02", vBonePos );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}
			pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Ring_Eve_SI_A_EN_MEB03", vBonePos );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}

#ifdef SERV_SKILL_NOTE

			float fMemoPowerRate = 1.1f;
#ifdef BALANCE_PATCH_20110303
			fMemoPowerRate = 1.f;
#endif

	#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
			CX2DamageEffect::CEffect* pEffect = NULL;
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO7 ) == true )
			{
				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_MEGA_ELECTRON_BALL", fPowerRate * m_fAttackPowerRateElectronBall * fMemoPowerRate, 
					vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate * fRange );
			}
			else
			{
				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_MEGA_ELECTRON_BALL", fPowerRate * m_fAttackPowerRateElectronBall, 
					vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate * fRange );
			}
	#else //UPGRADE_SKILL_SYSTEM_2013
			CX2DamageEffect::CEffect* pEffect = NULL;
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO7 ) == true )
			{
				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_X_FIRE_BALL", fPowerRate * m_fAttackPowerRateElectronBall * fMemoPowerRate, 
					vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate * fRange );
			}
			else
			{
				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_X_FIRE_BALL", fPowerRate * m_fAttackPowerRateElectronBall, 
					vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate * fRange );
			}
	#endif //UPGRADE_SKILL_SYSTEM_2013
#else
			CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_X_FIRE_BALL", fPowerRate * m_fAttackPowerRateElectronBall, 
				vBonePos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, m_fForceDownValueRateElectronBall, m_fElectronBallRangeRate * fRange );
#endif
			if( pEffect != NULL )
			{
				pEffect->SetScale(fScale,fScale,fScale);
#ifdef INHERIT_FORCEDOWNRATE
				pEffect->SetInheritForceDownRate(true);
#endif INHERIT_FORCEDOWNRATE
			}
#ifdef EVE_ELECTRA
			if( NULL != pEffect )
#ifdef SERV_EVE_BATTLE_SERAPH
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
				m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_MEGA_ELECTRON_BALL_FILTERED", 
				L"EVE_MEGA_ELECTRON_BALL_FILTERED", L"EVE_MEGA_ELECTRON_BALL_FILTERED", L"EVE_MEGA_ELECTRON_BALL_FILTERED" );
#else //UPGRADE_SKILL_SYSTEM_2013
				m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_COMBO_X_FIRE_BALL_AMPLIFY_FILTERED", 
				L"EVE_COMBO_X_FIRE_BALL_SPECTRUM_FILTERED", L"EVE_COMBO_X_FIRE_BALL_INDUCTION_FILTERED", 
				L"EVE_COMBO_X_FIRE_BALL_FUSION_FILTERED" );
#endif //UPGRADE_SKILL_SYSTEM_2013
#else
				m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_COMBO_X_FIRE_BALL_FILTERED", L"EVE_COMBO_X_FIRE_BALL_FILTERED" );
#endif

#endif EVE_ELECTRA

#ifdef EVE_ELECTRA
			PlaySound( L"Eve_FireShot1.ogg" );
#endif EVE_ELECTRA
		}
		else
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
			CreateNotEnoughMPEffect( vBonePos, 0.f, 0.f, 0.f );
		}
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_A_EN_MEGA_ELECTRONBALL_EventProcess()
{
#ifdef EVE_ELECTRA
	if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.4f )
	{
		if( m_InputData.pureUp == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
		}
		else if( m_InputData.pureDown == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
		}
	}
#endif EVE_ELECTRA

	//float fSkipTime;
	//float fChangeTime;

	//LUA_GET_VALUE( m_LuaManager, "SKIP_TIME",	fSkipTime, 0.0f );
	//LUA_GET_VALUE( m_LuaManager, "CHANGE_TIME",	fChangeTime, 0.0f );

	//if( false == IsOnSomethingFuture() && m_pXSkinAnimFuture->GetNowAnimationTime() > fChangeTime )
	//{
	//	StateChange( ENSI_JUMP_DOWN );
	//}
	//ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_C
	//{
	//	if( m_pXSkinAnimFuture->GetNowAnimationTime() > fSkipTime )
	//	{
	//		StateChange( ENSI_WAIT );
	//	}
	//}

	//if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	//{
	//	if( false == IsOnSomethingFuture() )
	//		StateChange( ENSI_JUMP_DOWN );
	//	else
	//		StateChange( ENSI_WAIT );
	//}	
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.36f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.36f ) == true && EventCheck( 0.36f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_bDisableGravity = false;
	}

	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}
void CX2GUEve::ENSI_A_EN_MEGA_ELECTRONBALL_EndFuture()
{
	m_bDisableGravity = false;
	CommonStateEndFuture();
}


#ifdef SKILL_30_TEST

void CX2GUEve::ENSI_SA_EEG_IRONSCRAPS_Init()
{
	XSkinMeshReadyInBackground( L"GuardianStrike02.X" );
	XMeshReadyInBackground( L"IronScraps_Mesh01.Y" );
	TextureReadyInBackground( L"Whitecircle02.tga" );
	TextureReadyInBackground( L"AeroTornado04.tga" );
	TextureReadyInBackground( L"Condense_Light01.tga" );
	TextureReadyInBackground( L"Explosion_Light02.tga" );
	TextureReadyInBackground( L"ColorBallGray.tga" );
}
void CX2GUEve::ENSI_SA_EEG_IRONSCRAPS_StateStart()
{
	CommonStateStart();

	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );

}

void CX2GUEve::ENSI_SA_EEG_IRONSCRAPS_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.02f, 2 );

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EEG_IRONSCRAPS_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_SA_EEG_IRONSCRAPS_StateEnd()
{
	m_bDisableGravity = false;
	CommonStateEnd();
}


void CX2GUEve::ENSI_SA_EEG_IRONSCRAPS_HYPER_Init()
{
	XSkinMeshReadyInBackground( L"GuardianStrike02.X" );
	XMeshReadyInBackground( L"IronScraps_Mesh01.Y" );
	TextureReadyInBackground( L"Whitecircle02.tga" );
	TextureReadyInBackground( L"AeroTornado04.tga" );
	TextureReadyInBackground( L"Condense_Light01.tga" );
	TextureReadyInBackground( L"Explosion_Light02.tga" );
	TextureReadyInBackground( L"ColorBallGray.tga" );
}
void CX2GUEve::ENSI_SA_EEG_IRONSCRAPS_HYPER_StateStart()
{
	CommonStateStart();

	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );

}

void CX2GUEve::ENSI_SA_EEG_IRONSCRAPS_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.02f, 2 );

	CommonFrameMove();
}



void CX2GUEve::ENSI_SA_EEG_IRONSCRAPS_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	CommonEventProcess();
}


void CX2GUEve::ENSI_SA_EEG_IRONSCRAPS_HYPER_StateEnd()
{
	m_bDisableGravity = false;
	CommonStateEnd();
}




void CX2GUEve::ENSI_SA_EAT_SPACE_WRENCH_StateStart()
{
	CommonStateStart();

	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );

}

void CX2GUEve::ENSI_SA_EAT_SPACE_WRENCH_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.02f, 2 );

	//여왕의 지배력 영향력을 주기 위해 데미지 이펙트만 코드로 빼냄.
	float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.066f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.066f ) == true && EventCheck( 0.066f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_SPACE_WRENCH", GetPowerRate() * fStatAtkRateOfSummoned,
			GetPos(), GetRotateDegree(), GetRotateDegree() );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EAT_SPACE_WRENCH_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	CommonEventProcess();
}


void CX2GUEve::ENSI_SA_EAT_SPACE_WRENCH_StateEnd()
{
	m_bDisableGravity = false;
	CommonStateEnd();
}


void CX2GUEve::ENSI_SA_EAT_SPACE_WRENCH_HYPER_StateStart()
{
	CommonStateStart();

	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );

}

void CX2GUEve::ENSI_SA_EAT_SPACE_WRENCH_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.02f, 2 );

	//여왕의 지배력 영향력을 주기 위해 데미지 이펙트만 코드로 빼냄.
	float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.066f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.066f ) == true && EventCheck( 0.066f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_AT_SPACE_WRENCH_HYPER", GetPowerRate() * fStatAtkRateOfSummoned,
			GetPos(), GetRotateDegree(), GetRotateDegree() );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EAT_SPACE_WRENCH_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	CommonEventProcess();
}


void CX2GUEve::ENSI_SA_EAT_SPACE_WRENCH_HYPER_StateEnd()
{
	m_bDisableGravity = false;
	CommonStateEnd();
}

//ENSI_SA_EEG_METAL_DUST_AURA
void CX2GUEve::ENSI_A_EEG_METAL_DUST_AURA_Init()
{
	XSkinMeshReadyInBackground( L"SI_A_EEG_METAL_DUST_AURA_Effect.x" );
	TextureReadyInBackground( L"CutTendon_Slash01.tga" );
	TextureReadyInBackground( L"Star.tga" );
	TextureReadyInBackground( L"SlashLight.tga" );
}
void CX2GUEve::ENSI_A_EEG_METAL_DUST_AURA_StateStart()
{
	CommonStateStart();

	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );
}
void CX2GUEve::ENSI_A_EEG_METAL_DUST_AURA_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.333f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.333f ) == true && EventCheck( 0.333f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet 
			= GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EEG_METAL_DUST_AURA );

		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO11 ) )
			SetBuffFactorToGameUnit( pSkillTemplet, 1 );
		else
			SetBuffFactorToGameUnit( pSkillTemplet, 0 );
	}

	CommonFrameMove();
}
void CX2GUEve::ENSI_A_EEG_METAL_DUST_AURA_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.66f )
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}
void CX2GUEve::ENSI_A_EEG_METAL_DUST_AURA_StateEnd()
{
	m_bDisableGravity = false;
	CommonStateEnd();
}
//ENSI_A_EEG_METAL_DUST_AURA_HYPER
void CX2GUEve::ENSI_A_EEG_METAL_DUST_AURA_HYPER_Init()
{
	XSkinMeshReadyInBackground( L"SI_A_EEG_METAL_DUST_AURA_Effect.x" );
	TextureReadyInBackground( L"CutTendon_Slash01.tga" );
	TextureReadyInBackground( L"Star.tga" );
	TextureReadyInBackground( L"SlashLight.tga" );
}
void CX2GUEve::ENSI_A_EEG_METAL_DUST_AURA_HYPER_StateStart()
{
	CommonStateStart();

	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );

}
void CX2GUEve::ENSI_A_EEG_METAL_DUST_AURA_HYPER_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.333f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.333f ) == true && EventCheck( 0.333f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet 
			= GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EEG_METAL_DUST_AURA );

		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO11 ) )
			SetBuffFactorToGameUnit( pSkillTemplet, 1 );
		else
			SetBuffFactorToGameUnit( pSkillTemplet, 0 );
	}

	CommonFrameMove();
}
void CX2GUEve::ENSI_A_EEG_METAL_DUST_AURA_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.66f )
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}
void CX2GUEve::ENSI_A_EEG_METAL_DUST_AURA_HYPER_StateEnd()
{
	m_bDisableGravity = false;
	CommonStateEnd();
}



//ENSI_A_EAT_OBERON_GUARD
void CX2GUEve::ENSI_A_EAT_OBERON_GUARD_Init()
{
	//아키텍쳐만 사용하는 스킬이라 유닛클래스 검사를 하지 않아도 됨.
	XSkinMeshReadyInBackground( L"Eve_SI_A_Oberon_Guard_Oberon_Mesh01.x" );
	XMeshReadyInBackground( L"Eve_Barrier_SideLine01.Y" );
	XMeshReadyInBackground( L"Eve_Barrier_Plane01.Y" );
	XMeshReadyInBackground( L"Eve_Barrier01.Y" );
}
void CX2GUEve::ENSI_A_EAT_OBERON_GUARD_StateStart()
{
	CommonStateStart();

	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );
}
void CX2GUEve::ENSI_A_EAT_OBERON_GUARD_FrameMove()
{
	D3DXVECTOR3 vPos;

	float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();

	//첫타격을 하는 오베론 돌격 데미지 이펙트.
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.26f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.26f ) == true && EventCheck( 0.26f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		vPos = GetPos();

		CX2DamageEffect::CEffect* pEffect = NULL;
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO12 ) == true )
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DE_EVE_SI_A_OVERON_GUARD01_MEMO", GetPowerRate() * fStatAtkRateOfSummoned,
			vPos, GetRotateDegree(), GetRotateDegree() );
		else
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DE_EVE_SI_A_OVERON_GUARD01", GetPowerRate() * fStatAtkRateOfSummoned,
			vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			if( m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_01] != INVALID_MESH_INSTANCE_HANDLE )
			{
				g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle( m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_01] );
				m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_01] = INVALID_MESH_INSTANCE_HANDLE;
			}

			m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_01] = pEffect->GetMainEffectHandle();
		}

		m_sATOveronGuardData.m_TimerElapsedTime.restart();
		m_sATOveronGuardData.SetEnable(true);

#ifdef SKILL_BALANCE_PATCH
		if( m_hOberonGuard != INVALID_EFFECTSET_HANDLE )
		{
			g_pX2Game->GetEffectSet()->StopEffectSet(m_hOberonGuard);
		}

		float fScale = m_sATOveronGuardData.GetProjectileSize();
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO12 ) == true )
			m_hOberonGuard = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EAT_OBERON_GUARD_MEMO", (CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned, -1.f, D3DXVECTOR3(fScale, fScale, fScale) );
		else
			m_hOberonGuard = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EAT_OBERON_GUARD", (CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned, -1.f, D3DXVECTOR3(fScale, fScale, fScale) );
#endif
	}
	//시작시 발동 되는 파티클 3종
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		vPos = GetBonePos( L"Bip01_R_Finger2" );

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_Eve_SI_A_Oberon_Guard01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}

#ifndef SKILL_BALANCE_PATCH
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.466f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.466f ) == true && EventCheck( 0.466f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		vPos = GetPos();
		vPos.y += 120.f;
		if( true == GetIsRight() )
			vPos -= GetDirVector() * 200.f;
		else
			vPos += GetDirVector() * 200.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_SI_A_Oberon_Guard_SideLiner01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
			float fScale = m_sATOveronGuardData.GetProjectileSize();
			pSeq->SetScaleFactor( D3DXVECTOR3(fScale,fScale,fScale) );

			if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_01 ) )
			{
				g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_01 ) );
				SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_01, INVALID_PARTICLE_SEQUENCE_HANDLE );
			}

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_01, pSeq->GetHandle() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.47f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.47f ) == true && EventCheck( 0.47f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		vPos = GetPos();
		vPos.y += 120.f;
		if( true == GetIsRight() )
			vPos -= GetDirVector() * 240.f;
		else
			vPos += GetDirVector() * 240.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_SI_A_Oberon_Guard_Plane01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
			float fSize = m_sATOveronGuardData.GetProjectileSize();
			pSeq->SetScaleFactor( D3DXVECTOR3(fSize,fSize,fSize) );

			if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_02 ) )
			{
				g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_02 ) );
				SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_02, INVALID_PARTICLE_SEQUENCE_HANDLE );
			}
			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_02, pSeq->GetHandle() );
		}
	}
	//반격을 준비하는 데미지 이펙트.
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.53f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.53f ) == true && EventCheck( 0.53f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		vPos = GetPos();
		vPos.y += 120.f;
#ifdef SKILL_BALANCE_PATCH
		if( true == GetIsRight() )
			vPos -= GetDirVector() * 220.f;
		else
			vPos += GetDirVector() * 220.f;
#else
		if( true == GetIsRight() )
			vPos -= GetDirVector() * 270.f;
		else
			vPos += GetDirVector() * 270.f;
#endif
		CX2DamageEffect::CEffect* pEffect = NULL;
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO12 ) == true )
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DE_EVE_SI_A_OVERON_GUARD02_MEMO", GetPowerRate() * fStatAtkRateOfSummoned,
			vPos, GetRotateDegree(), GetRotateDegree() );
		else
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DE_EVE_SI_A_OVERON_GUARD02", GetPowerRate() * fStatAtkRateOfSummoned,
			vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			float fScale = m_sATOveronGuardData.GetProjectileSize();
			pEffect->SetScale(fScale,fScale,fScale);

			if( m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_02] != INVALID_MESH_INSTANCE_HANDLE )
			{
				g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle( m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_02] );
				m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_02] = INVALID_MESH_INSTANCE_HANDLE;
			}

			m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_02] = pEffect->GetMainEffectHandle();
		}
	}
#endif

	CommonFrameMove();
}
void CX2GUEve::ENSI_A_EAT_OBERON_GUARD_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.66f )
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}
void CX2GUEve::ENSI_A_EAT_OBERON_GUARD_StateEnd()
{
	m_bDisableGravity = false;
	CommonStateEnd();
}
//ENSI_A_EAT_OBERON_GUARD_HYPER
void CX2GUEve::ENSI_A_EAT_OBERON_GUARD_HYPER_Init()
{
	//아키텍쳐만 사용하는 스킬이라 유닛클래스 검사를 하지 않아도 됨.
	XSkinMeshReadyInBackground( L"Eve_SI_A_Oberon_Guard_Oberon_Mesh01.x" );
	XMeshReadyInBackground( L"Eve_Barrier_SideLine01.Y" );
	XMeshReadyInBackground( L"Eve_Barrier_Plane01.Y" );
	XMeshReadyInBackground( L"Eve_Barrier01.Y" );
}
void CX2GUEve::ENSI_A_EAT_OBERON_GUARD_HYPER_StateStart()
{
	CommonStateStart();

	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );

}
void CX2GUEve::ENSI_A_EAT_OBERON_GUARD_HYPER_FrameMove()
{
	D3DXVECTOR3 vPos;

	float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();

	//첫타격을 하는 오베론 돌격 데미지 이펙트.
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.26f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.26f ) == true && EventCheck( 0.26f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		vPos = GetPos();

		CX2DamageEffect::CEffect* pEffect = NULL;
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO12 ) == true )
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DE_EVE_SI_A_OVERON_GUARD01_MEMO", GetPowerRate() * fStatAtkRateOfSummoned,
			vPos, GetRotateDegree(), GetRotateDegree() );
		else
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DE_EVE_SI_A_OVERON_GUARD01", GetPowerRate() * fStatAtkRateOfSummoned,
			vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			if( m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_01] != INVALID_MESH_INSTANCE_HANDLE )
			{
				g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle( m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_01] );
				m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_01] = INVALID_MESH_INSTANCE_HANDLE;
			}

			m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_01] = pEffect->GetMainEffectHandle();
		}

		m_sATOveronGuardData.m_TimerElapsedTime.restart();
		m_sATOveronGuardData.SetEnable(true);


#ifdef SKILL_BALANCE_PATCH
		if( m_hOberonGuard != INVALID_EFFECTSET_HANDLE )
		{
			g_pX2Game->GetEffectSet()->StopEffectSet(m_hOberonGuard);
		}

		float fScale = m_sATOveronGuardData.GetProjectileSize();
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO12 ) == true )
			m_hOberonGuard = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EAT_OBERON_GUARD_MEMO", (CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned, -1.f, D3DXVECTOR3(fScale, fScale, fScale) );
		else
			m_hOberonGuard = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EAT_OBERON_GUARD", (CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned, -1.f, D3DXVECTOR3(fScale, fScale, fScale) );
#endif
	}

	//시작시 발동 되는 파티클 3종
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		vPos = GetBonePos( L"Bip01_R_Finger2" );

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"LightParticle_Eve_SI_A_Oberon_Guard01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#ifndef SKILL_BALANCE_PATCH
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.466f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.466f ) == true && EventCheck( 0.466f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		vPos = GetPos();
		vPos.y += 120.f;
		if( true == GetIsRight() )
			vPos -= GetDirVector() * 200.f;
		else
			vPos += GetDirVector() * 200.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_SI_A_Oberon_Guard_SideLiner01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
			float fScale = m_sATOveronGuardData.GetProjectileSize();
			pSeq->SetScaleFactor( D3DXVECTOR3(fScale,fScale,fScale) );

			if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_01 ) )
			{
				g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_01 ) );
				SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_01, INVALID_PARTICLE_SEQUENCE_HANDLE );
			}

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_01, pSeq->GetHandle() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.47f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.47f ) == true && EventCheck( 0.47f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		vPos = GetPos();
		vPos.y += 120.f;
		if( true == GetIsRight() )
			vPos -= GetDirVector() * 200.f;
		else
			vPos += GetDirVector() * 240.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_SI_A_Oberon_Guard_Plane01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
			float fSize = m_sATOveronGuardData.GetProjectileSize();
			pSeq->SetScaleFactor( D3DXVECTOR3(fSize,fSize,fSize) );

			if( INVALID_PARTICLE_SEQUENCE_HANDLE != GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_02 ) )
			{
				g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( GetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_02 ) );
				SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_02, INVALID_PARTICLE_SEQUENCE_HANDLE );
			}

			SetHandleEveMajorParticleByEnum( EVE_MAJOR_PII_OVERON_GUARD_02, pSeq->GetHandle() );
		}
	}
	//반격을 준비하는 데미지 이펙트.
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.53f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.53f ) == true && EventCheck( 0.53f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		vPos = GetPos();
		vPos.y += 120.f;
#ifdef SKILL_BALANCE_PATCH
		if( true == GetIsRight() )
			vPos -= GetDirVector() * 220.f;
		else
			vPos += GetDirVector() * 220.f;
#else
		if( true == GetIsRight() )
			vPos -= GetDirVector() * 270.f;
		else
			vPos += GetDirVector() * 270.f;
#endif

		CX2DamageEffect::CEffect* pEffect = NULL;
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO12 ) == true )
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DE_EVE_SI_A_OVERON_GUARD02_MEMO", GetPowerRate() * fStatAtkRateOfSummoned,
			vPos, GetRotateDegree(), GetRotateDegree() );
		else
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DE_EVE_SI_A_OVERON_GUARD02", GetPowerRate() * fStatAtkRateOfSummoned,
			vPos, GetRotateDegree(), GetRotateDegree() );
		if( NULL != pEffect )
		{
			float fScale = m_sATOveronGuardData.GetProjectileSize();
			pEffect->SetScale(fScale,fScale,fScale);

			if( m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_02] != INVALID_MESH_INSTANCE_HANDLE )
			{
				g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle( m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_02] );
				m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_02] = INVALID_MESH_INSTANCE_HANDLE;
			}

			m_ahMajorMeshInstance[MajorMID_AT_Overon_Guard_02] = pEffect->GetMainEffectHandle();
		}
	}
#endif
	CommonFrameMove();
}
void CX2GUEve::ENSI_A_EAT_OBERON_GUARD_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.66f )
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}
void CX2GUEve::ENSI_A_EAT_OBERON_GUARD_HYPER_StateEnd()
{
	m_bDisableGravity = false;
	CommonStateEnd();
}
#endif SKILL_30_TEST

#ifdef SKILL_CASH_10_TEST
void CX2GUEve::ENSI_A_EEG_JUNK_BREAK_Init()
{		
	XSkinMeshReadyInBackground( L"SI_SA_EEG_JUNK_BREAK_Effect_Drill_Main.X" );
	XSkinMeshReadyInBackground( L"SI_SA_EEG_JUNK_BREAK_Effect_Drill_Side.X" );
	XSkinMeshReadyInBackground( L"Spin_Liner03.X" );
	TextureReadyInBackground( L"GroundShockWave.tga" );
	TextureReadyInBackground( L"Condense_Pulse02.tga" );
}

void CX2GUEve::ENSI_A_EEG_JUNK_BREAK_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Bip01_Spine1", 0.01f, 2 );

	CommonFrameMove();
}

void CX2GUEve::ENSI_A_EEG_JUNK_BREAK_Hyper_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Bip01_Spine1", 0.01f, 2 );

	CommonFrameMove();
}

void CX2GUEve::ENSI_A_EEG_JUNK_BREAK_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
#ifdef BALANCE_CODE_NEMESIS_20121213
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
#endif //BALANCE_CODE_NEMESIS_20121213
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXCAS
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 5.33f )
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_A_EEG_JUNK_BREAK_Hyper_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
#ifdef BALANCE_CODE_NEMESIS_20121213
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
#endif //BALANCE_CODE_NEMESIS_20121213
	CommonEventProcess();
}

void CX2GUEve::ENSI_A_EAT_HEAVENS_FIST_Init()
{		
	XSkinMeshReadyInBackground( L"SI_SA_EAT_HEAVENS_FIST_Effect_King_Hand.X" );
	XSkinMeshReadyInBackground( L"SI_SA_EAT_HEAVENS_FIST_Effect_Light01.X" );
	XSkinMeshReadyInBackground( L"SI_SA_EAT_HEAVENS_FIST_Effect_Light02.X" );
	XSkinMeshReadyInBackground( L"SI_SA_EAT_HEAVENS_FIST_Effect_Bottom_Light.X" );
	XSkinMeshReadyInBackground( L"SI_SA_EAT_HEAVENS_FIST_Effect_Hole.X" );
}

void CX2GUEve::ENSI_A_EAT_HEAVENS_FIST_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Bip01_Spine1", 0.01f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//여왕의 지배력 파워수치를 이펙트 셋에 전달.
		float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();
		if( g_pX2Game != NULL && g_pX2Game->GetEffectSet() != NULL )
		{
			CX2EffectSet::Handle hFist = INVALID_EFFECTSET_HANDLE;
#ifdef ADD_MEMO_1ST_CLASS //김창한
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO20 ) == true )
				hFist = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EVE_HEAVENS_FIST_MEMO", (CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned );
			else
#endif //ADD_MEMO_1ST_CLASS
			hFist = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EVE_HEAVENS_FIST", (CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned );
			if( hFist != INVALID_EFFECTSET_HANDLE )
				m_vecEffectSetToDeleteOnDamageReact.push_back(hFist);
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.241f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.241f ) == true && EventCheck( 1.241f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		UpDownCrashCamera( 80.f, 1.0f );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_A_EAT_HEAVENS_FIST_Hyper_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Bip01_Spine1", 0.01f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//여왕의 지배력 파워수치를 이펙트 셋에 전달.
		float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();
		if( g_pX2Game != NULL && g_pX2Game->GetEffectSet() != NULL )
		{
			CX2EffectSet::Handle hFist = INVALID_EFFECTSET_HANDLE;
#ifdef ADD_MEMO_1ST_CLASS //김창한
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO20 ) == true )
				hFist = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EVE_HEAVENS_FIST_MEMO", (CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned );
			else
#endif //ADD_MEMO_1ST_CLASS
			hFist = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EVE_HEAVENS_FIST", (CX2GameUnit*)this, NULL, true, GetPowerRate() * fStatAtkRateOfSummoned );
			if( hFist != INVALID_EFFECTSET_HANDLE )
				m_vecEffectSetToDeleteOnDamageReact.push_back(hFist);
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.25f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.25f ) == true && EventCheck( 1.25f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		UpDownCrashCamera( 80.f, 1.0f );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_A_EAT_HEAVENS_FIST_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXCAS
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 3.33f )
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_A_EAT_HEAVENS_FIST_Hyper_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	CommonEventProcess();
}
#endif

//////////////////////////////////////////////////////////////////////////
void CX2GUEve::MEGA_ELECTRONBALL_Data::Reset(bool bIsChargeTrue /* = true */, FrameData* pFrameDataFuture /* = NULL  */)
{
	if( bIsChargeTrue == false && pFrameDataFuture != NULL )
	{
		pFrameDataFuture->syncData.nowAction = UAI_MEGA_ELECTRONBALL_CHARGE_FAIL;
	}

	m_bEnable		= false;
	m_bIsSucCharge	= false;
	//m_dMaxTime		= 0.;

	ResetParticle();


	g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_FullCharge.ogg" );
	g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_Condense_power.ogg" );


}


void CX2GUEve::MEGA_ELECTRONBALL_Data::ResetParticle()
{
	for( int i = 0; i < ARRAY_SIZE(m_ahMajorParticleInstance); ++i )
	{
		if( m_ahMajorParticleInstance[i] != INVALID_PARTICLE_SEQUENCE_HANDLE )
			g_pX2Game->GetMajorParticle()->DestroyInstanceHandle(m_ahMajorParticleInstance[i]);
		m_ahMajorParticleInstance[i] = INVALID_PARTICLE_SEQUENCE_HANDLE;
	}
}



void CX2GUEve::StateChangeJumpDashIfPossible()
{
	if( true == GetEnableDash() )
	{
#ifdef SERV_EVE_BATTLE_SERAPH
		if ( true == m_bHighPoweredElectrics && CX2Unit::UC_EVE_BATTLE_SERAPH == GetUnit()->GetClass() )
		{
			if ( 0 < m_iDashJumpCount && true == m_bAfterJumpDash && true == m_InputData.pureDoubleRight && 
				BDS_RIGHT == m_eBoostDashState )
			{
				m_eBoostDashState = BDS_RIGHT;
				m_bEnableBoostDash = true;
			}
			else if ( 0 < m_iDashJumpCount && true == m_bAfterJumpDash && true == m_InputData.pureDoubleLeft && 
				BDS_LEFT == m_eBoostDashState)
			{
				m_eBoostDashState = BDS_LEFT;
				m_bEnableBoostDash = true;
			}
			else
			{
				if ( true == m_InputData.pureDoubleRight || true == m_InputData.pureRight )
					m_eBoostDashState = BDS_RIGHT;
				else if ( true == m_InputData.pureDoubleLeft || true == m_InputData.pureLeft )
					m_eBoostDashState = BDS_LEFT;

				m_bEnableBoostDash = false;
			}

			if ( true == m_bEnableBoostDash )
				StateChange( ENSI_EBS_BOOST_DASH_AIR_START );
			else
				StateChange( ENSI_JUMP_DASH );
		}
		else
		{
			StateChange( ENSI_JUMP_DASH );
		}
#else
		StateChange( ENSI_JUMP_DASH );
#endif
	}
	else
	{
		StateChange( USI_JUMP_DOWN );
	}
}

//{{ kimhc // 2010.1.25 // 이브 2차 전직 대시 콤보
#ifdef EVE_SECOND_CLASS_CHANGE

void CX2GUEve::CreateSpearBurst()
{
	m_bDisableGravity = false;			
	m_PhysicParam.fDownAccel = m_PhysicParam.fGAccel * 4.f;

	D3DXVECTOR3 vPos = GetPos();
	vPos.y += 150;

	D3DXVECTOR3 vRotateDegree = GetRotateDegree();

	if ( GetIsRight() == false )
		vRotateDegree += D3DXVECTOR3( 0.0f, 180.0f, 0.0f );

	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_ENS_SPEAR_BURST );
	if( NULL != pSkillTemplet )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		if ( NULL == GetUnit() )
			return;
	
		const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	
		const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_SPEAR_BURST_SPEAR",
			pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel ), vPos, vRotateDegree, vRotateDegree );
	#else // UPGRADE_SKILL_SYSTEM_2013
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_SPEAR_BURST_SPEAR",
			pSkillTemplet->m_fPowerRate, vPos, vRotateDegree, vRotateDegree );
	#endif // UPGRADE_SKILL_SYSTEM_2013

		float fGapY	= vPos.y - GetLandPosition().y;

		if ( pEffect != NULL )
		{
			float fLifeTime = fGapY / 3500;//( pMeshInstance->GetVelocity().y * -1 );
            if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
            {
			    pMeshInstance->SetLandPosition( GetLandPosition().y );
			    pMeshInstance->SetNotCheckLandTime( fLifeTime + 0.17f );	// 0.17 만큼의 라인맵 체크할 시간이 생김
            }
			m_bDoneSpearBurst	= true;
			//m_ahMajorMeshInstance[MajorPID_SPEAR_BURST01] = pEffect->GetMainEffectHandle();			
		}
	}
}


void CX2GUEve::ENSI_NS_DASH_COMBO_ZX_Init()
{
	XSkinMeshReadyInBackground( L"NS_DashComboZX_Spear.x" );
}

void CX2GUEve::ENSI_NS_DASH_COMBO_ZX_Start()
{
	CommonStateStart();
	m_iDashJumpCount++;
}

void CX2GUEve::ENSI_NS_DASH_COMBO_ZX_FrameMove()
{
	float fPowerRate = GetPowerRate();

	if ( m_sEGQueensThrone.m_bEnable == true )
		fPowerRate = m_sEGQueensThrone.m_fPowerRate;

	D3DXVECTOR3 vPos = GetPos();
	vPos.y -= 50;

	if ( GetIsRight() == true )
	{
		vPos.x -= GetDirVector().x * 70;

	}
	else
	{
		vPos.x += GetDirVector().x * 70;
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.27f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.27f ) == true && EventCheck( 0.27f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{	
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_DASH_COMBO_ZX_SPEAR", fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_NS_DASH_COMBO_ZX_EventProcess()
{
	if( SpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) == true )
	{
	}
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.46f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;

		m_PhysicParam.nowSpeed		= D3DXVECTOR2( 900, 900 );
		StateChange( ENSI_NS_DASH_COMBO_ZXX );
	}
	else if( m_InputData.oneX == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.46f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}
	ELSE_IF_ARROW_ZXASDC_PRESSED_AFTER( 0.46f )
	{
		m_PhysicParam.nowSpeed		= D3DXVECTOR2( 900, 900 );
		StateChange( USI_JUMP_DOWN );
	}

	if( true == IsOnSomethingFuture() && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.46f )
	{
		m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
		StateChange( USI_JUMP_LANDING );		// not dash_jump_landing 
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_NS_DASH_COMBO_ZXX_Init()
{
	XSkinMeshReadyInBackground( L"NS_DashComboZXX_Spear.x" );
}

void CX2GUEve::ENSI_NS_DASH_COMBO_ZXX_FrameMove()
{
	float fPowerRate = GetPowerRate();

	if ( m_sEGQueensThrone.m_bEnable == true )
		fPowerRate = m_sEGQueensThrone.m_fPowerRate;

	D3DXVECTOR3 vPos = GetPos();

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{	
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_DASH_COMBO_ZXX_SPEAR", fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_NS_DASH_COMBO_ZXX_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		m_FrameDataFuture.syncData.bIsRight = !(m_FrameDataFuture.syncData.bIsRight);
		StateChange( USI_JUMP_LANDING );		// not dash_jump_landing 
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.56f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_NS_COMBO_XXZ_FrameMove()
{
	float fPowerRate = GetPowerRate();

	if ( m_sEGQueensThrone.m_bEnable == true )
		fPowerRate = m_sEGQueensThrone.m_fPowerRate;

	D3DXVECTOR3 vPos = GetPos();

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.001f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.001f ) == true && EventCheck( 0.001f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{	
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_COMBO_XXZ_SPEAR1", fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_COMBO_XXZ_SPEAR2", fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_NS_COMBO_XXZ_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if ( m_iSuccessiveHit_OneZ >= 1 && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.53f )	
	{
		m_iSuccessiveHit_OneZ = 0;
		StateChange( ENSI_NS_COMBO_XXZZ8 );
	}
	else if ( m_InputData.oneZ == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.53f )
	{
		m_iSuccessiveHit_OneZ++;
	}

	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_NS_COMBO_XXZZ8_FrameMove()
{
	float fPowerRate = GetPowerRate();

	if ( m_sEGQueensThrone.m_bEnable == true )
		fPowerRate = m_sEGQueensThrone.m_fPowerRate;

	D3DXVECTOR3 vPos = GetPos();

	if ( GetIsRight() == true )
		vPos -= D3DXVECTOR3( 40.0f, 0.0f, 0.0f );
	else
		vPos += D3DXVECTOR3( 40.0f, 0.0f, 0.0f );

	// 6타중 첫번째 1타
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.26f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.26f ) == true && EventCheck( 0.26f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{	
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_COMBO_XXZZ8_SPEAR1", fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );
	}

	// 6타중 2타
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.40f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.40f ) == true && EventCheck( 0.40f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{	
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_COMBO_XXZZ8_SPEAR2", fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );
	}

	// 6타중 3타
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.53f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.53f ) == true && EventCheck( 0.53f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{	
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_COMBO_XXZZ8_SPEAR3", fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );
	}

	// 6타중 4타
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.66f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.66f ) == true && EventCheck( 0.66f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{	
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_COMBO_XXZZ8_SPEAR4", fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );
	}

	// 6타중 5타
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.8f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.8f ) == true && EventCheck( 0.8f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{	
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_COMBO_XXZZ8_SPEAR5", fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );
	}

	// 6타중 6타
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.93f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.93f ) == true && EventCheck( 0.93f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{	
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_COMBO_XXZZ8_SPEAR6", fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_NS_COMBO_XXZZ8_EventProcess()
{
	if ( m_InputData.oneZ == true )
	{
		m_iSuccessiveHit_OneZ++;
	}

	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if ( m_iSuccessiveHit_OneZ < 1 && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.33f )
	{
		m_iSuccessiveHit_OneZ = 0;
		StateChange( ENSI_NS_COMBO_XXZZ8Z );	// 1~2 타만 때리고 막타
	}
	else if ( m_iSuccessiveHit_OneZ >= 1 && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.33f )
	{
		m_iSuccessiveHit_OneZ = 1;
	}
	else if ( m_iSuccessiveHit_OneZ < 2 && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.6f )
	{
		// 
		m_iSuccessiveHit_OneZ = 0;
		StateChange( ENSI_NS_COMBO_XXZZ8Z );	// 3~4 타 까지만 때리고 막타
	}

	if ( m_pXSkinAnimFuture->GetNowAnimationTime() > 1.05f || m_pXSkinAnimFuture->IsAnimationEnd() == true)
	{
		m_iSuccessiveHit_OneZ = 0;
		StateChange( ENSI_NS_COMBO_XXZZ8Z );
	}
#ifdef BALANCE_CODE_NEMESIS_20121213
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
#endif //BALANCE_CODE_NEMESIS_20121213


	CommonEventProcess();
}

void CX2GUEve::ENSI_NS_COMBO_XXZZ8Z_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.36f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.36f ) == true && EventCheck( 0.36f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{	
		float fPowerRate = GetPowerRate();

		if ( m_sEGQueensThrone.m_bEnable == true )
			fPowerRate = m_sEGQueensThrone.m_fPowerRate;

		D3DXVECTOR3 vPos = GetPos();

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_COMBO_XXZZ8Z_Final_SPEAR", fPowerRate, 
			vPos, GetRotateDegree(), GetRotateDegree() );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_NS_COMBO_XXZZ8Z_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
#ifdef SKILL_CANCEL_BY_HYPER_MODE // 김태환
	SKILL_CANCEL_AFTER( 0.46f )
#else // SKILL_CANCEL_BY_HYPER_MODE
	ELSE_IF_ASDC_PRESSED_AFTER( 0.46f )
	{
		SpecialAttackEventProcess();
	}
#endif //SKILL_CANCEL_BY_HYPER_MODE

#ifdef BALANCE_CODE_NEMESIS_20121213
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
#endif //BALANCE_CODE_NEMESIS_20121213
	if ( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
}
void CX2GUEve::ENSI_EP_DASH_COMBO_ZZ_Init()
{
	XSkinMeshReadyInBackground( L"Eve_Guardian_BladeWave01.X" );
	XSkinMeshReadyInBackground( L"Eve_EP_DashComboZ3_Mesh01.X" );
	TextureReadyInBackground( L"ColorBallGray.tga" );
}

void CX2GUEve::ENSI_EP_DASH_COMBO_ZZ_FrameMove()
{
	CommonFrameMove();
}

void CX2GUEve::ENSI_EP_DASH_COMBO_ZZ_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.46f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;

		StateChange( ENSI_EP_DASH_COMBO_ZZZ );
	}
	else if( m_InputData.oneZ == true && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.466667f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}

	if ( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}
	/*
	ELSE_IF_ASDC_PRESSED_AFTER( 0.4f )
	{
	SpecialAttackEventProcess();
	}
	*/
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXCAS
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.6f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_EP_DASH_COMBO_ZZZ_Init()
{
	XSkinMeshReadyInBackground( L"Eve_EP_DashComboZ3_Mesh02.X" );
	XSkinMeshReadyInBackground( L"Eve_EP_JumpAttackZX_Mesh02.X" );
}


void CX2GUEve::ENSI_EP_DASH_COMBO_ZZZ_FrameMove()
{
	CommonFrameMove();
}

void CX2GUEve::ENSI_EP_DASH_COMBO_ZZZ_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}

	if ( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}

	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.666667f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_EP_JUMP_COMBO_ZX_Init()
{
	XSkinMeshReadyInBackground( L"Eve_EP_JumpAttackZX_Mesh01.X" );
	XSkinMeshReadyInBackground( L"Eve_EP_JumpAttackZX_Mesh02.X" );
	XMeshReadyInBackground( L"Wind_Liner02.Y" );
	TextureReadyInBackground( L"ColorBallGray.tga" );
}

void CX2GUEve::ENSI_EP_JUMP_COMBO_ZX_FrameMove()
{
	CommonFrameMove();
}

void CX2GUEve::ENSI_EP_JUMP_COMBO_ZX_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		m_fCanNotAttackTime = 0.1f; // 제자리 점프하면서 계속해서 공격하는 것을 막기 위해서

		StateChange( USI_JUMP_LANDING );
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_EP_COMBO_XXdownX_Init()
{
	XSkinMeshReadyInBackground( L"Eve_EP_ComboX2DX_Mesh01.X" );
	XSkinMeshReadyInBackground( L"Eve_EP_ComboX2DX_Mesh02.X" );
	XSkinMeshReadyInBackground( L"Eve_EP_Grenade_Mesh01.X" );
	TextureReadyInBackground( L"ColorBallFire.tga" );
	TextureReadyInBackground( L"smoke02.tga" );
	TextureReadyInBackground( L"DarkCloud02.tga" );
	TextureReadyInBackground( L"Arme_Damage_Center.tga"	);
}

void CX2GUEve::ENSI_EP_COMBO_XXdownX_FrameMove()
{
	CommonFrameMove();
}

void CX2GUEve::ENSI_EP_COMBO_XXdownX_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}

	if ( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}

	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXC
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.666667f )
		{
			m_fCanNotAttackTime = 0.1f;
			StateChange( USI_WAIT );
		}
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SA_ENS_ATOMIC_BLASTER_Init()
{
	XMeshReadyInBackground( L"Eve_Atomic_Blaster_GunFire01.Y" );
	XSkinMeshReadyInBackground( L"Eve_SI_SA_ENS_Atomic_Blaster_Mesh01.X" );
	XSkinMeshReadyInBackground( L"Eve_SI_SA_ENS_Atomic_Blaster_Mesh02.X" );
}

void CX2GUEve::ENSI_SA_ENS_ATOMIC_BLASTER_Start()
{
	CommonStateStart();

	for ( int i = MajorPID_ATOMIC_BLASTER_GUN; i <= MajorPID_ATOMIC_BLASTER_BULLET; i++ )
	{
		if ( m_ahMajorMeshInstance[i] != INVALID_MESH_INSTANCE_HANDLE )
		{
			g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle( m_ahMajorMeshInstance[i] );
			m_ahMajorMeshInstance[i] = INVALID_MESH_INSTANCE_HANDLE;
		}
	}
}

void CX2GUEve::ENSI_SA_ENS_ATOMIC_BLASTER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.01f, 0 );

	D3DXVECTOR3 vUnitPos	= GetPos();
	D3DXVECTOR3	vRotate		= GetRotateDegree();

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.07f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.07f ) == true && EventCheck( 0.07f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if ( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_GUN] == INVALID_MESH_INSTANCE_HANDLE )
		{
			CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_ATOMIC_BLASTER", GetPowerRate(),
				vUnitPos, vRotate, vRotate );

			if ( pEffect != NULL )
				m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_GUN] = pEffect->GetMainEffectHandle();
		}

		if ( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_BULLET] == INVALID_MESH_INSTANCE_HANDLE )
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this, L"Eve_SI_SA_ENS_Atomic_Blaster_Mesh02", vUnitPos,
				vRotate, vRotate );

			if ( pMeshInst != NULL )
			{
				m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_BULLET] = pMeshInst->GetHandle();
			}
		}
	}

	if ( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_GUN] != INVALID_MESH_INSTANCE_HANDLE )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_GUN] );

		if ( pMeshInst != NULL )
		{
			pMeshInst->SetPos( vUnitPos );
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Pelvis" );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.89f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			if ( m_pXSkinAnim->EventTimer( 0.89f ) == true && EventCheck( 0.89f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
				m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_DUMMY] == INVALID_MESH_INSTANCE_HANDLE )
			{
				CX2DamageEffect::CEffect* pEffectDummy = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_ATOMIC_BLASTER_DUMMY", GetPowerRate(),
					vBonePos, vRotate, vRotate );

				if ( pEffectDummy != NULL )
					m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_DUMMY] = pEffectDummy->GetMainEffectHandle();
			}
			else if ( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_DUMMY] != INVALID_MESH_INSTANCE_HANDLE )
			{
				CKTDGXMeshPlayer::CXMeshInstance* pMeshInstDummy = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_DUMMY] );

				if ( pMeshInstDummy != NULL )
				{
					pMeshInstDummy->SetPos( vBonePos );

					pMeshInstDummy->SetRotateDegree( pMeshInstDummy->GetRotateDegree() + D3DXVECTOR3( 0.0f, 0.0f, 1.2f ) );
				}
				else
					m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_DUMMY] = INVALID_MESH_INSTANCE_HANDLE;
			}
		}
		else
			m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_GUN] = INVALID_MESH_INSTANCE_HANDLE;
	}

	if ( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_BULLET] != INVALID_MESH_INSTANCE_HANDLE && m_pXSkinAnim->GetNowAnimationTime() < 1.62f )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_BULLET] );

		if ( pMeshInst != NULL )
			pMeshInst->SetPos( vUnitPos );
		else
			m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_BULLET] = INVALID_MESH_INSTANCE_HANDLE;
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_ENS_ATOMIC_BLASTER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
#ifdef BALANCE_CODE_NEMESIS_20121213
	ELSE_IF_ARROW_ZXASDC_PRESSED_AFTER( m_fAttackCancelAfter )
	{
		StateChange( USI_WAIT );
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
#else
	ELSE_IF_ARROW_ZXASDC_PRESSED_AFTER( 1.62f )
	{
		StateChange( USI_WAIT );
	}
#endif //BALANCE_CODE_NEMESIS_20121213

	CommonEventProcess();
}

void CX2GUEve::ENSI_SA_ENS_ATOMIC_BLASTER_End()
{
	CommonStateEnd();
}

void CX2GUEve::ENSI_SA_ENS_ATOMIC_BLASTER_Hyper_Init()
{
	ENSI_SA_ENS_ATOMIC_BLASTER_Init();
}

void CX2GUEve::ENSI_SA_ENS_ATOMIC_BLASTER_Hyper_Start()
{
	ENSI_SA_ENS_ATOMIC_BLASTER_Start();
}

void CX2GUEve::ENSI_SA_ENS_ATOMIC_BLASTER_Hyper_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.01f, 0 );

	D3DXVECTOR3 vUnitPos	= GetPos();
	D3DXVECTOR3	vRotate		= GetRotateDegree();

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.07f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.07f ) == true && EventCheck( 0.07f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if ( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_GUN] == INVALID_MESH_INSTANCE_HANDLE )
		{
			CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_ATOMIC_BLASTER", GetPowerRate(),
				vUnitPos, vRotate, vRotate );

			if ( pEffect != NULL )
				m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_GUN] = pEffect->GetMainEffectHandle();
		}

		if ( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_BULLET] == INVALID_MESH_INSTANCE_HANDLE )
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this, L"Eve_SI_SA_ENS_Atomic_Blaster_Mesh02", vUnitPos,
				vRotate, vRotate );

			if ( pMeshInst != NULL )
			{
				m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_BULLET] = pMeshInst->GetHandle();
			}
		}
	}

	if ( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_GUN] != INVALID_MESH_INSTANCE_HANDLE )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_GUN] );

		if ( pMeshInst != NULL )
		{
			pMeshInst->SetPos( vUnitPos );
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_Pelvis" );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.89f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
			if ( m_pXSkinAnim->EventTimer( 0.89f ) == true && EventCheck( 0.89f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
				m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_DUMMY] == INVALID_MESH_INSTANCE_HANDLE )
			{
				CX2DamageEffect::CEffect* pEffectDummy = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_ATOMIC_BLASTER_DUMMY_HYPER", GetPowerRate(),
					vBonePos, vRotate, vRotate );

				if ( pEffectDummy != NULL )
					m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_DUMMY] = pEffectDummy->GetMainEffectHandle();
			}
			else if ( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_DUMMY] != INVALID_MESH_INSTANCE_HANDLE )
			{
				CKTDGXMeshPlayer::CXMeshInstance* pMeshInstDummy = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_DUMMY] );

				if ( pMeshInstDummy != NULL )
				{
					pMeshInstDummy->SetPos( vBonePos );

					pMeshInstDummy->SetRotateDegree( pMeshInstDummy->GetRotateDegree() + D3DXVECTOR3( 0.0f, 0.0f, 1.2f ) );
				}
				else
					m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_DUMMY] = INVALID_MESH_INSTANCE_HANDLE;
			}
		}
		else
			m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_GUN] = INVALID_MESH_INSTANCE_HANDLE;
	}

	if ( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_BULLET] != INVALID_MESH_INSTANCE_HANDLE && m_pXSkinAnim->GetNowAnimationTime() < 1.62f )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_BULLET] );

		if ( pMeshInst != NULL )
			pMeshInst->SetPos( vUnitPos );
		else
			m_ahMajorMeshInstance[MajorPID_ATOMIC_BLASTER_BULLET] = INVALID_MESH_INSTANCE_HANDLE;
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_ENS_ATOMIC_BLASTER_Hyper_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
#ifdef BALANCE_CODE_NEMESIS_20121213
	ELSE_IF_ARROW_ZXASDC_PRESSED_AFTER( m_fAttackCancelAfter )
	{
		StateChange( USI_WAIT );
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
#else
	ELSE_IF_ARROW_ZXASDC_PRESSED_AFTER( 1.62f )
	{
		StateChange( USI_WAIT );
	}
#endif //BALANCE_CODE_NEMESIS_20121213

	CommonEventProcess();
}

void CX2GUEve::ENSI_SA_ENS_ATOMIC_BLASTER_Hyper_End()
{
	ENSI_SA_ENS_ATOMIC_BLASTER_End();
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_Init()
{
	XSkinMeshReadyInBackground( L"NS_BURST_SPEAR_Spear.X" );
	XSkinMeshReadyInBackground( L"NS_BURST_SPEAR_Spear_End.X" );
	XMeshReadyInBackground( L"Hexagon_impact01.Y" );
	XMeshReadyInBackground( L"Lire_Uplight01.Y" );
	TextureReadyInBackground( L"GroundShockWave.tga" );
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_Start()
{
	CommonStateStart();

	m_bDoneSpearBurst = false;
	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_FrameMove()
{
#ifdef BALANCE_PATCH_20110303
	if( IsSuperArmor() )
	{
		m_FrameDataNow.stateParam.bSuperArmorNotRed = false;
	}
#endif

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.15f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.15f ) == true && EventCheck( 0.15f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CreateSpearBurst();
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_EventProcess()
{
	if( true == IsOnSomethingFuture() )
		StateChange( ENSI_A_ENS_BURST_SPEAR_Landing );

	CommonEventProcess();
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_End()
{
	m_bDisableGravity = false;

	CommonStateEnd();
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_Hyper_Init()
{
	ENSI_A_ENS_BURST_SPEAR_Start();
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_Hyper_Start()
{
	ENSI_A_ENS_BURST_SPEAR_Start();
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_Hyper_FrameMove()
{
#ifdef BALANCE_PATCH_20110303
	if( IsSuperArmor() )
	{
		m_FrameDataNow.stateParam.bSuperArmorNotRed = false;
	}
#endif

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.15f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.15f ) == true && EventCheck( 0.15f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CreateSpearBurst();
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_Hyper_EventProcess()
{
	if( true == IsOnSomethingFuture() )
		StateChange( ENSI_A_ENS_BURST_SPEAR_Landing_HYPER );

	CommonEventProcess();
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_Hyper_End()
{
	ENSI_A_ENS_BURST_SPEAR_End();
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_Landing_FrameMove()
{
	if ( m_bDoneSpearBurst == false )
		CreateSpearBurst();

	CommonFrameMove();
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_Landing_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}
	ELSE_IF_ARROW_ASDC_PRESSED_AFTER( 0.3f )
	{
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_Landing_Hyper_FrameMove()
{
	if ( m_bDoneSpearBurst == false )
		CreateSpearBurst();

	CommonFrameMove();
}

void CX2GUEve::ENSI_A_ENS_BURST_SPEAR_Landing_Hyper_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}
	ELSE_IF_ARROW_ASDC_PRESSED_AFTER( 0.3f )
	{
		StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

// oasis907 : 김상윤 [2010.1.28] // 
void CX2GUEve::ENSI_SA_EEP_ELECTRONIC_FIELD_Init()
{
	XSkinMeshReadyInBackground( L"Eve_EP_SI_SA_Electronic_Field_Mesh01.X" );
	XMeshReadyInBackground( L"Lightning_Liner01.Y");
	TextureReadyInBackground( L"Lightning_Piercing02.tga" );
	TextureReadyInBackground( L"ColorBallGray.tga" );
	TextureReadyInBackground( L"Arme_Ring2.tga" );
	TextureReadyInBackground( L"Explosion_Sphere.tga" );
	TextureReadyInBackground( L"GroundShockWave.tga" );
	TextureReadyInBackground( L"Lire_Kick_Impact01.tga" );
	TextureReadyInBackground( L"Nasod_King_Laser03.tga" );
}
void CX2GUEve::ENSI_SA_EEP_ELECTRONIC_FIELD_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Bip01_Spine1", 0.01f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//여왕의 지배력 파워수치를 이펙트 셋에 전달.
		float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();
		if( g_pX2Game != NULL && g_pX2Game->GetEffectSet() != NULL )
		{
			CX2EffectSet::Handle hEField = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Eve_ELECTRONIC_FIELD", (CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned );
			if( hEField != INVALID_EFFECTSET_HANDLE )
				m_vecEffectSetToDeleteOnDamageReact.push_back(hEField);
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.18f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.18f ) == true && EventCheck( 0.18f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -130.f;
		}
		else
		{
			vPos -= GetDirVector() * -130.f;
		}
		vPos.y += 110.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_Spinliner01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotDegree1 = GetRotateDegree();
			D3DXVECTOR3 vRotDegree2 = GetRotateDegree();
			vRotDegree1 += D3DXVECTOR3( -180, 20, 90 );
			vRotDegree2 += D3DXVECTOR3( 180, 20, 90 );

			CKTDGParticleSystem::CParticleEvent_Rotate* pEventRotate = new CKTDGParticleSystem::CParticleEvent_Rotate();
			pEventRotate->SetActualTime( CMinMax<float>( 0.f, 0.f ) );
			pEventRotate->SetRotate( CMinMax<D3DXVECTOR3>( vRotDegree1, vRotDegree2 ) );

			pSeq->m_EventList.push_back( pEventRotate );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.2f ) == true && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -120.f;
		}
		else
		{
			vPos -= GetDirVector() * -120.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_Magicsquare01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotateDegree = GetRotateDegree();
			vRotateDegree += D3DXVECTOR3( 0, -70, -45 );

			pSeq->SetAddRotate( vRotateDegree );
			pSeq->SetAxisAngle( vRotateDegree );
		}


		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 70.f;
		}
		else
		{
			vPos -= GetDirVector() * 70.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_PinLight01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.23f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.23f ) == true && EventCheck( 0.23f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 110.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_Light01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
	CommonFrameMove();
}
void CX2GUEve::ENSI_SA_EEP_ELECTRONIC_FIELD_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXCAS
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 1.33333f )
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}
void CX2GUEve::ENSI_SA_EEP_ELECTRONIC_FIELD_Hyper_Init()
{
	XSkinMeshReadyInBackground( L"Eve_EP_SI_SA_Electronic_Field_Mesh01.X" );
	XMeshReadyInBackground( L"Lightning_Liner01.Y");
	TextureReadyInBackground( L"Lightning_Piercing02.tga" );
	TextureReadyInBackground( L"ColorBallGray.tga" );
	TextureReadyInBackground( L"Arme_Ring2.tga" );
	TextureReadyInBackground( L"Explosion_Sphere.tga" );
	TextureReadyInBackground( L"GroundShockWave.tga" );
	TextureReadyInBackground( L"Lire_Kick_Impact01.tga" );
	TextureReadyInBackground( L"Nasod_King_Laser03.tga" );
}
void CX2GUEve::ENSI_SA_EEP_ELECTRONIC_FIELD_Hyper_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Bip01_Spine1", 0.01f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//여왕의 지배력 파워수치를 이펙트 셋에 전달.
		float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();
		if( g_pX2Game != NULL && g_pX2Game->GetEffectSet() != NULL )
		{
			CX2EffectSet::Handle hEField = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Eve_ELECTRONIC_FIELD", (CX2GameUnit*)this, NULL, true, GetPowerRate() * fStatAtkRateOfSummoned );
			if( hEField != INVALID_EFFECTSET_HANDLE )
				m_vecEffectSetToDeleteOnDamageReact.push_back(hEField);
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.18f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.18f ) == true && EventCheck( 0.18f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -130.f;
		}
		else
		{
			vPos -= GetDirVector() * -130.f;
		}
		vPos.y += 110.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_Spinliner01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotDegree1 = GetRotateDegree();
			D3DXVECTOR3 vRotDegree2 = GetRotateDegree();
			vRotDegree1 += D3DXVECTOR3( -180, 20, 90 );
			vRotDegree2 += D3DXVECTOR3( 180, 20, 90 );

			CKTDGParticleSystem::CParticleEvent_Rotate* pEventRotate = new CKTDGParticleSystem::CParticleEvent_Rotate();
			pEventRotate->SetActualTime( CMinMax<float>( 0.f, 0.f ) );
			pEventRotate->SetRotate( CMinMax<D3DXVECTOR3>( vRotDegree1, vRotDegree2 ) );

			pSeq->m_EventList.push_back( pEventRotate );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.2f ) == true && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		D3DXVECTOR3 vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -120.f;
		}
		else
		{
			vPos -= GetDirVector() * -120.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_Magicsquare01", vPos );
		if( NULL != pSeq )
		{
			D3DXVECTOR3 vRotateDegree = GetRotateDegree();
			vRotateDegree += D3DXVECTOR3( 0, -70, -45 );

			pSeq->SetAddRotate( vRotateDegree );
			pSeq->SetAxisAngle( vRotateDegree );
		}


		vPos = GetPos();
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 70.f;
		}
		else
		{
			vPos -= GetDirVector() * 70.f;
		}
		vPos.y += 110.f;

		pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_PinLight01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.23f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.23f ) == true && EventCheck( 0.23f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetPos();
		vPos.y += 110.f;

		CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"Eve_Sp2a_Light01", vPos );
		if( NULL != pSeq )
		{
			pSeq->SetAddRotate( GetRotateDegree() );
			pSeq->SetAxisAngle( GetRotateDegree() );
		}
	}
	CommonFrameMove();
}
void CX2GUEve::ENSI_SA_EEP_ELECTRONIC_FIELD_Hyper_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXCAS
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 1.33333f )
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_A_EEP_SPIT_FIRE_Init()
{
	XSkinMeshReadyInBackground( L"Eve_EP_SI_SA_Spit_Fire_Mesh01.X" );
	XSkinMeshReadyInBackground( L"Eve_EP_SI_SA_Spit_Fire_Mesh02.X" );
	XMeshReadyInBackground( L"Wind_Liner02.Y" );
	TextureReadyInBackground( L"GuideArrow02.tga" );
	TextureReadyInBackground( L"ColorBallGray.tga" );
}

void CX2GUEve::ENSI_A_EEP_SPIT_FIRE_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//여왕의 지배력 파워수치를 이펙트 셋에 전달.
		float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();
		if( g_pX2Game != NULL && g_pX2Game->GetEffectSet() != NULL )
		{
			CX2EffectSet::Handle hSpitFire = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Eve_SPIT_FIRE", (CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned );
			if( hSpitFire != INVALID_EFFECTSET_HANDLE )
				m_vecEffectSetToDeleteOnDamageReact.push_back(hSpitFire);
		}
	}
	CommonFrameMove();
}
void CX2GUEve::ENSI_A_EEP_SPIT_FIRE_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXCAS
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 0.666667f )
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_A_EEP_SPIT_FIRE_Hyper_Init()
{
	XSkinMeshReadyInBackground( L"Eve_EP_SI_SA_Spit_Fire_Mesh01.X" );
	XSkinMeshReadyInBackground( L"Eve_EP_SI_SA_Spit_Fire_Mesh02.X" );
	XMeshReadyInBackground( L"Wind_Liner02.Y" );
	TextureReadyInBackground( L"GuideArrow02.tga" );
	TextureReadyInBackground( L"ColorBallGray.tga" );
}

void CX2GUEve::ENSI_A_EEP_SPIT_FIRE_Hyper_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//여왕의 지배력 파워수치를 이펙트 셋에 전달.
		float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();
		if( g_pX2Game != NULL && g_pX2Game->GetEffectSet() != NULL )
		{
			CX2EffectSet::Handle hSpitFire = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Eve_SPIT_FIRE", (CX2GameUnit*)this, NULL, true, GetPowerRate() * fStatAtkRateOfSummoned );
			if( hSpitFire != INVALID_EFFECTSET_HANDLE )
				m_vecEffectSetToDeleteOnDamageReact.push_back(hSpitFire);
		}
	}
	CommonFrameMove();
}
void CX2GUEve::ENSI_A_EEP_SPIT_FIRE_Hyper_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXCAS
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 0.666667f )
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}

#endif EVE_SECOND_CLASS_CHANGE
//}} kimhc // 2010.1.25 // 이브 2차 전직 대시 콤보


bool CX2GUEve::IsUpSkillSlotMegaElectronBall()
{
	bool bIsElectronBallSuccess = false;
	if( m_sMegaElectronBallData.m_bEnable == true )
	{
		//키가 업된는지 체크.
		switch( m_sMegaElectronBallData.GetSkillSlotID() )
		{
		case 0: if( m_InputData.pureA == false && m_InputData.oneA == false ) 
					bIsElectronBallSuccess = true;
			break;
		case 1: if( m_InputData.pureS == false && m_InputData.oneS == false ) 
					bIsElectronBallSuccess = true;
			break;
		case 2: if( m_InputData.pureD == false && m_InputData.oneD == false ) 
					bIsElectronBallSuccess = true;
			break;
		case 3: if( m_InputData.pureC == false && m_InputData.oneC == false ) 
					bIsElectronBallSuccess = true;
			break;
		case 4: if( m_InputData.pureQ == false && m_InputData.oneQ == false ) 
					bIsElectronBallSuccess = true;
			break;
		case 5: if( m_InputData.pureW == false && m_InputData.oneW == false ) 
					bIsElectronBallSuccess = true;
			break;
		case 6: if( m_InputData.pureE == false && m_InputData.oneE == false ) 
					bIsElectronBallSuccess = true;
			break;
		case 7: if( m_InputData.pureR == false && m_InputData.oneR == false ) 
					bIsElectronBallSuccess = true;
			break;

		default: // 시전시에 데이터 저장이 제대로 이루어 지지 않았을 경우.
			m_sMegaElectronBallData.Reset( false, &AccessFutureFrameData() );
			break;;
		}
	}

	return bIsElectronBallSuccess;
}


const CX2UserSkillTree::SkillSlotData* CX2GUEve::GetSkillSlotDataMegaElectronBall( IN const CX2UserSkillTree& cUserSkillTree_, OUT int& iSkillSlotIndexPressed_ )
{
	int iSlotIndex = (m_sMegaElectronBallData.GetSkillSlotID() > 3) ? m_sMegaElectronBallData.GetSkillSlotID()-4 : m_sMegaElectronBallData.GetSkillSlotID();
	bool bSlotB = (m_sMegaElectronBallData.GetSkillSlotID() > 3) ? true : false;

	const CX2UserSkillTree::SkillSlotData* pSkillSlotData = cUserSkillTree_.GetSkillSlot( iSlotIndex, bSlotB );
	if( CX2SkillTree::SI_NONE == pSkillSlotData->m_eID ||
		CX2SkillTree::SI_A_EN_MEGA_ELECTRONBALL != pSkillSlotData->m_eID)
	{
		m_sMegaElectronBallData.Reset( false, &AccessFutureFrameData() );
		return NULL;
	}

	// m_sMegaElectronBallData.Reset(); <= 예외처리를 하기위해
	
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( pSkillSlotData->m_eID );
#else // UPGRADE_SKILL_SYSTEM_2013
	const int iSkillLevel = cUserSkillTree_.GetSkillLevel( pSkillSlotData->m_eID );
	const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( pSkillSlotData->m_eID, iSkillLevel );
#endif // UPGRADE_SKILL_SYSTEM_2013
	if( NULL == pSkillTemplet )
	{
		m_sMegaElectronBallData.Reset( false, &AccessFutureFrameData() );
		return NULL;
	}

	// 메가일렉트론볼 정상 사용 완료
	m_sMegaElectronBallData.Reset( false, &AccessFutureFrameData() );
	iSkillSlotIndexPressed_ = m_sMegaElectronBallData.GetSkillSlotID();

	return pSkillSlotData;
}


//{{ kimhc // 2010.11.2 // 엠프레스 - 충전 추진기
#ifdef	NEW_SKILL_2010_11

/** @function : CX2GUEve::CanUseChargingBooster
@brief : 충전추진기 패시브가 발동 될 수 있는지를 확인 하는 함수
@param : 지금 사용한 스킬의 타입, 유저가 배운 스킬트리
@return : 사용할 수 있는지 여부( 사용할 수 있으면 true )
*/
bool CX2GUEve::CanUseChargingBooster( CX2SkillTree::SKILL_TYPE eSkillType_, const IN CX2UserSkillTree& cUserSkillTree_ )
{
	// 사용한 스킬의 타입이 스페셜인지 판단
	if ( CX2SkillTree::ST_SPECIAL_ACTIVE != eSkillType_ )
		return false;

	// 충전 추진기 스킬이 있는지 판단
	const CX2SkillTree::SkillTemplet* pChargingBoosterTemplet = cUserSkillTree_.GetUserSkillTemplet( CX2SkillTree::SI_P_EEP_CHARGING_BOOSTER );

	if ( NULL == pChargingBoosterTemplet )
		return false;

	// 발동 확률을 판단 후

#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	const int iSkillTempletLevel = max( 1, cUserSkillTree_.GetSkillLevel( CX2SkillTree::SI_P_EEP_CHARGING_BOOSTER, true ) );	/// 스킬 레벨

	float fRateChargingBooster = pChargingBoosterTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_RATE, iSkillTempletLevel );
#else // UPGRADE_SKILL_UI
	float fRateChargingBooster = pChargingBoosterTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_RATE );
#endif // UPGRADE_SKILL_UI
	
	if ( GetRandomFloat() > fRateChargingBooster )
		return false;

	if( false == m_ChargingBoosterSkillDataBasePtr->IsEndCoolTime() )
		return false;

	// 발동

	return true;
}

/** @function : CX2GUEve::UseChargingBooster
@brief : 충전추진기를 사용함. 스킬슬롯에 장착된 모든 스킬의 재발동 시간이 초기화 됨
@param : 유저가 배운 스킬 트리
@return : 없음
*/
void CX2GUEve::UseChargingBooster( CX2UserSkillTree& pcUserSkillTree_ )
{
	const CX2SkillTree::SkillTemplet* pSkillTempletChargingBooster
		= pcUserSkillTree_.GetUserSkillTemplet( CX2SkillTree::SI_P_EEP_CHARGING_BOOSTER );
	SpecialAttackNoStageChange( pSkillTempletChargingBooster );

	m_ChargingBoosterSkillDataBasePtr->SetTimerBasedOnCoolTime( m_ChargingBoosterSkillDataBasePtr->GetCoolTime() );
	pcUserSkillTree_.ResetLeftSkillCoolTimeAll();
}

#endif	NEW_SKILL_2010_11
//}} kimhc // 2010.11.2 // 엠프레스 - 충전 추진기



#ifdef NEW_SKILL_2010_11
//{{ JHKang / 강정훈 / 2010/11/08 / 어설트 스피어
/** 
@function ENSI_SA_EAT_ASSUALT_SPEAR_Init
@brief 관련된 리소스 로딩
- 메쉬 : 오필리아, 오베론, 창(애니메이션 통합), 창(애니메이션 분리) 등
*/
void CX2GUEve::ENSI_SA_EAT_ASSUALT_SPEAR_Init()
{
	XSkinMeshReadyInBackground( L"Sp2a_Oberon01.X" );
	XSkinMeshReadyInBackground( L"Sp2a_Ophelia01.X" );
	XSkinMeshReadyInBackground( L"Sp2a_Spear.X" );
	XSkinMeshReadyInBackground( L"Sp2a_Spear_Explosion.X" );
	XSkinMeshReadyInBackground( L"Sp2a_Spear_Fly.X" );
	XSkinMeshReadyInBackground( L"Sp2a_Spear_Ready.X" );
	XSkinMeshReadyInBackground( L"DummyAttackBox_50x50x50.X" );
	TextureReadyInBackground( L"Mesh_ASSUALT_SPEAR.tga" );
	TextureReadyInBackground( L"Eve_Guardian_Ophelia_Face.tga" );
	TextureReadyInBackground( L"Eve_Guardian_Ophelia_Lowbody.tga" );
	TextureReadyInBackground( L"Eve_Guardian_Ophelia_Upbody.tga" );
	TextureReadyInBackground( L"GUARDIAN_EVE_Hair.tga" );
	TextureReadyInBackground( L"GUARDIAN_EVE_Hand.tga" );
	TextureReadyInBackground( L"GUARDIAN_EVE_Lowbody.tga" );
	TextureReadyInBackground( L"GUARDIAN_EVE_Upbody.tga" );
}

/** 
@function ENSI_SA_EAT_ASSUALT_SPEAR_FrameMove
@brief 애니메이션 및 데미지 이펙트 출력(중요)
- 1차 : 애니메이션 타임 폭발 테스트(코드 제거)
- 2차 : 라인맵 충돌시 폭발로 변경
*/
void CX2GUEve::ENSI_SA_EAT_ASSUALT_SPEAR_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Bip01_L_Finger11", 0.01f, 2 );
#ifdef 	BALANCE_PATCH_20131107
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimerOneshot( 0.3f ) ) 
#else	X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#endif	X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
#else	BALANCE_PATCH_20131107
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.266f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.266f ) == true && EventCheck( 0.266f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
#endif	BALANCE_PATCH_20131107
	{
		D3DXVECTOR3 vPos = GetBonePos( L"Bip01_Head" );

		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -135.f * GetScaleByUnit().x;
		}
		else
		{
			vPos -= GetDirVector() * -135.f * GetScaleByUnit().x;
		}
		vPos.y += 435.f * GetScaleByUnit().y;

#ifdef BALANCE_PATCH_20131107
		vPos.x -= 10.f;
		vPos.y -= 10.f;
#endif //BALANCE_PATCH_20131107

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SA_EAT_ASSUALT_SPEAR_READY", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );

		vPos = GetPos();

		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -250.f * GetScaleByUnit().x;
		}
		else
		{
			vPos -= GetDirVector() * -250.f * GetScaleByUnit().x;
		}

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SA_EAT_ASSUALT_SPEAR_EFFECT2", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SI_SA_EAT_ASSUALT_SPEAR_OPHILIA_NO_DAMAGE", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SI_SA_EAT_ASSUALT_SPEAR_OBERON_NO_DAMAGE", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 1.199f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 1.199f ) == true && EventCheck( 1.199f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetBonePos( L"Bip01_Head" );
#ifdef BALANCE_PATCH_20131107
		vPos.y += 285.f * GetScaleByUnit().y;
#else //BALANCE_PATCH_20131107
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 175.f * GetScaleByUnit().x;
		}
		else
		{
			vPos -= GetDirVector() * 175.f * GetScaleByUnit().x;
		}
		vPos.y += 135.f * GetScaleByUnit().y;
#endif //BALANCE_PATCH_20131107

		/// 여왕의 지배력 영향력을 주기 위해 데미지 이펙트만 코드로 빼냄.
		float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SA_EAT_ASSUALT_SPEAR", GetPowerRate() * fStatAtkRateOfSummoned,
			vPos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );
	}

	CommonFrameMove();
}

/** 
@function ENSI_SA_EAT_ASSUALT_SPEAR_EventProcess
@brief 이벤트 처리
*/
void CX2GUEve::ENSI_SA_EAT_ASSUALT_SPEAR_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
#ifdef BALANCE_PATCH_20120329
	WALK_CANCEL_AFTER( m_fWalkCancelAfter )
#endif
		ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXCAS
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 3.0f )
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}

/** 
@function ENSI_SA_EAT_ASSUALT_SPEAR_HYPER_FrameMove
@brief 각성
*/
void CX2GUEve::ENSI_SA_EAT_ASSUALT_SPEAR_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Bip01_L_Finger11", 0.01f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
#ifdef 	BALANCE_PATCH_20131107
    if ( m_pXSkinAnim->EventTimerOneshot( 0.3f ) )
#else	BALANCE_PATCH_20131107
    if ( m_pXSkinAnim->EventTimerOneshot( 0.266f ) )
#endif	BALANCE_PATCH_20131107
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
#ifdef BALANCE_PATCH_20131107
	if ( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#else //BALANCE_PATCH_20131107
	if ( m_pXSkinAnim->EventTimer( 0.266f ) == true && EventCheck( 0.266f, false ) == true )
#endif //BALANCE_PATCH_20131107
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetBonePos( L"Bip01_Head" );

		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -135.f * GetScaleByUnit().x;
		}
		else
		{
			vPos -= GetDirVector() * -135.f * GetScaleByUnit().x;
		}
		vPos.y += 435.f * GetScaleByUnit().y;

#ifdef BALANCE_PATCH_20131107
		vPos.x -= 10.f;
		vPos.y -= 10.f;
#endif //BALANCE_PATCH_20131107

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SA_EAT_ASSUALT_SPEAR_READY", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );

		vPos = GetPos();

		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * -250.f * GetScaleByUnit().x;
		}
		else
		{
			vPos -= GetDirVector() * -250.f * GetScaleByUnit().x;
		}

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SA_EAT_ASSUALT_SPEAR_EFFECT2", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SI_SA_EAT_ASSUALT_SPEAR_OPHILIA_NO_DAMAGE", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SI_SA_EAT_ASSUALT_SPEAR_OBERON_NO_DAMAGE", GetPowerRate(),
			vPos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 1.199f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 1.199f ) == true && EventCheck( 1.199f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vPos = GetBonePos( L"Bip01_Head" );
#ifdef BALANCE_PATCH_20131107
		vPos.y += 285.f * GetScaleByUnit().y;
#else //BALANCE_PATCH_20131107
		if( true == GetIsRight() )
		{
			vPos += GetDirVector() * 175.f * GetScaleByUnit().x;
		}
		else
		{
			vPos -= GetDirVector() * 175.f * GetScaleByUnit().x;
		}
		vPos.y += 135.f * GetScaleByUnit().y;
#endif //BALANCE_PATCH_20131107

		/// 여왕의 지배력 영향력을 주기 위해 데미지 이펙트만 코드로 빼냄.
		float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();

		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SA_EAT_ASSUALT_SPEAR", GetPowerRate() * fStatAtkRateOfSummoned,
			vPos, GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );
	}

	CommonFrameMove();
}

/** 
@function ENSI_SA_EAT_ASSUALT_SPEAR_HYPER_EventProcess
@brief 각성
*/
void CX2GUEve::ENSI_SA_EAT_ASSUALT_SPEAR_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
#ifdef BALANCE_PATCH_20120329
	WALK_CANCEL_AFTER( m_fWalkCancelAfter )
#endif
		ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXCAS
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 3.0f )
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}
//}} JHKang / 강정훈 / 2010/11/08 / 어설트 스피어

//{{ JHKang / 강정훈 / 2010/11/12 / 아토믹 쉴드
/** 
@function ENSI_SA_EEG_ATOMIC_SHIELD_Init
@brief 관련된 리소스 로딩
- 6개의 나노 머신, 보호막 이미지
*/
void CX2GUEve::ENSI_SA_EEG_ATOMIC_SHIELD_Init()
{
	XSkinMeshReadyInBackground( L"ATOMIC_SHIELD_nasod1.X" );
	XSkinMeshReadyInBackground( L"ATOMIC_SHIELD_nasod_loop1.X" );
	XSkinMeshReadyInBackground( L"ATOMIC_SHIELD_nasod_loop2.X" );
	XSkinMeshReadyInBackground( L"ATOMIC_SHIELD_nasod_loop3.X" );
	XSkinMeshReadyInBackground( L"ATOMIC_SHIELD_nasod_loop4.X" );
	XSkinMeshReadyInBackground( L"ATOMIC_SHIELD_nasod_loop5.X" );
	XSkinMeshReadyInBackground( L"ATOMIC_SHIELD_nasod_loop6.X" );
	TextureReadyInBackground( L"Mesh_ENERGY_OF_CONCENTRATION.tga" );
	TextureReadyInBackground( L"Arme_smoke.tga" );
	TextureReadyInBackground( L"Barrier_Ball_AS02.tga" );
	TextureReadyInBackground( L"atomic_eve.tga" );
}

/** 
@function ENSI_SA_EEG_ATOMIC_SHIELD_StateStart
@brief 이동하면서 스킬 사용 시 이펙트 밀리는 현상 제거
*/
void CX2GUEve::ENSI_SA_EEG_ATOMIC_SHIELD_StateStart()
{
	CommonStateStart();

	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );
}

/** 
@function ENSI_SA_EEG_ATOMIC_SHIELD_FrameMove
@brief 0.02sec : 쉴드 초기 이펙트, 0.8sec : 버프용 데미지 이펙터, NPC 쉴드 소환(적 타격에 의한 체력 감소)
*/
void CX2GUEve::ENSI_SA_EEG_ATOMIC_SHIELD_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Bip01_L_Hand", 0.02f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.02f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.02f ) == true && EventCheck( 0.02f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet(CX2SkillTree::SI_SA_ENS_ATOMIC_SHIELD);
		if( NULL != pSkillTemplet )
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		if ( NULL == GetUnit() )
			return;

		const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

		const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( CX2SkillTree::SI_SA_ENS_ATOMIC_SHIELD ) );	/// 스킬 레벨

		/// 쉴드 크기
		float fShieldSize = (float)pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SIZE_ABS, iSkillTempletLevel );
	#else // UPGRADE_SKILL_UI
			/// 쉴드 크기
			float fShieldSize = (float)pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SIZE_ABS );
	#endif // UPGRADE_SKILL_UI

			D3DXVECTOR3 vPos = GetPos();

			D3DXVECTOR3 vScale( fShieldSize / 450.f * GetScaleByUnit().x, fShieldSize / 450.f * GetScaleByUnit().y,
				fShieldSize /450.f * GetScaleByUnit().z );

			if( true == GetIsRight() )
			{
				vPos += 40 * GetDirVector() * GetScaleByUnit().x * fShieldSize / 450.f;
			}
			else
			{
				vPos -= 40 * GetDirVector() * GetScaleByUnit().x * fShieldSize / 450.f;
			}
			vPos.y += 220 * GetScaleByUnit().y * fShieldSize / 450.f;

			/// 초기 이펙트
			CX2EffectSet::Handle hAtomicShield = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EVE_ATOMIC_SHIELD_INIT", this, NULL );
			if( INVALID_EFFECTSET_HANDLE != hAtomicShield )
			{
				if ( CX2EffectSet::EffectSetInstance* pAtomicShield = g_pX2Game->GetEffectSet()->GetEffectSetInstance( hAtomicShield ) )
				{
					pAtomicShield->SetEffectScale( vScale );
					pAtomicShield->m_bCustomPosition = true;
					pAtomicShield->m_vPosition = vPos;
				}
			}
		}
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.8f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.8f ) == true && EventCheck( 0.8f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		// 기존에 소환된 몬스터가 있으면 자폭 시키고 다시 소환한다
		SetSelfDestructSummonedNPC( CX2UnitManager::NUI_ATOMIC_SHIELD_EVE );


		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet(CX2SkillTree::SI_SA_ENS_ATOMIC_SHIELD);
		if( NULL != pSkillTemplet )
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			if ( NULL == GetUnit() )
				return;

			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( CX2SkillTree::SI_SA_ENS_ATOMIC_SHIELD ) );	/// 스킬 레벨

			/// 쉴드 지속 시간 설정(NPC)
			float fEffectTime = (float)pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillTempletLevel );
			/// 쉴드 크기
			float fShieldSize = (float)pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SIZE_ABS, iSkillTempletLevel );
	#else // UPGRADE_SKILL_UI
				/// 쉴드 지속 시간 설정(NPC)
				float fEffectTime = (float)pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME );
				/// 쉴드 크기
				float fShieldSize = (float)pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SIZE_ABS );
	#endif // UPGRADE_SKILL_UI

			D3DXVECTOR3 vPos = GetBonePos( L"Bip01_Head" );

			if( true == GetIsRight() )
			{
				vPos += GetDirVector() * GetScaleByUnit().x * fShieldSize / 450.f;
			}
			else
			{
				vPos -= GetDirVector() * GetScaleByUnit().x * fShieldSize / 450.f;
			}
			vPos.y += GetScaleByUnit().y * fShieldSize / 450.f;

			if( true == g_pX2Game->IsHost() )
			{
				int iHyperMode = 0;

				/// NPC
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_ATOMIC_SHIELD_EVE, iHyperMode, true, vPos, 
					GetIsRight(), 0.f, true, int(pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_DAMAGED_REL, iSkillTempletLevel ) * 100),
					(CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID(), false, (CX2Room::TEAM_NUM) GetTeam() );
	#else // UPGRADE_SKILL_SYSTEM_2013
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_ATOMIC_SHIELD_EVE, iHyperMode, true, vPos, 
					GetIsRight(), 0.f, true, int(pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_DAMAGED_REL ) * 100),
					(CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID(), false, (CX2Room::TEAM_NUM) GetTeam() );
	#endif // UPGRADE_SKILL_SYSTEM_2013

				m_fAtomicShieldLifeTime = fEffectTime;
				m_timerAtomicShieldSummoned.restart();
			}
		}
	}

	CommonFrameMove();
}

/**
@function ENSI_SA_EEG_ATOMIC_SHIELD_EventProcess
@brief 이벤트 처리
*/
void CX2GUEve::ENSI_SA_EEG_ATOMIC_SHIELD_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
#ifdef BALANCE_CODE_NEMESIS_20121213
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
#endif //BALANCE_CODE_NEMESIS_20121213

	CommonEventProcess();
}

/** 
@function ENSI_SA_EEG_ATOMIC_SHIELD_StateStart
@brief 각성
*/
void CX2GUEve::ENSI_SA_EEG_ATOMIC_SHIELD_HYPER_StateStart()
{
	CommonStateStart();

	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );
}

/** 
@function ENSI_SA_EEG_ATOMIC_SHIELD_HYPER_FrameMove
@brief 각성
*/
void CX2GUEve::ENSI_SA_EEG_ATOMIC_SHIELD_HYPER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Bip01_L_Hand", 0.02f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if ( m_pXSkinAnim->EventTimerOneshot( 0.02f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if ( m_pXSkinAnim->EventTimer( 0.02f ) == true && EventCheck( 0.02f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet(CX2SkillTree::SI_SA_ENS_ATOMIC_SHIELD);
		if( NULL != pSkillTemplet )
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			if ( NULL == GetUnit() )
				return;

			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( CX2SkillTree::SI_SA_ENS_ATOMIC_SHIELD ) );	/// 스킬 레벨

			/// 쉴드 크기
			float fShieldSize = (float)pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SIZE_ABS, iSkillTempletLevel );
	#else // UPGRADE_SKILL_UI
			/// 쉴드 크기
			float fShieldSize = (float)pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SIZE_ABS );
	#endif // UPGRADE_SKILL_UI
			D3DXVECTOR3 vPos = GetPos();

			D3DXVECTOR3 vScale( fShieldSize / 450.f * GetScaleByUnit().x, fShieldSize / 450.f * GetScaleByUnit().y,
				fShieldSize /450.f * GetScaleByUnit().z );

			if( true == GetIsRight() )
			{
				vPos += 40 * GetDirVector() * GetScaleByUnit().x * fShieldSize / 450.f;
			}
			else
			{
				vPos -= 40 * GetDirVector() * GetScaleByUnit().x * fShieldSize / 450.f;
			}
			vPos.y += 220 * GetScaleByUnit().y * fShieldSize / 450.f;

			/// 초기 이펙트
			CX2EffectSet::Handle hAtomicShield = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EVE_ATOMIC_SHIELD_INIT", this, NULL );
			if( INVALID_EFFECTSET_HANDLE != hAtomicShield )
			{
				if ( CX2EffectSet::EffectSetInstance* pAtomicShield = g_pX2Game->GetEffectSet()->GetEffectSetInstance( hAtomicShield ) )
				{
					pAtomicShield->SetEffectScale( vScale );
					pAtomicShield->m_bCustomPosition = true;
					pAtomicShield->m_vPosition = vPos;
				}
			}
		}
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.8f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.8f ) == true && EventCheck( 0.8f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		// 기존에 소환된 몬스터가 있으면 자폭 시키고 다시 소환한다
		SetSelfDestructSummonedNPC( CX2UnitManager::NUI_ATOMIC_SHIELD_EVE );


		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet(CX2SkillTree::SI_SA_ENS_ATOMIC_SHIELD);
		if( NULL != pSkillTemplet )
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			if ( NULL == GetUnit() )
				return;

			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨

			/// 쉴드 지속 시간 설정(NPC)
			float fEffectTime = (float)pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillTempletLevel );
			/// 쉴드 크기
			float fShieldSize = (float)pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SIZE_ABS, iSkillTempletLevel );
	#else // UPGRADE_SKILL_UI
			/// 쉴드 지속 시간 설정(NPC)
			float fEffectTime = (float)pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME );
			/// 쉴드 크기
			float fShieldSize = (float)pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SIZE_ABS );
	#endif // UPGRADE_SKILL_UI

			D3DXVECTOR3 vPos = GetBonePos( L"Bip01_Head" );

			if( true == GetIsRight() )
			{
				vPos += GetDirVector() * GetScaleByUnit().x * fShieldSize / 450.f;
			}
			else
			{
				vPos -= GetDirVector() * GetScaleByUnit().x * fShieldSize / 450.f;
			}
			vPos.y += GetScaleByUnit().y * fShieldSize / 450.f;

			if( true == g_pX2Game->IsHost() )
			{
				int iHyperMode = 1;

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
				/// NPC
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_ATOMIC_SHIELD_EVE, iHyperMode, true, vPos, 
					GetIsRight(), 0.f, true, int(pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_DAMAGED_REL, iSkillTempletLevel ) * 100),
					(CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID(),false, (CX2Room::TEAM_NUM) GetTeam() );
	#else // UPGRADE_SKILL_SYSTEM_2013
				/// NPC
				g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_ATOMIC_SHIELD_EVE, iHyperMode, true, vPos, 
					GetIsRight(), 0.f, true, int(pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_DAMAGED_REL ) * 100),
					(CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID(),false, (CX2Room::TEAM_NUM) GetTeam() );
	#endif // UPGRADE_SKILL_SYSTEM_2013

				m_fAtomicShieldLifeTime = fEffectTime;
				m_timerAtomicShieldSummoned.restart();
			}
		}
	}

	CommonFrameMove();
}

/** 
@function ENSI_SA_EEG_ATOMIC_SHIELD_HYPER_EventProcess
@brief 각성
*/
void CX2GUEve::ENSI_SA_EEG_ATOMIC_SHIELD_HYPER_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
#ifdef BALANCE_CODE_NEMESIS_20121213
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
#endif //BALANCE_CODE_NEMESIS_20121213
	ELSE_IF_KEY_PRESSED_AT_SKIP_POINT_ZXCAS
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 2.640f )
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}
//}} JHKang / 강정훈 / 2010/11/12 / 아토믹 쉴드
#endif NEW_SKILL_2010_11



#ifdef EVE_ELECTRA
CX2GUEve::EveElectraLaserData::EveElectraLaserData( EveElectraSystem* _pEveElectraSystem )
{
	m_pEveElectraSystem	= _pEveElectraSystem;
	m_AmplifyDamageEffectName	= L"";
	m_SpectrumDamageEffectName	= L"";
	m_bPlaneFront		= false;
	m_bDie				= false;
	m_TraceBone			= L"";
	m_fVelocity			= 0.f;
	m_fLaserPropagateTime	= 0.f;
	m_fElapsedTime		= 0.f;
	m_fPenetrateTime	= 0.f;
	m_fLaserWidthScale	= 1.f;
	m_bPenetrate		= false;
	m_bPenetrateGiga[0]	= false;
	m_bPenetrateGiga[1]	= false;
	m_bPenetrateGiga[2]	= false;
	m_bPenetrateGiga[3]	= false;
	m_hParticleLaserCross			= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleGigaLaserCross[0]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleGigaLaserCross[1]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleGigaLaserCross[2]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleGigaLaserCross[3]	= INVALID_PARTICLE_SEQUENCE_HANDLE;

	m_bApplyLaserRangePassive		= false;
#ifdef SERV_EVE_BATTLE_SERAPH
	m_InductionDamageEffectName	= L"";
	m_iFireCount		= 0;
#endif
}
void CX2GUEve::EveElectraLaserData::OnFrameMove( float fElapsedTime )
{
	D3DXVECTOR3 vRotateDegree;
	m_fElapsedTime += fElapsedTime;

    CX2DamageEffect::CEffect* pDamageEffect0 = ( m_vecDamageEffect.size() > 0 ) ? g_pX2Game->GetDamageEffect()->GetInstance( m_vecDamageEffect[0] ) : NULL;
	if( CKTDGXMeshPlayer::CXMeshInstance *pMainEffect0 = ( pDamageEffect0 != NULL ) ? pDamageEffect0->GetMainEffect() : NULL )
	{
		vRotateDegree = pMainEffect0->GetRotateLocalDegree();

		D3DXVECTOR3 vRotationAxis;
		D3DXVec3Cross( &vRotationAxis, &m_vDirVector, &Y_AXIS );
		D3DXVec3Normalize( &vRotationAxis, &vRotationAxis );


		D3DXMATRIX matRotation;
		D3DXMatrixRotationAxis( &matRotation, &vRotationAxis, D3DX_PI / 180.f * vRotateDegree.z );

		D3DXVECTOR4 v4DirVectorLaser;
		D3DXVec3Transform( &v4DirVectorLaser, &m_vDirVector, &matRotation );

		D3DXVECTOR3 vDirVectorLaser = v4DirVectorLaser;


		pDamageEffect0->SetPos( m_vLaserStartPos );

		D3DXVECTOR3 vLaserNowPos = m_vLaserStartPos + ( m_fVelocity * m_fElapsedTime * vDirVectorLaser );
		D3DXVECTOR3 vLaserEndPos = m_vLaserStartPos + ( m_fVelocity * m_fLaserPropagateTime * m_pEveElectraSystem->m_fLaserRangeScale * vDirVectorLaser );

		if( m_fElapsedTime > m_fLaserPropagateTime * m_pEveElectraSystem->m_fLaserRangeScale)
		{
			vLaserNowPos = vLaserEndPos;
		}

		D3DXVECTOR3 vPlaneIntersectPoint;
		D3DXPlaneIntersectLine( &vPlaneIntersectPoint, &m_pEveElectraSystem->m_PrimaryPlane, &vLaserEndPos, &m_vLaserStartPos );

		if( m_pEveElectraSystem->GetEnablePlane() == false )	// 역장이 없을 때
		{

			if( m_pEveElectraSystem->GetEnableGigaPlane() == false )
			{
				const float MAGIC_LASER_LENGTH = 0.01f;
				float fLaserLength = D3DXVec3Length( &( vLaserNowPos - m_vLaserStartPos ) );
				fLaserLength *= MAGIC_LASER_LENGTH;

				pMainEffect0->SetScale( fLaserLength, m_fLaserWidthScale, 1.f );

				if( m_vecDamageEffect.size() > 1 )
				{
					for(UINT i = 1; i < m_vecDamageEffect.size(); i++ )
					{
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
                        if ( m_vecDamageEffect[i] != INVALID_DAMAGE_EFFECT_HANDLE )
                            g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_vecDamageEffect[i] );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
						if( m_vecDamageEffect[i] != NULL )
                        {
							g_pX2Game->GetDamageEffect()->DestroyInstance( m_vecDamageEffect[i] );
                            m_vecDamageEffect[i] = NULL;
                        }
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
					}
				}
			}
			//////////// GIGA STREAM ////////////////////////////////////////////////////////{{
			else
			{
				D3DXVECTOR3 vGigaPlaneIntersectPoint;
				D3DXPlaneIntersectLine( &vGigaPlaneIntersectPoint, &m_pEveElectraSystem->m_GigaStreamPlane, &vLaserEndPos, &m_vLaserStartPos );

				if( D3DXPlaneDotCoord( &m_pEveElectraSystem->m_GigaStreamPlane, &D3DXVECTOR3( vLaserNowPos ) ) < 0.0f )
				{
					const float MAGIC_LASER_LENGTH = 0.01f;
					float fLaserLength = D3DXVec3Length( &( vLaserNowPos - m_vLaserStartPos ) );
					fLaserLength *= MAGIC_LASER_LENGTH;

					pMainEffect0->SetScale( fLaserLength, m_fLaserWidthScale, 1.f );
				}
				else
				{

					const float MAGIC_LASER_LENGTH = 0.01f;
					float fLaserLength = D3DXVec3Length( &( vGigaPlaneIntersectPoint - m_vLaserStartPos ) );
					fLaserLength *= MAGIC_LASER_LENGTH;

					pMainEffect0->SetScale( fLaserLength, m_fLaserWidthScale, 1.f );

					if( m_bPenetrate == false )
					{
						CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( m_pEveElectraSystem->m_pGUEve, m_AmplifyDamageEffectName.c_str(), m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vGigaPlaneIntersectPoint, m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), 
							0, false, -1.f, 1.f, 1.f, -1, -1.f, 0, -1.f, true );
						m_pEveElectraSystem->LaserAttackLineSet( pEffect );
                        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                        {
						    pMeshInstance->SetNowLifeTime( pMainEffect0->GetNowLifeTime() );
						    pMeshInstance->SetMaxLifeTime( pMainEffect0->GetMaxLifeTime() );
                        }
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
						pEffect->SetLaserGroupID( pDamageEffect0->GetLaserGroupID() );
#else //UPGRADE_SKILL_SYSTEM_2013
						pEffect->SetLaserGroupID( 1 );
#endif //UPGRADE_SKILL_SYSTEM_2013
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
                        m_vecDamageEffect.push_back( pEffect->GetHandle() );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
						m_vecDamageEffect.push_back( pEffect );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

						CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
						*pDamageData = pDamageEffect0->GetDamageData();
#ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			            pDamageData->hAttackerEffect = pEffect->GetHandle();
#else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
						pDamageData->pAttackerEffect = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
						pDamageData->m_iLaserGroupID = pDamageEffect0->GetLaserGroupID();
#else //UPGRADE_SKILL_SYSTEM_2013
						pDamageData->m_iLaserGroupID = 1;
#endif //UPGRADE_SKILL_SYSTEM_2013

						pDamageData->damage.fPhysic *= 2.0f;
						pDamageData->damage.fMagic *= 2.0f;


						m_hParticleLaserCross = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pEveElectraSystem->m_pGUEve,  L"eve_spectro_giga_bump_P01", vGigaPlaneIntersectPoint );
						CKTDGParticleSystem::CParticleEventSequence* pSeqLaserCross = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleLaserCross );
						if( pSeqLaserCross != NULL )
						{
							pSeqLaserCross->SetScaleFactor( D3DXVECTOR3( m_fLaserWidthScale * 0.7f, m_fLaserWidthScale * 0.7f, m_fLaserWidthScale * 0.7f ) );
							D3DXVECTOR3 vRotateDegree = m_pEveElectraSystem->m_pGUEve->GetRotateDegree();
							vRotateDegree.z = m_pEveElectraSystem->m_fPlaneZAngle;
							pSeqLaserCross->SetAxisAngle( vRotateDegree );
							pSeqLaserCross->SetAddRotate( vRotateDegree );
						}	

						m_bPenetrate = true;
					}

                    CX2DamageEffect::CEffect* pDamageEffect1 = ( m_vecDamageEffect.size() > 1 ) ? g_pX2Game->GetDamageEffect()->GetInstance( m_vecDamageEffect[1] ) : NULL;
					if( CKTDGXMeshPlayer::CXMeshInstance *pMainEffect1 = ( pDamageEffect1 != NULL ) ? pDamageEffect1->GetMainEffect() : NULL )
					{

						pDamageEffect1->SetPos( vGigaPlaneIntersectPoint );

						D3DXVECTOR3 vSecondRotateDegree = vRotateDegree; 

						vSecondRotateDegree.z += m_pEveElectraSystem->m_fPlaneZAngle + vSecondRotateDegree.z * 0.8f;

						pMainEffect1->SetRotateLocalDegree( vSecondRotateDegree );

						float fSecondLaserLength = D3DXVec3Length( &( vLaserNowPos - vGigaPlaneIntersectPoint ) );
						fSecondLaserLength *= MAGIC_LASER_LENGTH;
						pMainEffect1->SetScale( fSecondLaserLength, m_fLaserWidthScale * 5.0f, 1.f );

						pMainEffect1->SetMeshAlphaColor( pMainEffect0->GetMeshAlphaColor() );

					}


				}
				CKTDGParticleSystem::CParticleEventSequence* pSeqLaserCross = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleLaserCross );
				if( pSeqLaserCross != NULL )
				{
					pSeqLaserCross->SetPosition( vGigaPlaneIntersectPoint );
				}
			}
			//////////// GIGA STREAM ////////////////////////////////////////////////////////}}
		}
		else if( D3DXPlaneDotCoord( &m_pEveElectraSystem->m_PrimaryPlane, &D3DXVECTOR3( vLaserNowPos ) ) < 0.0f )
		{
			const float MAGIC_LASER_LENGTH = 0.01f;
			float fLaserLength = D3DXVec3Length( &( vLaserNowPos - m_vLaserStartPos ) );
			fLaserLength *= MAGIC_LASER_LENGTH;

			pMainEffect0->SetScale( fLaserLength, m_fLaserWidthScale, 1.f );
		}
		else if( m_fPenetrateTime > 0.f )
		{
			m_fPenetrateTime -= fElapsedTime;
			m_fElapsedTime -= fElapsedTime;

			const float MAGIC_LASER_LENGTH = 0.01f;
			float fLaserLength = D3DXVec3Length( &( vPlaneIntersectPoint - m_vLaserStartPos ) );
			fLaserLength *= MAGIC_LASER_LENGTH;

			pMainEffect0->SetScale( fLaserLength, m_fLaserWidthScale, 1.f );

		}
		else	// 역장이 있을 시
		{
			const float MAGIC_LASER_LENGTH = 0.01f;
			float fLaserLength = D3DXVec3Length( &( vPlaneIntersectPoint - m_vLaserStartPos ) );
			fLaserLength *= MAGIC_LASER_LENGTH;

			pMainEffect0->SetScale( fLaserLength, m_fLaserWidthScale, 1.f );

			if( m_bPenetrate == false )
			{
				switch( m_pEveElectraSystem->m_ePlaneFormationType )
				{
				case PFT_AMPLIFIER:	// 증폭장 : 물리/ 마법 데미지 1.2배
					{
						CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( m_pEveElectraSystem->m_pGUEve, m_AmplifyDamageEffectName.c_str(), m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vPlaneIntersectPoint, m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), m_pEveElectraSystem->m_pGUEve->GetRotateDegree(),
							0, false, -1.f, 1.f, 1.f, -1, -1.f, 0, -1.f, true );

                        if ( pEffect != NULL )
                        {
						    m_pEveElectraSystem->LaserAttackLineSet( pEffect );

                            if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                            {
						        pMeshInstance->SetNowLifeTime( pMainEffect0->GetNowLifeTime() );
						        pMeshInstance->SetMaxLifeTime( pMainEffect0->GetMaxLifeTime() );
                            }
    #ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
						    pEffect->SetLaserGroupID( pDamageEffect0->GetLaserGroupID() );
    #else //UPGRADE_SKILL_SYSTEM_2013
						    pEffect->SetLaserGroupID( 1 );
    #endif //UPGRADE_SKILL_SYSTEM_2013
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
                            m_vecDamageEffect.push_back( pEffect->GetHandle() );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
						    m_vecDamageEffect.push_back( pEffect );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

						    CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
						    *pDamageData = pDamageEffect0->GetDamageData();
    #ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			                pDamageData->hAttackerEffect = pEffect->GetHandle();
    #else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
						    pDamageData->pAttackerEffect = pEffect;
    #endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    #ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
						    pDamageData->m_iLaserGroupID = pDamageEffect0->GetLaserGroupID();
    #else //UPGRADE_SKILL_SYSTEM_2013
						    pDamageData->m_iLaserGroupID = 1;
    #endif //UPGRADE_SKILL_SYSTEM_2013

						    pDamageData->damage.fPhysic *= 1.2f;
						    pDamageData->damage.fMagic *= 1.2f;
                        }

					}
					break;
				case PFT_SPECTRUM:	/// 분광장 : 물리/ 마법 데미지, 획득 마나, 속성/ 소켓 발동 확률 0.45배, 세 갈래 이펙트 생성
					{
						for(UINT i = 1; i <= 3; i++ )
						{
							CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( m_pEveElectraSystem->m_pGUEve, m_SpectrumDamageEffectName.c_str(), m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vPlaneIntersectPoint, m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), m_pEveElectraSystem->m_pGUEve->GetRotateDegree(),
								0, false, -1.f, 1.f, 1.f, -1, -1.f, 0, -1.f, true );

                            if ( pEffect != NULL )
                            {
							    m_pEveElectraSystem->LaserAttackLineSet( pEffect );

                                if (  CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                                {
							        pMeshInstance->SetNowLifeTime( pMainEffect0->GetNowLifeTime() );
							        pMeshInstance->SetMaxLifeTime( pMainEffect0->GetMaxLifeTime() );
                                }
    #ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
							    pEffect->SetLaserGroupID( i + ( pDamageEffect0->GetLaserGroupID() - 1 ) * 3 );
    #else //UPGRADE_SKILL_SYSTEM_2013
							    pEffect->SetLaserGroupID( i );
    #endif //UPGRADE_SKILL_SYSTEM_2013
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
                                m_vecDamageEffect.push_back( pEffect->GetHandle() );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
							    m_vecDamageEffect.push_back( pEffect );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

							    CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
							    *pDamageData = pDamageEffect0->GetDamageData();
    #ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			                    pDamageData->hAttackerEffect = pEffect->GetHandle();
    #else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
						        pDamageData->pAttackerEffect = pEffect;
    #endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    #ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
							    pDamageData->m_iLaserGroupID = i + ( pDamageEffect0->GetLaserGroupID() - 1 ) * 3;
    #else //UPGRADE_SKILL_SYSTEM_2013
							    pDamageData->m_iLaserGroupID = i;
    #endif //UPGRADE_SKILL_SYSTEM_2013

							    pDamageData->damage.fPhysic *= 0.45f;
							    pDamageData->damage.fMagic *= 0.45f;

							    pDamageData->fHitAddMP *= 0.45f;

							    pDamageData->m_fRateModifier *= 0.45f;

    #ifdef SERV_EVE_BATTLE_SERAPH
							    pDamageData->fForceDownValue	*= 0.333f;
    #endif
                            }
						}
					}
					break;
#ifdef SERV_EVE_BATTLE_SERAPH
				case PFT_INDUCTION:	// 반응장 : 데미지 / 획득 마나 / 속성 / 소켓 발동 확률 0.55, Size 0.8, 유도탄, 데미지 타임 +1
					{
						++m_iFireCount;
					} break;
				case PFT_FUSION:	// 융합장 : 데미지 / 획득 마나 / 속성 / 소켓 발동 확률 0.25, Size 0.75, 유도탄, 세발, 데미지 타임 +1
					{
						++m_iFireCount;
					} break;
#endif
				}

				m_hParticleLaserCross = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pEveElectraSystem->m_pGUEve,  L"eve_spectro_bump_P01", vPlaneIntersectPoint );
				CKTDGParticleSystem::CParticleEventSequence* pSeqLaserCross = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleLaserCross );
				if( pSeqLaserCross != NULL )
				{
					pSeqLaserCross->SetScaleFactor( D3DXVECTOR3( m_fLaserWidthScale * 0.7f, m_fLaserWidthScale * 0.7f, m_fLaserWidthScale * 0.7f ) );
				}	

				m_bPenetrate = true;
			}



			switch( m_pEveElectraSystem->m_ePlaneFormationType )
			{
			case PFT_AMPLIFIER:
				{
                    CX2DamageEffect::CEffect* pDamageEffect1 = ( m_vecDamageEffect.size() > 1 ) 
                        ? g_pX2Game->GetDamageEffect()->GetInstance( m_vecDamageEffect[1] ) : NULL;
					if( CKTDGXMeshPlayer::CXMeshInstance *pMainEffect1 = ( pDamageEffect1 != NULL ) ? pDamageEffect1->GetMainEffect() : NULL )
					{
						pDamageEffect1->SetPos( vPlaneIntersectPoint );

						D3DXVECTOR3 vSecondRotateDegree = vRotateDegree;

#ifdef SERV_EVE_BATTLE_SERAPH
						vSecondRotateDegree.z += m_pEveElectraSystem->m_fEveZAngle + m_pEveElectraSystem->m_fPlaneZAngle + vSecondRotateDegree.z * 0.8f;
#else
						vSecondRotateDegree.z += m_pEveElectraSystem->m_fPlaneZAngle + vSecondRotateDegree.z * 0.8f;
#endif

						pMainEffect1->SetRotateLocalDegree( vSecondRotateDegree );

						float fSecondLaserLength = D3DXVec3Length( &( vLaserNowPos - vPlaneIntersectPoint ) );
						fSecondLaserLength *= MAGIC_LASER_LENGTH;
#ifdef SERV_EVE_BATTLE_SERAPH
						pMainEffect1->SetScale( fSecondLaserLength, 
							m_fLaserWidthScale * ( 1.5f + m_pEveElectraSystem->m_fHyperOpticalResearchScale ), 1.f );
#else
						pMainEffect1->SetScale( fSecondLaserLength, m_fLaserWidthScale * 1.5f, 1.f );
#endif
						pMainEffect1->SetMeshAlphaColor( pMainEffect0->GetMeshAlphaColor() );

					}
				}
				break;
			case PFT_SPECTRUM:
				{
					for(UINT i = 1; i <=3; i++ )
					{
                        CX2DamageEffect::CEffect* pDamageEffecti = ( m_vecDamageEffect.size() > i ) 
                            ? g_pX2Game->GetDamageEffect()->GetInstance( m_vecDamageEffect[i] ) : NULL;
						if( CKTDGXMeshPlayer::CXMeshInstance *pMainEffecti = ( pDamageEffecti != NULL ) ? pDamageEffecti->GetMainEffect() : NULL )
						{
							pDamageEffecti->SetPos( vPlaneIntersectPoint );

							D3DXVECTOR3 vSecondRotateDegree = vRotateDegree; 

#ifdef SERV_EVE_BATTLE_SERAPH
							vSecondRotateDegree.z += m_pEveElectraSystem->m_fEveZAngle + m_pEveElectraSystem->m_fPlaneZAngle + vSecondRotateDegree.z * 0.8f;
#else
							vSecondRotateDegree.z += m_pEveElectraSystem->m_fPlaneZAngle + vSecondRotateDegree.z * 0.8f;
#endif

							float vSpectrumZRotate = vRotateDegree.z - vSecondRotateDegree.z; 
							if( vSpectrumZRotate < 0.f )
								vSpectrumZRotate = -vSpectrumZRotate;

							if( m_pEveElectraSystem->m_fPlaneZAngle == 0.f )
							{
								if( i == 2)
									vSecondRotateDegree.z += (14.f + vSpectrumZRotate * 0.65f );
								else if( i == 3 )
									vSecondRotateDegree.z -= (14.f + vSpectrumZRotate * 0.65f );
							}
							else
							{
								if( i == 2)
									vSecondRotateDegree.z += vSpectrumZRotate * 0.6f;
								else if( i == 3 )
									vSecondRotateDegree.z -= vSpectrumZRotate * 0.6f;
							}

							pMainEffecti->SetRotateLocalDegree( vSecondRotateDegree );

							float fSecondLaserLength = D3DXVec3Length( &( vLaserNowPos - vPlaneIntersectPoint ) );
							fSecondLaserLength *= MAGIC_LASER_LENGTH;
							pMainEffecti->SetScale( fSecondLaserLength, m_fLaserWidthScale * 0.7f, 1.f );

							pMainEffecti->SetMeshAlphaColor( pMainEffect0->GetMeshAlphaColor() );
						}
					}
				} break;

#ifdef SERV_EVE_BATTLE_SERAPH
			case PFT_INDUCTION:	// 반응장 bPenetrate 후 처리될 부분
				{
					pDamageEffect0->GetDamageData().bReAttack = false;

					if ( m_fElapsedTime < pMainEffect0->GetMaxLifeTime() &&
						m_fElapsedTime <= pDamageEffect0->GetAttackTime().y &&
						m_fElapsedTime > m_iFireCount * pDamageEffect0->GetDamageData().fHitGap )
					{
						++m_iFireCount;

						D3DXVECTOR2 vLockOnRange( 0.f, 0.f );

						CX2DamageEffect::CEffect* pEffect = NULL;

						if ( CX2DamageManager::AT_SPECIAL == pDamageEffect0->GetDamageData().attackType )
						{
							pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( 
								m_pEveElectraSystem->m_pGUEve, L"EVE_EBS_INDUCTION_LASER_SPECIAL",
								m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vPlaneIntersectPoint, 
								m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), m_pEveElectraSystem->m_pGUEve->GetRotateDegree() );
							ASSERT( pEffect != NULL );
                            if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                            {
						        pMeshInstance->SetNowLifeTime( 0.f );
						        pMeshInstance->SetMaxLifeTime( 2.5f );
                            }

							vLockOnRange = D3DXVECTOR2( 0, 1500 );
						}
						else
						{
							pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( 
								m_pEveElectraSystem->m_pGUEve, L"EVE_EBS_INDUCTION_LASER",
								m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vPlaneIntersectPoint, 
								m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), m_pEveElectraSystem->m_pGUEve->GetRotateDegree() );
							ASSERT( pEffect != NULL );
                            if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                            {
						        pMeshInstance->SetNowLifeTime( 0.f );
						        pMeshInstance->SetMaxLifeTime( 1.0f );
                            }

							vLockOnRange = D3DXVECTOR2( 0, 500 );
						}

						pEffect->SetAttackTime( D3DXVECTOR2( 0.f, 100.f) );
						CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();

						D3DXVECTOR2 vBackSpeed = pDamageData->backSpeed;
						*pDamageData = pDamageEffect0->GetDamageData();
#ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			            pDamageData->hAttackerEffect = pEffect->GetHandle();
#else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
						pDamageData->pAttackerEffect = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
						pDamageData->damage.fPhysic		*= 0.55f;
						pDamageData->damage.fMagic		*= 0.55f;
						pDamageData->fHitGap			= 0.5f;
						pDamageData->bReAttack			= true;
						pDamageData->fHitAddMP			*= 0.55f;
						pDamageData->m_fRateModifier	*= 0.55f;
						pDamageData->bArrangedFly		= false;
						pDamageData->backSpeed			= vBackSpeed;
						pDamageData->fForceDownValue	*= 0.5f;
						pDamageData->techPoint			= int(pDamageData->techPoint * 0.55);
						pDamageData->m_iLaserGroupID	= -1;

						bool bUserUnit = false;
						UidType gameUnitUID = -1;

						if ( CX2DamageManager::AT_SPECIAL == pDamageEffect0->GetDamageData().attackType )
						{
							pDamageData->m_fPvpRate *= 0.75f;
						}

						if ( g_pMain->GetNowStateID() == CX2Main::XS_PVP_GAME )
						{
							gameUnitUID = g_pX2Game->GetLockOnNearstTargetInRange( static_cast<CX2Room::TEAM_NUM>( 
								m_pEveElectraSystem->m_pGUEve->GetTeam() ), pEffect->GetPos(), vLockOnRange, bUserUnit );
						}
						else
						{
							vLockOnRange.y += 300.f;
							gameUnitUID = g_pX2Game->GetLockOnNearstTargetInRange( static_cast<CX2Room::TEAM_NUM>( 
								m_pEveElectraSystem->m_pGUEve->GetTeam() ), pEffect->GetPos(), vLockOnRange, bUserUnit );
						}

						if( bUserUnit == true )
							pEffect->SetLockOnUnitUID( gameUnitUID );
						else
							pEffect->SetLockOnNPCUID( static_cast<int>( gameUnitUID ) );

						if( m_pEveElectraSystem->GetEnableGigaPlane() == true )
                        {
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
                            m_vecDamageEffect.push_back( pEffect->GetHandle() );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
							m_vecDamageEffect.push_back( pEffect );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
                        }
					}
				} break;

			case PFT_FUSION:
				{
					pDamageEffect0->GetDamageData().bReAttack = false;

					if ( m_fElapsedTime < pMainEffect0->GetMaxLifeTime() &&
						m_fElapsedTime <= pDamageEffect0->GetAttackTime().y &&
						m_fElapsedTime > m_iFireCount * pDamageEffect0->GetDamageData().fHitGap )
					{
						++m_iFireCount;

						D3DXVECTOR2 vLockOnRange( 0.f, 0.f );

						for( UINT i = 1; i <= 3; ++i )
						{
							CX2DamageEffect::CEffect* pEffect = NULL;

							if ( CX2DamageManager::AT_SPECIAL == pDamageEffect0->GetDamageData().attackType )
							{
								pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( 
									m_pEveElectraSystem->m_pGUEve, L"EVE_EBS_INDUCTION_LASER_SPECIAL",
									m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vPlaneIntersectPoint, 
									m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), m_pEveElectraSystem->m_pGUEve->GetRotateDegree() );
								ASSERT( pEffect != NULL );									
                                if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                                {
								    pMeshInstance->SetNowLifeTime( 0.f );
								    pMeshInstance->SetMaxLifeTime( 2.5f );
                                }
								vLockOnRange = D3DXVECTOR2( 0, 1500 );
							}
							else
							{
								pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( 
									m_pEveElectraSystem->m_pGUEve, L"EVE_EBS_INDUCTION_LASER",
									m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vPlaneIntersectPoint, 
									m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), m_pEveElectraSystem->m_pGUEve->GetRotateDegree() );
								ASSERT( pEffect != NULL );									
                                if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                                {
								    pMeshInstance->SetNowLifeTime( 0.f );
								    pMeshInstance->SetMaxLifeTime( 1.0f );
                                }
								vLockOnRange = D3DXVECTOR2( 0, 500 );
							}

							pEffect->SetAttackTime( D3DXVECTOR2( 0.f, 100.f) );
							CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
							D3DXVECTOR2 vBackSpeed = pDamageData->backSpeed;
							*pDamageData = pDamageEffect0->GetDamageData();
#ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			                pDamageData->hAttackerEffect = pEffect->GetHandle();
#else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
						    pDamageData->pAttackerEffect = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
							pDamageData->fHitGap			= 0.5f;
							pDamageData->bReAttack			= true;
							pDamageData->damage.fPhysic		*= 0.25f;
							pDamageData->damage.fMagic		*= 0.25f;
							pDamageData->fHitAddMP			*= 0.25f;
							pDamageData->m_fRateModifier	*= 0.25f;
							pDamageData->bArrangedFly		= false;
							pDamageData->backSpeed			= vBackSpeed;
							pDamageData->fForceDownValue	*= 0.166f;
							pDamageData->techPoint			= int(pDamageData->techPoint * 0.25);
							pDamageData->m_iLaserGroupID	= -1;

							bool bUserUnit = false;
							UidType gameUnitUID = -1;

							if ( CX2DamageManager::AT_SPECIAL == pDamageEffect0->GetDamageData().attackType )
							{
								pDamageData->m_fPvpRate *= 0.75f;
							}

							if ( g_pMain->GetNowStateID() == CX2Main::XS_PVP_GAME )
							{
								gameUnitUID = g_pX2Game->GetLockOnNearstTargetInRange( static_cast<CX2Room::TEAM_NUM>( 
									m_pEveElectraSystem->m_pGUEve->GetTeam() ), pEffect->GetPos(), vLockOnRange, bUserUnit );
							}
							else
							{
								vLockOnRange.y += 300.f;
								gameUnitUID = g_pX2Game->GetLockOnNearstTargetInRange( static_cast<CX2Room::TEAM_NUM>( 
									m_pEveElectraSystem->m_pGUEve->GetTeam() ), pEffect->GetPos(), vLockOnRange, bUserUnit );
							}

							if( bUserUnit == true )
								pEffect->SetLockOnUnitUID( gameUnitUID );
							else
								pEffect->SetLockOnNPCUID( static_cast<int>( gameUnitUID ) );

							if( m_pEveElectraSystem->GetEnableGigaPlane() == true )
                            {
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
                                m_vecDamageEffect.push_back( pEffect->GetHandle() );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
								m_vecDamageEffect.push_back( pEffect );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
                            }
						}
					}
				} break;
#endif
			}
			CKTDGParticleSystem::CParticleEventSequence* pSeqLaserCross = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleLaserCross );
			if( pSeqLaserCross != NULL )
			{
				pSeqLaserCross->SetPosition( vPlaneIntersectPoint );
			}
			//////////// GIGA STREAM ////////////////////////////////////////////////////////{{
			if( m_pEveElectraSystem->GetEnableGigaPlane() == true )
			{
				switch ( m_pEveElectraSystem->m_ePlaneFormationType )
				{
				case PFT_AMPLIFIER:
					{
                        CX2DamageEffect::CEffect* pDamageEffect1 = ( m_vecDamageEffect.size() > 1 ) 
                            ? g_pX2Game->GetDamageEffect()->GetInstance( m_vecDamageEffect[1] ) : NULL;
					    if( CKTDGXMeshPlayer::CXMeshInstance *pMainEffect1 = ( pDamageEffect1 != NULL ) ? pDamageEffect1->GetMainEffect() : NULL )
						{
							D3DXVECTOR3 vRotateDegree = pMainEffect1->GetRotateLocalDegree();

							D3DXVECTOR3 vRotationAxis;
							D3DXVec3Cross( &vRotationAxis, &m_vDirVector, &Y_AXIS );
							D3DXVec3Normalize( &vRotationAxis, &vRotationAxis );


							D3DXMATRIX matRotation;
							D3DXMatrixRotationAxis( &matRotation, &vRotationAxis, D3DX_PI / 180.f * vRotateDegree.z );

							D3DXVECTOR4 v4DirVectorLaser;
							D3DXVec3Transform( &v4DirVectorLaser, &m_vDirVector, &matRotation );

							D3DXVECTOR3 vDirVectorLaser = v4DirVectorLaser;

							D3DXVECTOR3 vLaserStartPos = vPlaneIntersectPoint;

							D3DXVECTOR3 vLaserNowPos = vLaserStartPos + ( m_fVelocity * m_fElapsedTime * vDirVectorLaser );
							D3DXVECTOR3 vLaserEndPos = vLaserStartPos + ( m_fVelocity * m_fLaserPropagateTime * m_pEveElectraSystem->m_fLaserRangeScale * vDirVectorLaser );

							if( m_fElapsedTime > m_fLaserPropagateTime * m_pEveElectraSystem->m_fLaserRangeScale)
							{
								vLaserNowPos = vLaserEndPos;
							}

							D3DXVECTOR3 vGigaPlaneIntersectPoint;
							D3DXPlaneIntersectLine( &vGigaPlaneIntersectPoint, &m_pEveElectraSystem->m_GigaStreamPlane, &vLaserEndPos, &vLaserStartPos );

							if( D3DXPlaneDotCoord( &m_pEveElectraSystem->m_GigaStreamPlane, &D3DXVECTOR3( vLaserNowPos ) ) < 0.0f )
							{
								const float MAGIC_LASER_LENGTH = 0.01f;
								float fLaserLength = D3DXVec3Length( &( vLaserNowPos - vLaserStartPos ) );
								fLaserLength *= MAGIC_LASER_LENGTH;

								pMainEffect1->SetScale( fLaserLength, m_fLaserWidthScale * 1.5f, 1.f );
							}
							else
							{

								const float MAGIC_LASER_LENGTH = 0.01f;
								float fLaserLength = D3DXVec3Length( &( vGigaPlaneIntersectPoint - vLaserStartPos ) );
								fLaserLength *= MAGIC_LASER_LENGTH;

								pMainEffect1->SetScale( fLaserLength, m_fLaserWidthScale * 1.5f, 1.f );

								if( m_bPenetrateGiga[0] == false )
								{
									CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( m_pEveElectraSystem->m_pGUEve, m_AmplifyDamageEffectName.c_str(), m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vGigaPlaneIntersectPoint, m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), m_pEveElectraSystem->m_pGUEve->GetRotateDegree(),
										0, false, -1.f, 1.f, 1.f, -1, -1.f, 0, -1.f, true );
									ASSERT( pEffect != NULL );
									m_pEveElectraSystem->LaserAttackLineSet( pEffect );
                                    if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                                    {
									    pMeshInstance->SetNowLifeTime( pMainEffect1->GetNowLifeTime() );
									    pMeshInstance->SetMaxLifeTime( pMainEffect1->GetMaxLifeTime() );
                                    }
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
									pEffect->SetLaserGroupID( pDamageEffect0->GetLaserGroupID() );
#else //UPGRADE_SKILL_SYSTEM_2013
									pEffect->SetLaserGroupID( 1 );
#endif //UPGRADE_SKILL_SYSTEM_2013
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
                                    m_vecDamageEffect.push_back( pEffect->GetHandle() );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
									m_vecDamageEffect.push_back( pEffect );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

									CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
									*pDamageData = pDamageEffect1->GetDamageData();
#ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			                        pDamageData->hAttackerEffect = pEffect->GetHandle();
#else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
						            pDamageData->pAttackerEffect = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
									pDamageData->m_iLaserGroupID = pDamageEffect0->GetLaserGroupID();
#else //UPGRADE_SKILL_SYSTEM_2013
									pDamageData->m_iLaserGroupID = 1;
#endif //UPGRADE_SKILL_SYSTEM_2013

									pDamageData->damage.fPhysic *= 2.0f;
									pDamageData->damage.fMagic *= 2.0f;

									m_hParticleGigaLaserCross[0] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pEveElectraSystem->m_pGUEve,  L"eve_spectro_giga_bump_P01", vGigaPlaneIntersectPoint );
									CKTDGParticleSystem::CParticleEventSequence* pSeqLaserCross = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleGigaLaserCross[0] );
									if( pSeqLaserCross != NULL )
									{
#ifdef SERV_EVE_BATTLE_SERAPH
										float fhyperORScale = m_pEveElectraSystem->m_fHyperOpticalResearchScale;
										pSeqLaserCross->SetScaleFactor( D3DXVECTOR3( ( m_fLaserWidthScale + fhyperORScale ) * 1.0f,
											( m_fLaserWidthScale + fhyperORScale ) * 1.0f,
											( m_fLaserWidthScale + fhyperORScale ) * 1.0f ) );
#else
										pSeqLaserCross->SetScaleFactor( D3DXVECTOR3( m_fLaserWidthScale * 1.0f, m_fLaserWidthScale * 1.0f, m_fLaserWidthScale * 1.0f ) );
#endif
										D3DXVECTOR3 vRotateDegree = m_pEveElectraSystem->m_pGUEve->GetRotateDegree();
										vRotateDegree.z = m_pEveElectraSystem->m_fPlaneZAngle;
										pSeqLaserCross->SetAxisAngle( vRotateDegree );
										pSeqLaserCross->SetAddRotate( vRotateDegree );	

									}

									m_bPenetrateGiga[0] = true;
								}

                                CX2DamageEffect::CEffect* pDamageEffect2 = ( m_vecDamageEffect.size() > 2 ) 
                                    ? g_pX2Game->GetDamageEffect()->GetInstance( m_vecDamageEffect[2] ) : NULL;
        					    if( CKTDGXMeshPlayer::CXMeshInstance *pMainEffect2 = ( pDamageEffect2 != NULL ) ? pDamageEffect2->GetMainEffect() : NULL )
								{

									pDamageEffect2->SetPos( vGigaPlaneIntersectPoint );

									D3DXVECTOR3 vSecondRotateDegree = vRotateDegree; 

									//vSecondRotateDegree.z += m_pEveElectraSystem->m_fPlaneZAngle + vSecondRotateDegree.z * 0.8f;

									pMainEffect2->SetRotateLocalDegree( vSecondRotateDegree );

									float fSecondLaserLength = D3DXVec3Length( &( vLaserNowPos - vGigaPlaneIntersectPoint ) );
									fSecondLaserLength *= MAGIC_LASER_LENGTH;
#ifdef SERV_EVE_BATTLE_SERAPH
									pMainEffect2->SetScale( fSecondLaserLength, 
										( m_fLaserWidthScale + m_pEveElectraSystem->m_fHyperOpticalResearchScale ) * 7.5f, 1.f );
#else
									pMainEffect2->SetScale( fSecondLaserLength, m_fLaserWidthScale * 7.5f, 1.f );
#endif

									pMainEffect2->SetMeshAlphaColor( pMainEffect1->GetMeshAlphaColor() );

								}
							}
							CKTDGParticleSystem::CParticleEventSequence* pSeqLaserCross = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleGigaLaserCross[0] );
							if( pSeqLaserCross != NULL )
							{
								pSeqLaserCross->SetPosition( vGigaPlaneIntersectPoint );
							}
						}
					} break;
				case PFT_SPECTRUM:
					{
						for(UINT i=1; i<4; ++i )
						{
                            CX2DamageEffect::CEffect* pDamageEffecti = ( m_vecDamageEffect.size() > i ) 
                                ? g_pX2Game->GetDamageEffect()->GetInstance( m_vecDamageEffect[i] ) : NULL;
						    if( CKTDGXMeshPlayer::CXMeshInstance *pMainEffecti = ( pDamageEffecti != NULL ) ? pDamageEffecti->GetMainEffect() : NULL )
							{

								D3DXVECTOR3 vRotateDegree = pMainEffecti->GetRotateLocalDegree();

								D3DXVECTOR3 vRotationAxis;
								D3DXVec3Cross( &vRotationAxis, &m_vDirVector, &Y_AXIS );
								D3DXVec3Normalize( &vRotationAxis, &vRotationAxis );


								D3DXMATRIX matRotation;
								D3DXMatrixRotationAxis( &matRotation, &vRotationAxis, D3DX_PI / 180.f * vRotateDegree.z );

								D3DXVECTOR4 v4DirVectorLaser;
								D3DXVec3Transform( &v4DirVectorLaser, &m_vDirVector, &matRotation );

								D3DXVECTOR3 vDirVectorLaser = v4DirVectorLaser;

								D3DXVECTOR3 vLaserStartPos = vPlaneIntersectPoint;

								D3DXVECTOR3 vLaserNowPos = vLaserStartPos + ( m_fVelocity * m_fElapsedTime * vDirVectorLaser );
								D3DXVECTOR3 vLaserEndPos = vLaserStartPos + ( m_fVelocity * m_fLaserPropagateTime * m_pEveElectraSystem->m_fLaserRangeScale * vDirVectorLaser );

								if( m_fElapsedTime > m_fLaserPropagateTime * m_pEveElectraSystem->m_fLaserRangeScale)
								{
									vLaserNowPos = vLaserEndPos;
								}

								D3DXVECTOR3 vGigaPlaneIntersectPoint;
								D3DXPlaneIntersectLine( &vGigaPlaneIntersectPoint, &m_pEveElectraSystem->m_GigaStreamPlane, &vLaserEndPos, &vLaserStartPos );

								if( D3DXPlaneDotCoord( &m_pEveElectraSystem->m_GigaStreamPlane, &D3DXVECTOR3( vLaserNowPos ) ) < 0.0f )
								{
									const float MAGIC_LASER_LENGTH = 0.01f;
									float fLaserLength = D3DXVec3Length( &( vLaserNowPos - vLaserStartPos ) );
									fLaserLength *= MAGIC_LASER_LENGTH;

									pMainEffecti->SetScale( fLaserLength, m_fLaserWidthScale * 0.7f, 1.f );
								}
								else
								{

									const float MAGIC_LASER_LENGTH = 0.01f;
									float fLaserLength = D3DXVec3Length( &( vGigaPlaneIntersectPoint - vLaserStartPos ) );
									fLaserLength *= MAGIC_LASER_LENGTH;

									pMainEffecti->SetScale( fLaserLength, m_fLaserWidthScale * 0.7f, 1.f );

									if( m_bPenetrateGiga[i] == false )
									{
										CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( m_pEveElectraSystem->m_pGUEve, m_AmplifyDamageEffectName.c_str(), m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vGigaPlaneIntersectPoint, m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), m_pEveElectraSystem->m_pGUEve->GetRotateDegree(),
											0, false, -1.f, 1.f, 1.f, -1, -1.f, 0, -1.f, true );
										ASSERT( pEffect != NULL );
										m_pEveElectraSystem->LaserAttackLineSet( pEffect );
                                        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                                        {
										    pMeshInstance->SetNowLifeTime( pMainEffecti->GetNowLifeTime() );
										    pMeshInstance->SetMaxLifeTime( pMainEffecti->GetMaxLifeTime() );
                                        }
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
										pEffect->SetLaserGroupID( pDamageEffecti->GetLaserGroupID() );
#else //UPGRADE_SKILL_SYSTEM_2013
										pEffect->SetLaserGroupID( i );
#endif //UPGRADE_SKILL_SYSTEM_2013
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
                                        m_vecDamageEffect.push_back( pEffect->GetHandle() );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
										m_vecDamageEffect.push_back( pEffect );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

										CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
										*pDamageData = pDamageEffecti->GetDamageData();
#ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			                            pDamageData->hAttackerEffect = pEffect->GetHandle();
#else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
						                pDamageData->pAttackerEffect = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
										pDamageData->m_iLaserGroupID = pDamageEffecti->GetLaserGroupID();
#else //UPGRADE_SKILL_SYSTEM_2013
										pDamageData->m_iLaserGroupID = i;
#endif //UPGRADE_SKILL_SYSTEM_2013
										
										pDamageData->damage.fPhysic *= 2.0f;
										pDamageData->damage.fMagic *= 2.0f;

										m_hParticleGigaLaserCross[i] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pEveElectraSystem->m_pGUEve,  L"eve_spectro_giga_bump_P01", vGigaPlaneIntersectPoint );
										CKTDGParticleSystem::CParticleEventSequence* pSeqLaserCross = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleGigaLaserCross[i] );
										if( pSeqLaserCross != NULL )
										{
											pSeqLaserCross->SetScaleFactor( D3DXVECTOR3( m_fLaserWidthScale * 0.4f, m_fLaserWidthScale * 0.4f, m_fLaserWidthScale * 0.4f ) );
											D3DXVECTOR3 vRotateDegree = m_pEveElectraSystem->m_pGUEve->GetRotateDegree();
											vRotateDegree.z = m_pEveElectraSystem->m_fPlaneZAngle;
											pSeqLaserCross->SetAxisAngle( vRotateDegree );
											pSeqLaserCross->SetAddRotate( vRotateDegree );
										}

										m_bPenetrateGiga[i] = true;
									}

                                    CX2DamageEffect::CEffect* pDamageEffecti3 = ( m_vecDamageEffect.size() > i+3 ) 
                                        ? g_pX2Game->GetDamageEffect()->GetInstance( m_vecDamageEffect[i+3] ) : NULL;
						            if( CKTDGXMeshPlayer::CXMeshInstance *pMainEffecti3 = ( pDamageEffecti3 != NULL ) ? pDamageEffecti3->GetMainEffect() : NULL )
									{

										pDamageEffecti3->SetPos( vGigaPlaneIntersectPoint );

										D3DXVECTOR3 vSecondRotateDegree = vRotateDegree; 

										//vSecondRotateDegree.z += m_pEveElectraSystem->m_fPlaneZAngle + vSecondRotateDegree.z * 0.8f;

										pMainEffecti3->SetRotateLocalDegree( vSecondRotateDegree );

										float fSecondLaserLength = D3DXVec3Length( &( vLaserNowPos - vGigaPlaneIntersectPoint ) );
										fSecondLaserLength *= MAGIC_LASER_LENGTH;
										pMainEffecti3->SetScale( fSecondLaserLength, m_fLaserWidthScale * 3.5f, 1.f );

										pMainEffecti3->SetMeshAlphaColor( pMainEffecti->GetMeshAlphaColor() );

									}
								}
								CKTDGParticleSystem::CParticleEventSequence* pSeqLaserCross = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleGigaLaserCross[i] );
								if( pSeqLaserCross != NULL )
								{
									pSeqLaserCross->SetPosition( vGigaPlaneIntersectPoint );
								}
							}
						}
					} break;
#ifdef SERV_EVE_BATTLE_SERAPH
				case PFT_INDUCTION:
					{
						for( UINT i = 1; i < m_vecDamageEffect.size(); ++i )
						{
                            CX2DamageEffect::CEffect* pDamageEffecti = ( m_vecDamageEffect.size() > i ) 
                                ? g_pX2Game->GetDamageEffect()->GetInstance( m_vecDamageEffect[i] ) : NULL;
						    if( CKTDGXMeshPlayer::CXMeshInstance *pMainEffecti = ( pDamageEffecti != NULL ) ? pDamageEffecti->GetMainEffect() : NULL )
							{
								D3DXVECTOR3 vEffectNowPos = pMainEffecti->GetPos();	// 이펙트의 현재 위치
								D3DXVECTOR2 vLockOnRange( 0.f, 0.f );

								if( false == pDamageEffecti->GetCheckSpectro() &&
									0.f < D3DXPlaneDotCoord( &m_pEveElectraSystem->m_GigaStreamPlane, &D3DXVECTOR3( vEffectNowPos ) ) )
								{
									D3DXVECTOR3 vEffectEndPos;
									D3DXPlaneIntersectLine( &vEffectEndPos, &m_pEveElectraSystem->m_GigaStreamPlane, &vEffectNowPos,
										&vPlaneIntersectPoint );

									CX2DamageEffect::CEffect* pEffect = NULL;
                                    CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = NULL;
									if ( CX2DamageManager::AT_SPECIAL == pDamageEffecti->GetDamageData().attackType )
									{
										pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( 
											m_pEveElectraSystem->m_pGUEve, L"EVE_EBS_INDUCTION_LASER_SPECIAL",
											m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vEffectEndPos, 
											m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), m_pEveElectraSystem->m_pGUEve->GetRotateDegree() );
										ASSERT( pEffect != NULL );
                                        if ( pMeshInstance = pEffect->GetMainEffect() )
                                        {
										    pMeshInstance->SetNowLifeTime( 0.f );
										    pMeshInstance->SetMaxLifeTime( 2.5f );
                                        }
										vLockOnRange = D3DXVECTOR2( 1, 1500 );
									}
									else
									{
										pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( 
											m_pEveElectraSystem->m_pGUEve, L"EVE_EBS_INDUCTION_LASER",
											m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vEffectEndPos, 
											m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), m_pEveElectraSystem->m_pGUEve->GetRotateDegree() );
										ASSERT( pEffect != NULL );											
                                        if ( pMeshInstance = pEffect->GetMainEffect() )
                                        {
										    pMeshInstance->SetNowLifeTime( 0.f );
										    pMeshInstance->SetMaxLifeTime( 1.0f );
                                        }
										vLockOnRange = D3DXVECTOR2( 1, 400 );
									}

									pEffect->SetAttackTime( D3DXVECTOR2( 0.f, 100.f) );
									CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
									*pDamageData = pDamageEffecti->GetDamageData();
#ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			                        pDamageData->hAttackerEffect = pEffect->GetHandle();
#else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
						            pDamageData->pAttackerEffect = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
									pDamageData->damage.fPhysic		*= 2.0f;
									pDamageData->damage.fMagic		*= 2.0f;
									pDamageData->fHitGap			= 0.5f;
									pDamageData->bReAttack			= true;
									pDamageData->bArrangedFly		= false;
									pDamageData->m_iLaserGroupID	= -1;

									bool bUserUnit = false;
									UidType gameUnitUID = -1;

									if ( g_pMain->GetNowStateID() == CX2Main::XS_PVP_GAME )
										gameUnitUID = g_pX2Game->GetLockOnNearstTargetInRange( static_cast<CX2Room::TEAM_NUM>( 
										m_pEveElectraSystem->m_pGUEve->GetTeam() ), pEffect->GetPos(), vLockOnRange, bUserUnit );
									else
										gameUnitUID = g_pX2Game->GetLockOnNearstTargetInRange( static_cast<CX2Room::TEAM_NUM>( 
										m_pEveElectraSystem->m_pGUEve->GetTeam() ), pEffect->GetPos(), vLockOnRange, bUserUnit );

									if( bUserUnit == true )
									{
										pEffect->SetLockOnUnitUID( gameUnitUID );
										pEffect->SetLockOnRandomSeed( (int)m_pEveElectraSystem->m_pGUEve->GetRandomInt() );
									}
									else
									{
										pEffect->SetLockOnNPCUID( static_cast<int>( gameUnitUID ) );
										pEffect->SetLockOnRandomSeed( (int)m_pEveElectraSystem->m_pGUEve->GetRandomInt() );
									}

									pEffect->SetCheckSpectro( true );
									g_pX2Game->GetDamageEffect()->DestroyInstanceSilently( pDamageEffecti );

									CKTDGParticleSystem::CParticleEventSequenceHandle hParticleCross = g_pX2Game->
										GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pEveElectraSystem->m_pGUEve,
										L"eve_spectro_giga_cross_P01", vEffectEndPos );
									CKTDGParticleSystem::CParticleEventSequence* pSeqLaserCross =
										g_pX2Game->GetMajorParticle()->GetInstanceSequence( hParticleCross );

									if( pSeqLaserCross != NULL )
									{
                                        if ( pMeshInstance != NULL )
										    pSeqLaserCross->SetScaleFactor( pMeshInstance->GetScale() * 0.3f );
										D3DXVECTOR3 vRotateDegree = m_pEveElectraSystem->m_pGUEve->GetRotateDegree();
										vRotateDegree.z = m_pEveElectraSystem->m_fPlaneZAngle;
										pSeqLaserCross->SetAxisAngle( vRotateDegree );
										pSeqLaserCross->SetAddRotate( vRotateDegree );
									}
								}
							}
						}
					} break;
				case PFT_FUSION: // 30개의 유도탄이 기가 스트림으로
					{
						for( UINT i = 1; i < m_vecDamageEffect.size(); ++i )
						{
                            CX2DamageEffect::CEffect* pDamageEffecti = ( m_vecDamageEffect.size() > i ) 
                                ? g_pX2Game->GetDamageEffect()->GetInstance( m_vecDamageEffect[i] ) : NULL;
						    if( CKTDGXMeshPlayer::CXMeshInstance *pMainEffecti = ( pDamageEffecti != NULL ) ? pDamageEffecti->GetMainEffect() : NULL )
							{
								D3DXVECTOR3 vEffectNowPos = pMainEffecti->GetPos();	// 이펙트의 현재 위치
								D3DXVECTOR2 vLockOnRange( 0.f, 0.f );

								if( false == pDamageEffecti->GetCheckSpectro() &&
									0.f < D3DXPlaneDotCoord( &m_pEveElectraSystem->m_GigaStreamPlane, &D3DXVECTOR3( vEffectNowPos ) ) )
								{
									D3DXVECTOR3 vEffectEndPos;
									D3DXPlaneIntersectLine( &vEffectEndPos, &m_pEveElectraSystem->m_GigaStreamPlane, &vEffectNowPos,
										&vPlaneIntersectPoint );

									CX2DamageEffect::CEffect* pEffect = NULL;
                                    CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = NULL;
									if ( CX2DamageManager::AT_SPECIAL == pDamageEffecti->GetDamageData().attackType )
									{
										pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( 
											m_pEveElectraSystem->m_pGUEve, L"EVE_EBS_INDUCTION_LASER_SPECIAL",
											m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vEffectEndPos, 
											m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), m_pEveElectraSystem->m_pGUEve->GetRotateDegree() );
                                        if ( pMeshInstance = pEffect->GetMainEffect() )
                                        {
										    pMeshInstance->SetNowLifeTime( 0.f );
										    pMeshInstance->SetMaxLifeTime( 2.5f );
                                        }
										vLockOnRange = D3DXVECTOR2( 1, 1500 );
									}
									else
									{
										pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( 
											m_pEveElectraSystem->m_pGUEve, L"EVE_EBS_INDUCTION_LASER",
											m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vEffectEndPos, 
											m_pEveElectraSystem->m_pGUEve->GetRotateDegree(), m_pEveElectraSystem->m_pGUEve->GetRotateDegree() );
                                        if ( pMeshInstance = pEffect->GetMainEffect() )
                                        {
										    pMeshInstance->SetNowLifeTime( 0.f );
										    pMeshInstance->SetMaxLifeTime( 1.0f );
                                        }
										vLockOnRange = D3DXVECTOR2( 1, 400 );
									}

									pEffect->SetAttackTime( D3DXVECTOR2( 0.f, 100.f) );
									CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
									*pDamageData = pDamageEffecti->GetDamageData();
#ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			                        pDamageData->hAttackerEffect = pEffect->GetHandle();
#else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
						            pDamageData->pAttackerEffect = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
									pDamageData->damage.fPhysic		*= 2.0f;
									pDamageData->damage.fMagic		*= 2.0f;
									pDamageData->fHitGap			= 0.5f;
									pDamageData->bReAttack			= true;
									pDamageData->bArrangedFly		= false;
									pDamageData->m_iLaserGroupID	= -1;

									bool bUserUnit = false;
									UidType gameUnitUID = -1;

									if ( g_pMain->GetNowStateID() == CX2Main::XS_PVP_GAME )
										gameUnitUID = g_pX2Game->GetLockOnNearstTargetInRange( static_cast<CX2Room::TEAM_NUM>( 
										m_pEveElectraSystem->m_pGUEve->GetTeam() ), pEffect->GetPos(), vLockOnRange, bUserUnit );
									else
										gameUnitUID = g_pX2Game->GetLockOnNearstTargetInRange( static_cast<CX2Room::TEAM_NUM>( 
										m_pEveElectraSystem->m_pGUEve->GetTeam() ), pEffect->GetPos(), vLockOnRange, bUserUnit );

									if( bUserUnit == true )
									{
										pEffect->SetLockOnUnitUID( gameUnitUID );
										pEffect->SetLockOnRandomSeed( (int)m_pEveElectraSystem->m_pGUEve->GetRandomInt() );
									}
									else
									{
										pEffect->SetLockOnNPCUID( static_cast<int>( gameUnitUID ) );
										pEffect->SetLockOnRandomSeed( (int)m_pEveElectraSystem->m_pGUEve->GetRandomInt() );
									}

									pEffect->SetCheckSpectro( true );
									g_pX2Game->GetDamageEffect()->DestroyInstanceSilently( pDamageEffecti );

									CKTDGParticleSystem::CParticleEventSequenceHandle hParticleCross = g_pX2Game->
										GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pEveElectraSystem->m_pGUEve,
										L"eve_spectro_giga_cross_P01", vEffectEndPos );
									CKTDGParticleSystem::CParticleEventSequence* pSeqLaserCross =
										g_pX2Game->GetMajorParticle()->GetInstanceSequence( hParticleCross );

									if( pSeqLaserCross != NULL )
									{
                                        if ( pMeshInstance != NULL )
										    pSeqLaserCross->SetScaleFactor( pMeshInstance->GetScale() * 0.3f );
										D3DXVECTOR3 vRotateDegree = m_pEveElectraSystem->m_pGUEve->GetRotateDegree();
										vRotateDegree.z = m_pEveElectraSystem->m_fPlaneZAngle;
										pSeqLaserCross->SetAxisAngle( vRotateDegree );
										pSeqLaserCross->SetAddRotate( vRotateDegree );
									}
								}
							}
						}
					} break;
#endif
				}
			}
			//////////// GIGA STREAM ////////////////////////////////////////////////////////}}
		}
		m_bDie			= false;
	}
	else
	{

		g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleLaserCross );
		g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaLaserCross[0] );
		g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaLaserCross[1] );
		g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaLaserCross[2] );
		g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaLaserCross[3] );

        if ( m_vecDamageEffect.empty() == false )
        {
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
            m_vecDamageEffect[0]	= INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
		    m_vecDamageEffect[0]	= NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        }
		m_bDie					= true;
	}


	return;
}

void CX2GUEve::EveElectraLaserData::Delete()
{
	if( m_vecDamageEffect.empty() == false )
	{
		for(UINT i = 0; i < m_vecDamageEffect.size(); i++ )
		{
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
            if ( m_vecDamageEffect[i] != INVALID_DAMAGE_EFFECT_HANDLE )
                g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_vecDamageEffect[i] );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			if( m_vecDamageEffect[i] != NULL )
            {
				g_pX2Game->GetDamageEffect()->DestroyInstance( m_vecDamageEffect[i] );
                m_vecDamageEffect[i] = NULL;
            }
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
		}
	}
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleLaserCross );
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaLaserCross[0] );
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaLaserCross[1] );
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaLaserCross[2] );
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaLaserCross[3] );

}
CX2GUEve::EveElectraEffectData::EveElectraEffectData( EveElectraSystem* _pEveElectraSystem )
{
	m_pEveElectraSystem	= _pEveElectraSystem;
	m_fElapsedTime		= 0.f;
	m_bPlaneFront		= false;
	m_bDie				= false;
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hDamageEffect = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_pDamageEffect		= NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
}

void CX2GUEve::EveElectraEffectData::OnFrameMove( float fElapsedTime )
{
	D3DXVECTOR3 vRotateDegree;
	m_fElapsedTime += fElapsedTime;

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    CX2DamageEffect::CEffect* m_pDamageEffect = g_pX2Game->GetDamageEffect()->GetInstance( m_hDamageEffect );
    if( CKTDGXMeshPlayer::CXMeshInstance* pMainEffect = ( m_pDamageEffect != NULL ) ? m_pDamageEffect->GetMainEffect() : NULL)
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    CKTDGXMeshPlayer::CXMeshInstance* pMainEffect = ( m_pDamageEffect != NULL ) ? m_pDamageEffect->GetMainEffect() : NULL;
	if( pMainEffect != NULL && g_pX2Game->GetDamageEffect()->IsLiveInstance( m_pDamageEffect ) == true )
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	{
		vRotateDegree = pMainEffect->GetRotateDegree();


		D3DXVECTOR3 vEffectNowPos = pMainEffect->GetPos();


		if( m_pEveElectraSystem->GetEnablePlane() == false )
		{
			m_bPlaneFront = false;
		}
		else if( D3DXPlaneDotCoord( &m_pEveElectraSystem->m_PrimaryPlane, &D3DXVECTOR3( vEffectNowPos ) ) < 0.0f )
		{
			m_vPlaneIntersectPoint = vEffectNowPos;
			m_bPlaneFront = true;
		}
		else if( m_bPlaneFront == true )
		{

			D3DXVECTOR3 vPlaneIntersectPoint;
			D3DXVECTOR3 vEffectEndPos;
			D3DXPlaneIntersectLine( &vEffectEndPos, &m_pEveElectraSystem->m_PrimaryPlane, &vEffectNowPos, &m_vPlaneIntersectPoint );

			switch( m_pEveElectraSystem->m_ePlaneFormationType )
			{
			case PFT_AMPLIFIER:
				{
#ifdef SERV_EVE_BATTLE_SERAPH
					CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance(
						m_pEveElectraSystem->m_pGUEve, m_AmplifyDamageEffectName.c_str(), m_pDamageEffect->GetPowerRate(),
						vEffectEndPos, vRotateDegree, vRotateDegree );
#else
					CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( m_pEveElectraSystem->m_pGUEve, m_AmplifyDamageEffectName.c_str(), m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vEffectEndPos, vRotateDegree, vRotateDegree );
#endif

					CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
					*pDamageData = m_pDamageEffect->GetDamageData();
#ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			        pDamageData->hAttackerEffect = pEffect->GetHandle();
#else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
					pDamageData->pAttackerEffect = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

#ifdef FIX_EVE_TASER_PILUM
	#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
					int iAddDamageTime = m_pEveElectraSystem->m_pGUEve->GetTaserPilumAddDamageTime();

					if ( iAddDamageTime > 0 )
					{
						m_pEveElectraSystem->m_pGUEve->ResetTaserPilumTinyData();
						pEffect->SetDamageTime( pEffect->GetDamageTime() + iAddDamageTime );
					}

					int iAddDamageTimeKugel = m_pEveElectraSystem->m_pGUEve->GetKugelBlitzAddDamageTime();

					if ( iAddDamageTimeKugel > 0 )
					{
						m_pEveElectraSystem->m_pGUEve->ResetKugelBlitzTinyData();
						pEffect->SetDamageTime( pEffect->GetDamageTime() + iAddDamageTimeKugel );
					}
	#else //UPGRADE_SKILL_SYSTEM_2013
					int iAddDamageTime = m_pEveElectraSystem->m_pGUEve->GetTaserPilumAddDamageTime();
					m_pEveElectraSystem->m_pGUEve->ResetTaserPilumTinyData();
					pEffect->SetDamageTime( pEffect->GetDamageTime() + iAddDamageTime );
	#endif //UPGRADE_SKILL_SYSTEM_2013
#endif // FIX_EVE_TASER_PILUM
                    CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect();
                    if ( pMeshInstance != NULL )
                    {
					    pMeshInstance->SetNowLifeTime( pMainEffect->GetNowLifeTime() );	
					    pMeshInstance->SetMaxLifeTime( pMainEffect->GetMaxLifeTime() + 0.13333f );
                    }

					pDamageData->damage.fPhysic *= 1.2f;
					pDamageData->damage.fMagic *= 1.2f;

					D3DXVECTOR3 vAmplifyScale = m_pDamageEffect->GetMainEffectScaleByUnit();
					D3DXVECTOR3 vScale = pMainEffect->GetScale();
#ifdef SERV_EVE_BATTLE_SERAPH
					if ( m_AmplifyDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE" ) != 0
						&& m_AmplifyDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE_MEMO" ) != 0
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
						&& m_AmplifyDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet" ) != 0
#endif //UPGRADE_SKILL_SYSTEM_2013
#ifdef ADD_MEMO_1ST_CLASS
						&& m_AmplifyDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet_MEMO" ) != 0
#endif //ADD_MEMO_1ST_CLASS
						)
					{
						pEffect->SetPassiveparticleTriggerTimeRate( pMainEffect->GetMaxLifeTime() + 0.13333f );
					}
#endif
#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
					if ( m_AmplifyDamageEffectName.compare( L"EVE_MEGA_ELECTRON_BALL_FILTERED" ) == 0 )
					{
						float fNowPowerRate = m_pDamageEffect->GetPowerRate();
						const float fPowerRateModifier = 1.2f;
						fNowPowerRate *= fPowerRateModifier;

						// 메가 일렉트론 볼의 DieDamageEffect 데미지 적용을 위해 추가
						pEffect->SetPowerRate(fNowPowerRate);
					}
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편

					vAmplifyScale.x *= vScale.x;
					vAmplifyScale.y *= vScale.y;
					vAmplifyScale.z *= vScale.z;
#ifdef SERV_EVE_BATTLE_SERAPH
					vAmplifyScale *= 1.3f + m_pEveElectraSystem->m_fHyperOpticalResearchScale;
#else
					vAmplifyScale *= 1.3f;
#endif

					pEffect->SetScale( vAmplifyScale );

					D3DXVECTOR3 vSecondRotateDegree = vRotateDegree; 
					vSecondRotateDegree.z += m_pEveElectraSystem->m_fPlaneZAngle;

					if( vRotateDegree.z != 0.f)
						vSecondRotateDegree.z -= vRotateDegree.z;

                    if ( pMeshInstance != NULL )
                    {
					    pMeshInstance->SetRotateDegree( vSecondRotateDegree );
					    pMeshInstance->SetMoveAxisAngleDegree( vSecondRotateDegree );
                    }


				}
				break;
			case PFT_SPECTRUM:
				{
					for(UINT i = 1; i <= 3; i++ )
					{
#ifdef SERV_EVE_BATTLE_SERAPH
						CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance(
							m_pEveElectraSystem->m_pGUEve, m_SpectrumDamageEffectName.c_str(), m_pDamageEffect->GetPowerRate(),
							vEffectEndPos, vRotateDegree, vRotateDegree );
#else
						CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( m_pEveElectraSystem->m_pGUEve, m_SpectrumDamageEffectName.c_str(), m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vEffectEndPos, vRotateDegree, vRotateDegree );
#endif

						CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
						*pDamageData = m_pDamageEffect->GetDamageData();
#ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			            pDamageData->hAttackerEffect = pEffect->GetHandle();
#else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
					    pDamageData->pAttackerEffect = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
#ifdef FIX_EVE_TASER_PILUM
	#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
						int iAddDamageTime = m_pEveElectraSystem->m_pGUEve->GetTaserPilumAddDamageTime();

						if ( iAddDamageTime > 0 )
						{
							m_pEveElectraSystem->m_pGUEve->ResetTaserPilumTinyData();
							pEffect->SetDamageTime( pEffect->GetDamageTime() + iAddDamageTime );
						}

						int iAddDamageTimeKugel = m_pEveElectraSystem->m_pGUEve->GetKugelBlitzAddDamageTime();

						if ( iAddDamageTimeKugel > 0 )
						{
							m_pEveElectraSystem->m_pGUEve->ResetKugelBlitzTinyData();
							pEffect->SetDamageTime( pEffect->GetDamageTime() + iAddDamageTimeKugel );
						}
	#else //UPGRADE_SKILL_SYSTEM_2013
							int iAddDamageTime = m_pEveElectraSystem->m_pGUEve->GetTaserPilumAddDamageTime();
							m_pEveElectraSystem->m_pGUEve->ResetTaserPilumTinyData();
							pEffect->SetDamageTime( pEffect->GetDamageTime() + iAddDamageTime );
	#endif //UPGRADE_SKILL_SYSTEM_2013
#endif // FIX_EVE_TASER_PILUM
                        CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect();
                        if ( pMeshInstance != NULL )
                        {
						    pMeshInstance->SetNowLifeTime( pMainEffect->GetNowLifeTime() );
						    pMeshInstance->SetMaxLifeTime( pMainEffect->GetMaxLifeTime() + 0.13333f );
                        }
#ifdef SERV_EVE_BATTLE_SERAPH
						if ( m_SpectrumDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE" ) != 0
							&& m_SpectrumDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE_MEMO" ) != 0
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
							&& m_SpectrumDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet" ) != 0
#endif //UPGRADE_SKILL_SYSTEM_2013
#ifdef ADD_MEMO_1ST_CLASS
							&& m_SpectrumDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet_MEMO" ) != 0
#endif //ADD_MEMO_1ST_CLASS
							)
						{
							pEffect->SetPassiveparticleTriggerTimeRate( pMainEffect->GetMaxLifeTime() + 0.13333f );
						}
						pDamageData->fForceDownValue	*= 0.333f;
#endif

						float fNowPowerRate = m_pDamageEffect->GetPowerRate();
						// 공격력 감소
						{
							const float fPowerRateModifier = 0.45f;
							pDamageData->damage.fPhysic *= fPowerRateModifier;
							pDamageData->damage.fMagic *= fPowerRateModifier;
							fNowPowerRate *= fPowerRateModifier;

#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
							// 일반 일렉트론 볼은 역장마다 다른 데미지 이펙트를 사용하여 
							// 데미지가 이미 결정되어 있다.
							if ( m_SpectrumDamageEffectName.compare( L"EVE_MEGA_ELECTRON_BALL_FILTERED" ) == 0 )
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
							{
								// 메가 일렉트론 볼의 DieDamageEffect 데미지 적용을 위해 추가
								pEffect->SetPowerRate(fNowPowerRate);
							}
						}

						D3DXVECTOR3 vSpectrumScale = m_pDamageEffect->GetMainEffectScaleByUnit();
						D3DXVECTOR3 vScale = pMainEffect->GetScale();

						vSpectrumScale.x *= vScale.x;
						vSpectrumScale.y *= vScale.y;
						vSpectrumScale.z *= vScale.z;
						vSpectrumScale *= 0.8f;

						pEffect->SetScale( vSpectrumScale );

						D3DXVECTOR3 vSecondRotateDegree = vRotateDegree; 

						if( i == 2)
							vSecondRotateDegree.z += m_pEveElectraSystem->m_fPlaneZAngle + 30.f;
						else if( i == 3)
							vSecondRotateDegree.z += m_pEveElectraSystem->m_fPlaneZAngle - 30.f;
						else
							vSecondRotateDegree.z += m_pEveElectraSystem->m_fPlaneZAngle;

						if( vRotateDegree.z != 0.f)
							vSecondRotateDegree.z -= vRotateDegree.z;

                        if ( pMeshInstance != NULL )
                        {
						    pMeshInstance->SetRotateDegree( vSecondRotateDegree );
						    pMeshInstance->SetMoveAxisAngleDegree( vSecondRotateDegree );
                        }
					}
				}
				break;
#ifdef SERV_EVE_BATTLE_SERAPH
			case PFT_INDUCTION:		/// 일렉트론 볼, 메가 일렉트론 볼, 테이저 필라, 스위프 롤링
				{
					CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( 
						m_pEveElectraSystem->m_pGUEve, m_InductionDamageEffectName.c_str(), m_pDamageEffect->GetPowerRate(),
						vEffectEndPos, vRotateDegree, vRotateDegree );

					CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
					*pDamageData = m_pDamageEffect->GetDamageData();
#ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			        pDamageData->hAttackerEffect = pEffect->GetHandle();
#else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
					pDamageData->pAttackerEffect = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

                    CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect();
                    if ( pMeshInstance != NULL )
					    pMeshInstance->SetNowLifeTime( pMainEffect->GetNowLifeTime() );	

					if ( m_InductionDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE" ) != 0
						&& m_InductionDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE_MEMO" ) != 0
						&& m_InductionDamageEffectName.compare( L"EVE_ENERGY_NEEDLES_FILTERED" ) != 0
						&& m_InductionDamageEffectName.compare( L"EVE_TASER_PILUM_CHARGE_0_FILTERED" ) != 0
						&& m_InductionDamageEffectName.compare( L"EVE_TASER_PILUM_CHARGE_1_FILTERED" ) != 0
						&& m_InductionDamageEffectName.compare( L"EVE_TASER_PILUM_CHARGE_2_FILTERED" ) != 0
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
						&& m_InductionDamageEffectName.compare( L"Damage_KugelBlitz_Charge_FILTERED" ) != 0
#endif //UPGRADE_SKILL_SYSTEM_2013
						&& m_FusionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet" ) != 0
#ifdef ADD_MEMO_1ST_CLASS
						&& m_FusionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet_MEMO" ) != 0
#endif //ADD_MEMO_1ST_CLASS
						)
					{
                        if ( pMeshInstance != NULL )
						    pMeshInstance->SetMaxLifeTime( pMainEffect->GetMaxLifeTime() * 1.1f + 0.13333f );
						pEffect->SetPassiveparticleTriggerTimeRate( pMainEffect->GetMaxLifeTime() * 1.1f + 0.13333f );
						pEffect->SetDamageTime( pEffect->GetDamageTime() + 1 );

						pDamageData->damage.fPhysic *= 0.55f;
						pDamageData->damage.fMagic *= 0.55f;
						pDamageData->fHitGap = 0.3f;

						pDamageData->bReAttack			= true;
						pDamageData->fHitAddMP			*= 0.55f;
						pDamageData->m_fRateModifier	*= 0.55f;
						pDamageData->techPoint			= int(pDamageData->techPoint * 0.55);

						D3DXVECTOR3 vInductionScale = m_pDamageEffect->GetMainEffectScaleByUnit();
						D3DXVECTOR3 vScale = pMainEffect->GetScale();

						vInductionScale.x *= vScale.x;
						vInductionScale.y *= vScale.y;
						vInductionScale.z *= vScale.z;

						vInductionScale *= 0.8f;

						pEffect->SetScale( vInductionScale );
#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
						if ( m_InductionDamageEffectName.compare( L"EVE_MEGA_ELECTRON_BALL_FILTERED" ) == 0 )
						{
							float fNowPowerRate = m_pDamageEffect->GetPowerRate();
							const float fPowerRateModifier = 0.55f;
							fNowPowerRate *= fPowerRateModifier;

							// 메가 일렉트론 볼의 DieDamageEffect 데미지 적용을 위해 추가
							pEffect->SetPowerRate(fNowPowerRate);
						}
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편

					}
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
					else if ( m_InductionDamageEffectName.compare( L"Damage_KugelBlitz_Charge_FILTERED" ) == 0 )
					{
						int iAddDamageTime = m_pEveElectraSystem->m_pGUEve->GetKugelBlitzAddDamageTime();						
						D3DXVECTOR3 vInductionScale = m_pDamageEffect->GetMainEffectScaleByUnit();
						D3DXVECTOR3 vScale = pMainEffect->GetScale();

						vInductionScale.x *= vScale.x;
						vInductionScale.y *= vScale.y;
						vInductionScale.z *= vScale.z;

						vInductionScale *= 0.8f;

						pEffect->SetScale( vInductionScale );


						if ( iAddDamageTime > 0 )
						{
							m_pEveElectraSystem->m_pGUEve->ResetKugelBlitzTinyData();
							pEffect->SetDamageTime( pEffect->GetDamageTime() + iAddDamageTime );
						}
					}
#endif //UPGRADE_SKILL_SYSTEM_2013
#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
				
					else if ( m_InductionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet" ) == 0 ||
#ifdef ADD_MEMO_1ST_CLASS
							m_InductionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet_MEMO" ) == 0 ||
#endif //ADD_MEMO_1ST_CLASS
							m_InductionDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE" ) == 0 ||
							m_InductionDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE_MEMO" ) == 0 )
					{
						// 트라이 앵클 발칸의 경우 아래의 경우에 대해 예외적으로 처리 한다.
						// 크기 0.8배 감소
						D3DXVECTOR3 vInductionScale = m_pDamageEffect->GetMainEffectScaleByUnit();
						D3DXVECTOR3 vScale = pMainEffect->GetScale();

						vInductionScale.x *= vScale.x;
						vInductionScale.y *= vScale.y;
						vInductionScale.z *= vScale.z;

						vInductionScale *= 0.8f;

						pEffect->SetScale( vInductionScale );
					}
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편

#ifdef FIX_EVE_TASER_PILUM
					else
					{
						int iAddDamageTime = m_pEveElectraSystem->m_pGUEve->GetTaserPilumAddDamageTime();
						m_pEveElectraSystem->m_pGUEve->ResetTaserPilumTinyData();
						pEffect->SetDamageTime( pEffect->GetDamageTime() + iAddDamageTime );
					}
#endif // FIX_EVE_TASER_PILUM

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
					if ( m_InductionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet" ) == 0
#ifdef ADD_MEMO_1ST_CLASS
						|| m_InductionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet_MEMO" ) == 0 
#endif //ADD_MEMO_1ST_CLASS
#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
						|| m_InductionDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE" ) == 0 
						|| m_InductionDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE_MEMO" ) == 0 
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편											
						)
					{

#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
						// 트라이 앵클 발칸의 경우 아래의 경우에 대해 예외적으로 처리 한다.
						// 데미지 1.1배 증가, R
						pDamageData->damage.fPhysic *= 1.1f;
						pDamageData->damage.fMagic *= 1.1f;
						
#else // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
						pDamageData->fHitGap = 0.7f;

#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
					}
#endif //UPGRADE_SKILL_SYSTEM_2013
					D3DXVECTOR3 vSecondRotateDegree = vRotateDegree; 
					vSecondRotateDegree.z += m_pEveElectraSystem->m_fPlaneZAngle;

					if( vRotateDegree.z != 0.f)
						vSecondRotateDegree.z -= vRotateDegree.z;

					if ( pMeshInstance != NULL )
					{
						pMeshInstance->SetRotateDegree( vSecondRotateDegree );
						pMeshInstance->SetMoveAxisAngleDegree( vSecondRotateDegree );

						pMeshInstance->SetDirSpeed( pEffect->GetMainEffect()->GetVelocity().x );
						pMeshInstance->SetVelocity( D3DXVECTOR3( 0.f, 0.f, 0.f ) );
					}

					pEffect->GetLockOnData().m_LockOnType = CX2DamageEffect::LOT_NEARST_UID_VECTOR_IN_RANGE;
					pEffect->GetLockOnData().m_fCurveSpeed = 10;
					pEffect->GetLockOnData().m_fTimeUnlockFromStart = 0.1f;

#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
					// 트라이 앵클 발칸의 경우 아래의 경우에 대해 예외적으로 처리 한다.
					// NOT_TARGET_PRE_LOCK_ON_TARGET 추가 ( 때린 유닛이 있다면 다음 유닛을 때리러 감, 체인 라이트닝 )
					if ( m_InductionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet" ) == 0 
#ifdef ADD_MEMO_1ST_CLASS
						|| m_InductionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet_MEMO" ) == 0 
#endif //ADD_MEMO_1ST_CLASS
						)
					{
						pEffect->GetLockOnData().m_bIsNotTargetPreLockOnTarget = true;
					}
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편

					bool bUserUnit = false;
					UidType gameUnitUID = -1;

					if ( g_pMain->GetNowStateID() == CX2Main::XS_PVP_GAME )
						gameUnitUID = g_pX2Game->GetLockOnNearstTargetInRange( static_cast<CX2Room::TEAM_NUM>( 
						m_pEveElectraSystem->m_pGUEve->GetTeam() ), pEffect->GetPos(), D3DXVECTOR2(0, 1000), bUserUnit );
					else
						gameUnitUID = g_pX2Game->GetLockOnNearstTargetInRange( static_cast<CX2Room::TEAM_NUM>( 
						m_pEveElectraSystem->m_pGUEve->GetTeam() ), pEffect->GetPos(), D3DXVECTOR2(0, 1500), bUserUnit );

					if( bUserUnit == true )
					{
						pEffect->SetLockOnUnitUID( gameUnitUID );
						pEffect->SetLockOnRandomSeed( (int)m_pEveElectraSystem->m_pGUEve->GetRandomInt() );
					}
					else
					{
						pEffect->SetLockOnNPCUID( static_cast<int>( gameUnitUID ) );
						pEffect->SetLockOnRandomSeed( (int)m_pEveElectraSystem->m_pGUEve->GetRandomInt() );
					}
				} break;

			case PFT_FUSION:
				{
					for(UINT i = 1; i <= 3; i++ )
					{
						CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance(
							m_pEveElectraSystem->m_pGUEve, m_FusionDamageEffectName.c_str(), m_pDamageEffect->GetPowerRate(),
							vEffectEndPos, vRotateDegree, vRotateDegree );

						CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
						*pDamageData = m_pDamageEffect->GetDamageData();
#ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			            pDamageData->hAttackerEffect = pEffect->GetHandle();
#else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
					    pDamageData->pAttackerEffect = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

                        CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect();
                        if ( pMeshInstance != NULL )
						    pMeshInstance->SetNowLifeTime( pMainEffect->GetNowLifeTime() );	
						float fNowPowerRate = m_pDamageEffect->GetPowerRate();

						if ( m_FusionDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE" ) != 0
							&& m_FusionDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE_MEMO" ) != 0
							&& m_FusionDamageEffectName.compare( L"EVE_ENERGY_NEEDLES_FILTERED" ) != 0
							&& m_FusionDamageEffectName.compare( L"EVE_TASER_PILUM_CHARGE_0_FILTERED" ) != 0
							&& m_FusionDamageEffectName.compare( L"EVE_TASER_PILUM_CHARGE_1_FILTERED" ) != 0
							&& m_FusionDamageEffectName.compare( L"EVE_TASER_PILUM_CHARGE_2_FILTERED" ) != 0
	#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
							&& m_FusionDamageEffectName.compare( L"Damage_KugelBlitz_Charge_FILTERED" ) != 0
	#endif //UPGRADE_SKILL_SYSTEM_2013
							&& m_FusionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet" ) != 0
#ifdef ADD_MEMO_1ST_CLASS
							&& m_FusionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet_MEMO" ) != 0
#endif //ADD_MEMO_1ST_CLASS
							)
						{
                            if ( pMeshInstance != NULL )
							    pMeshInstance->SetMaxLifeTime( pMainEffect->GetMaxLifeTime() * 1.1f + 0.13333f );
							pEffect->SetPassiveparticleTriggerTimeRate( pMainEffect->GetMaxLifeTime() * 1.1f + 0.13333f );

							pEffect->SetDamageTime( pEffect->GetDamageTime() + 1 );

							// 공격력 감소
							{
								const float fPowerRateModifier = 0.5f;				
								pDamageData->damage.fPhysic *= fPowerRateModifier;
								pDamageData->damage.fMagic *= fPowerRateModifier;
								fNowPowerRate *= fPowerRateModifier;
							}

							pDamageData->fHitGap = 0.3f;
							pDamageData->bReAttack			= true;
							pDamageData->m_fRateModifier	*= 0.25f;


						}
#ifdef FIX_EVE_TASER_PILUM
						else
						{
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
							int iAddDamageTime = m_pEveElectraSystem->m_pGUEve->GetTaserPilumAddDamageTime();

							if ( iAddDamageTime > 0 )
							{
								m_pEveElectraSystem->m_pGUEve->ResetTaserPilumTinyData();
								pEffect->SetDamageTime( pEffect->GetDamageTime() + iAddDamageTime );
							}

							int iAddDamageTimeKugel = m_pEveElectraSystem->m_pGUEve->GetKugelBlitzAddDamageTime();

							if ( iAddDamageTimeKugel > 0 )
							{
								m_pEveElectraSystem->m_pGUEve->ResetKugelBlitzTinyData();
								pEffect->SetDamageTime( pEffect->GetDamageTime() + iAddDamageTimeKugel );
							}
#else //UPGRADE_SKILL_SYSTEM_2013
							int iAddDamageTime = m_pEveElectraSystem->m_pGUEve->GetTaserPilumAddDamageTime();
							m_pEveElectraSystem->m_pGUEve->ResetTaserPilumTinyData();
							pEffect->SetDamageTime( pEffect->GetDamageTime() + iAddDamageTime );
#endif //UPGRADE_SKILL_SYSTEM_2013
						}
#endif // FIX_EVE_TASER_PILUM

#ifndef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
						if ( m_FusionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet" ) == 0 
#ifdef ADD_MEMO_1ST_CLASS
							|| m_FusionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet_MEMO" ) == 0 
#endif //ADD_MEMO_1ST_CLASS
							)
							pDamageData->fHitGap = 0.7f;
#endif //UPGRADE_SKILL_SYSTEM_2013
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편

						{
							// 공격력 감소
						
							const float fPowerRateModifier = 0.5f;
							
							pDamageData->damage.fPhysic *= fPowerRateModifier;
							pDamageData->damage.fMagic *= fPowerRateModifier;
							fNowPowerRate *= fPowerRateModifier;
							
							// 메가 일렉트론 볼의 DieDamageEffect 데미지 적용을 위해 추가
#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
							if ( m_InductionDamageEffectName.compare( L"EVE_MEGA_ELECTRON_BALL_FILTERED" ) == 0 )
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
							{
								pEffect->SetPowerRate( fNowPowerRate );
							}
						}

#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
						if ( m_FusionDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE" ) == 0 ||
							m_FusionDamageEffectName.compare( L"EVE_SWEEP_PARADE_TRIANGLE_MEMO" ) == 0 ) 
						{
							pDamageData->fHitAddMP *= 0.5f;
						} 
						else if ( m_FusionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet" ) == 0 
#ifdef ADD_MEMO_1ST_CLASS
								|| m_FusionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet_MEMO" ) == 0 
#endif //ADD_MEMO_1ST_CLASS
							)
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
						{
							// 밸런스 개편으로 트라이 발칸이 융합장을 지나갈 시, Hitgap 변경 삭제
							pDamageData->fHitAddMP *= 0.25f;
						}
#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
						pDamageData->techPoint = int(pDamageData->techPoint * 0.5);
#else // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
						pDamageData->techPoint = int(pDamageData->techPoint * 0.25);
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편

						D3DXVECTOR3 vFusionScale = m_pDamageEffect->GetMainEffectScaleByUnit();
						D3DXVECTOR3 vScale = pMainEffect->GetScale();

						vFusionScale.x *= vScale.x;
						vFusionScale.y *= vScale.y;
						vFusionScale.z *= vScale.z;

						vFusionScale *= 0.75f;

						pEffect->SetScale( vFusionScale );

						D3DXVECTOR3 vSecondRotateDegree = vRotateDegree; 

						if( i == 2)
							vSecondRotateDegree.z += m_pEveElectraSystem->m_fPlaneZAngle + 30.f;
						else if( i == 3)
							vSecondRotateDegree.z += m_pEveElectraSystem->m_fPlaneZAngle - 30.f;
						else
							vSecondRotateDegree.z += m_pEveElectraSystem->m_fPlaneZAngle;

						if( vRotateDegree.z != 0.f)
							vSecondRotateDegree.z -= vRotateDegree.z;

						if ( pMeshInstance != NULL )
						{
							pMeshInstance->SetRotateDegree( vSecondRotateDegree );
							pMeshInstance->SetMoveAxisAngleDegree( vSecondRotateDegree );

							pMeshInstance->SetDirSpeed( pMeshInstance->GetVelocity().x );
							pMeshInstance->SetVelocity( D3DXVECTOR3( 0.f, 0.f, 0.f ) );
						}
						pEffect->GetLockOnData().m_LockOnType = CX2DamageEffect::LOT_NEARST_UID_VECTOR;
						pEffect->GetLockOnData().m_fCurveSpeed = 10;
						pEffect->GetLockOnData().m_fTimeUnlockFromStart = 0.1f;

#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
						if ( m_FusionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet" ) == 0 
#ifdef ADD_MEMO_1ST_CLASS
							|| m_FusionDamageEffectName.compare( L"DamageEffect_Triangle_Vulcan_Bullet_MEMO" ) == 0 
#endif //ADD_MEMO_1ST_CLASS
							)
						{
							// 밸런스 개편으로 트라이 발칸이 융합장을 지나갈 시, NOT_TARGET_PRE_LOCK_ON_TARGET 옵션을 켜줌
							pEffect->GetLockOnData().m_bIsNotTargetPreLockOnTarget = true;
						}
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
						bool bUserUnit = false;
						UidType gameUnitUID = -1;

						if ( g_pMain->GetNowStateID() == CX2Main::XS_PVP_GAME )
							gameUnitUID = g_pX2Game->GetLockOnNearstTargetInRange( static_cast<CX2Room::TEAM_NUM>( 
							m_pEveElectraSystem->m_pGUEve->GetTeam() ), pEffect->GetPos(), D3DXVECTOR2(0, 1000), bUserUnit );
						else
							gameUnitUID = g_pX2Game->GetLockOnNearstTargetInRange( static_cast<CX2Room::TEAM_NUM>( 
							m_pEveElectraSystem->m_pGUEve->GetTeam() ), pEffect->GetPos(), D3DXVECTOR2(0, 1500), bUserUnit );

						if( bUserUnit == true )
						{
							pEffect->SetLockOnUnitUID( gameUnitUID );
							pEffect->SetLockOnRandomSeed( (int)m_pEveElectraSystem->m_pGUEve->GetRandomInt() );
						}
						else
						{
							pEffect->SetLockOnNPCUID( static_cast<int>( gameUnitUID ) );
							pEffect->SetLockOnRandomSeed( (int)m_pEveElectraSystem->m_pGUEve->GetRandomInt() );
						}
					}
				} break;
#endif
			}
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
            g_pX2Game->GetDamageEffect()->DestroyInstanceHandleSilently( m_hDamageEffect );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			g_pX2Game->GetDamageEffect()->DestroyInstanceSilently( m_pDamageEffect );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			m_bDie = true;

		}
	}
	else
	{
		m_bDie = true;
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        m_hDamageEffect = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
		m_pDamageEffect = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	}


	return;
}
CX2GUEve::EveElectraLockonData::EveElectraLockonData( EveElectraSystem* _pEveElectraSystem )
{
	m_pEveElectraSystem	= _pEveElectraSystem;
	m_fElapsedTime		= 0.f;
	m_bPlaneFront		= false;
	m_bDie				= false;
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hDamageEffect = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_pDamageEffect		= NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
}

void CX2GUEve::EveElectraLockonData::OnFrameMove( float fElapsedTime )
{
	D3DXVECTOR3 vRotateDegree;
	m_fElapsedTime += fElapsedTime;

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    CX2DamageEffect::CEffect* m_pDamageEffect = g_pX2Game->GetDamageEffect()->GetInstance( m_hDamageEffect );
    if( CKTDGXMeshPlayer::CXMeshInstance* pMainEffect = ( m_pDamageEffect != NULL ) ? m_pDamageEffect->GetMainEffect() : NULL )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    CKTDGXMeshPlayer::CXMeshInstance* pMainEffect = ( m_pDamageEffect != NULL ) ? m_pDamageEffect->GetMainEffect() : NULL;
	if( pMainEffect != NULL && g_pX2Game->GetDamageEffect()->IsLiveInstance( m_pDamageEffect ) == true )
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	{
		vRotateDegree = pMainEffect->GetRotateDegree();


		D3DXVECTOR3 vEffectNowPos = pMainEffect->GetPos();


		if( m_pEveElectraSystem->GetEnablePlane() == false )
		{
			m_bPlaneFront = false;
		}
		else if( D3DXPlaneDotCoord( &m_pEveElectraSystem->m_PrimaryPlane, &D3DXVECTOR3( vEffectNowPos ) ) < 0.0f )
		{
			m_vPlaneIntersectPoint = vEffectNowPos;
			m_bPlaneFront = true;
		}
		else if( m_bPlaneFront == true )
		{

			D3DXVECTOR3 vPlaneIntersectPoint;
			D3DXVECTOR3 vEffectEndPos;
			D3DXPlaneIntersectLine( &vEffectEndPos, &m_pEveElectraSystem->m_PrimaryPlane, &vEffectNowPos, &m_vPlaneIntersectPoint );

			switch( m_pEveElectraSystem->m_ePlaneFormationType )
			{
			case PFT_AMPLIFIER:
				{
					CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( m_pEveElectraSystem->m_pGUEve, m_AmplifyDamageEffectName.c_str(), m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vEffectEndPos, vRotateDegree, vRotateDegree );

					CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
					*pDamageData = m_pDamageEffect->GetDamageData();
#ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			        pDamageData->hAttackerEffect = pEffect->GetHandle();
#else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
					pDamageData->pAttackerEffect = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

					pEffect->GetLockOnData().m_bLockOnUserUnit	= m_pDamageEffect->GetLockOnData().m_bLockOnUserUnit;
					pEffect->GetLockOnData().m_LockOnUnitUID	= m_pDamageEffect->GetLockOnData().m_LockOnUnitUID;
					pEffect->GetLockOnData().m_LockOnNPCUID	= m_pDamageEffect->GetLockOnData().m_LockOnNPCUID;

                    CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect();
                    if ( pMeshInstance != NULL )
                    {
					    pMeshInstance->SetNowLifeTime( pMainEffect->GetNowLifeTime() );	
					    pMeshInstance->SetMaxLifeTime( pMainEffect->GetMaxLifeTime() + 0.2f );	
                    }

					pDamageData->damage.fPhysic *= 1.2f;
					pDamageData->damage.fMagic *= 1.2f;

					pEffect->SetScale( D3DXVECTOR3( 1.3f, 1.3f, 1.3f ) );

					//D3DXVECTOR3 vManualDirDegree = GetDirVecToDegree( m_pEveElectraSystem->m_vPlaneNormal );

					D3DXVECTOR3 vManualDirDegree;

					vManualDirDegree.x = D3DXToDegree(m_pEveElectraSystem->m_vPlaneNormal.x);
					vManualDirDegree.y = D3DXToDegree(m_pEveElectraSystem->m_vPlaneNormal.y);
					vManualDirDegree.z = D3DXToDegree(m_pEveElectraSystem->m_vPlaneNormal.z);

                    if ( pMeshInstance != NULL )
                    {
					    pMeshInstance->SetManualDirDegree( vManualDirDegree );
					    pMeshInstance->UseManualDirDegree( true );
                    }

				}
				break;
			case PFT_SPECTRUM:
				{
					for(UINT i = 1; i <= 3; i++ )
					{
						CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( m_pEveElectraSystem->m_pGUEve, m_SpectrumDamageEffectName.c_str(), m_pEveElectraSystem->m_pGUEve->GetPowerRate(), vEffectEndPos, vRotateDegree, vRotateDegree );

						CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();
						*pDamageData = m_pDamageEffect->GetDamageData();
#ifdef      X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			            pDamageData->hAttackerEffect = pEffect->GetHandle();
#else       X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
					    pDamageData->pAttackerEffect = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

						pEffect->GetLockOnData().m_bLockOnUserUnit	= m_pDamageEffect->GetLockOnData().m_bLockOnUserUnit;
						pEffect->GetLockOnData().m_LockOnUnitUID	= m_pDamageEffect->GetLockOnData().m_LockOnUnitUID;
						pEffect->GetLockOnData().m_LockOnNPCUID	= m_pDamageEffect->GetLockOnData().m_LockOnNPCUID;

                        CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect();
                        if ( pMeshInstance != NULL )
                        {
    						pMeshInstance->SetNowLifeTime( pMainEffect->GetNowLifeTime() );
	    					pMeshInstance->SetMaxLifeTime( pMainEffect->GetMaxLifeTime() + 0.2f );	
                        }

						pDamageData->damage.fPhysic *= 0.5f;
						pDamageData->damage.fMagic *= 0.5f;

						pEffect->SetScale( D3DXVECTOR3( 0.8f, 0.8f, 0.8f ) );


						D3DXVECTOR3 vRotationAxis;
						D3DXVec3Cross( &vRotationAxis, &m_pEveElectraSystem->m_vPlaneNormal, &Y_AXIS );
						D3DXVec3Normalize( &vRotationAxis, &vRotationAxis );


						D3DXMATRIX matRotation_2;
						D3DXMatrixRotationAxis( &matRotation_2, &vRotationAxis, D3DX_PI / 180.f * 30.f );

						D3DXMATRIX matRotation_3;
						D3DXMatrixRotationAxis( &matRotation_3, &vRotationAxis, D3DX_PI / 180.f * -30.f );


						D3DXVECTOR4 v4DirVectorLockon_2;
						D3DXVec3Transform( &v4DirVectorLockon_2, &m_pEveElectraSystem->m_vPlaneNormal, &matRotation_2 );
						D3DXVECTOR3 vDirVectorLockon_2 = v4DirVectorLockon_2;

						D3DXVECTOR4 v4DirVectorLockon_3;
						D3DXVec3Transform( &v4DirVectorLockon_3, &m_pEveElectraSystem->m_vPlaneNormal, &matRotation_3 );
						D3DXVECTOR3 vDirVectorLockon_3 = v4DirVectorLockon_3;

						D3DXVECTOR3 vManualDirDegree1;
						vManualDirDegree1.x = D3DXToDegree(m_pEveElectraSystem->m_vPlaneNormal.x);
						vManualDirDegree1.y = D3DXToDegree(m_pEveElectraSystem->m_vPlaneNormal.y);
						vManualDirDegree1.z = D3DXToDegree(m_pEveElectraSystem->m_vPlaneNormal.z);

						D3DXVECTOR3 vManualDirDegree2;
						vManualDirDegree2.x = D3DXToDegree(vDirVectorLockon_2.x);
						vManualDirDegree2.y = D3DXToDegree(vDirVectorLockon_2.y);
						vManualDirDegree2.z = D3DXToDegree(vDirVectorLockon_2.z);

						D3DXVECTOR3 vManualDirDegree3;
						vManualDirDegree3.x = D3DXToDegree(vDirVectorLockon_3.x);
						vManualDirDegree3.y = D3DXToDegree(vDirVectorLockon_3.y);
						vManualDirDegree3.z = D3DXToDegree(vDirVectorLockon_3.z);


                        if ( pMeshInstance != NULL )
                        {
						    if( i == 2)
							    pMeshInstance->SetManualDirDegree( vManualDirDegree2 );
						    else if( i == 3)
							    pMeshInstance->SetManualDirDegree( vManualDirDegree3 );
						    else
							    pMeshInstance->SetManualDirDegree( vManualDirDegree1 );

						    pMeshInstance->UseManualDirDegree( true );
                        }
					}
				}
				break;
			}
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
            g_pX2Game->GetDamageEffect()->DestroyInstanceHandleSilently( m_hDamageEffect );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			g_pX2Game->GetDamageEffect()->DestroyInstanceSilently( m_pDamageEffect );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
			m_bDie = true;

		}
	}
	else
	{
		m_bDie = true;
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        m_hDamageEffect = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
		m_pDamageEffect = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	}
	return;
}

CX2GUEve::EveElectraSystem::EveElectraSystem( CX2GUEve* _pGUEve )
{
	m_pGUEve					= _pGUEve;
	m_fPlaneZAngle				= 0.f;
	m_fLastPlaneZAngle			= 0.f;
	m_bSystemEnable				= false;
	m_bPlaneEnable				= false;
	m_bSpectrumDynamicsEnable	= false;
#ifdef SERV_EVE_BATTLE_SERAPH
	m_bHyperOpticalResearch			= false;
	m_fHyperOpticalResearchScale	= 0.f;

	m_bExceptionSystem					= false;
	m_fExceptionSystemOperationTime		= 0.f;
	m_fExceptionSystemRemainTime		= 0.f;
	m_fExceptionFormationSetElapsedTime	= 0.f;
	m_ePrevSpectro						= PFT_NONE;

	m_fEveZAngle	= 0.f;
#endif
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	m_iLaserGroupNum = 1;
#endif //UPGRADE_SKILL_SYSTEM_2013
	m_fSystemOperationTime		= 0.f;
	m_fFormationSetElapsedTime	= 0.f;
	m_ePlaneFormationType	= PFT_AMPLIFIER;

	m_fLaserRangeScale			= 1.f;

	m_bGigaPlaneEnable			= false;
	m_fGigaPlaneZAngle			= 0.f;

	m_hEffectPlane		= INVALID_MESH_INSTANCE_HANDLE;
	m_hEffectCrystal1	= INVALID_MESH_INSTANCE_HANDLE;
	m_hEffectCrystal2	= INVALID_MESH_INSTANCE_HANDLE;
	m_hEffectCrystal3	= INVALID_MESH_INSTANCE_HANDLE;

	m_hParticlePlane		= INVALID_PARTICLE_SEQUENCE_HANDLE;

	m_hParticleCrystal[0]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleCrystal[1]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleCrystal[2]	= INVALID_PARTICLE_SEQUENCE_HANDLE;

	m_hParticleFormationMark[0]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleFormationMark[1]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleFormationMark[2]	= INVALID_PARTICLE_SEQUENCE_HANDLE;

	m_hParticleFormationMsg[0]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleFormationMsg[1]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleFormationMsg[2]	= INVALID_PARTICLE_SEQUENCE_HANDLE;

	m_hEffectGigaPlane		= INVALID_MESH_INSTANCE_HANDLE;
	m_hEffectGigaCrystal[0] = INVALID_MESH_INSTANCE_HANDLE;
	m_hEffectGigaCrystal[1] = INVALID_MESH_INSTANCE_HANDLE;
	m_hEffectGigaCrystal[2] = INVALID_MESH_INSTANCE_HANDLE;
	m_hEffectGigaCrystal[3] = INVALID_MESH_INSTANCE_HANDLE;
	m_hEffectGigaCrystal[4] = INVALID_MESH_INSTANCE_HANDLE;

	m_hParticleGigaPlane		= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleGigaCrystal[0]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleGigaCrystal[1]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleGigaCrystal[2]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleGigaCrystal[3]	= INVALID_PARTICLE_SEQUENCE_HANDLE;
	m_hParticleGigaCrystal[4]	= INVALID_PARTICLE_SEQUENCE_HANDLE;

	m_hParticleThousandStarFormation = INVALID_PARTICLE_SEQUENCE_HANDLE;

	m_fLaserEndOffsetX	= 0.f;
	m_fLaserEndOffsetY	= 0.f;

	m_iPriorEffectID		= 1 * ( _pGUEve->GetUnitIndex() + 1 );
	m_iPosteriorEffectID	= 1 * ( _pGUEve->GetUnitIndex() + 1 );

	//m_pEffectPlane = NULL;
}

void CX2GUEve::EveElectraSystem::ProcessPlane( float _fElapsedTime )
{

	CKTDGXMeshPlayer::CXMeshInstance* pMeshInstPlane = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_hEffectPlane );
	if( pMeshInstPlane != NULL )
	{
		if( m_fPlaneZAngle > 0 )
		{
			m_vPlaneNormal	= m_vPlaneNormalUpper;
			m_PrimaryPlane  = m_PlaneUpper;
			D3DXVECTOR3 vRotateDegree = pMeshInstPlane->GetRotateDegree();
			vRotateDegree.z += _fElapsedTime * 120.f;

			if( vRotateDegree.z > m_fPlaneZAngle)
				vRotateDegree.z = m_fPlaneZAngle;

			pMeshInstPlane->SetRotateDegree( vRotateDegree );
			pMeshInstPlane->SetMoveAxisAngleDegree( vRotateDegree );
		}
		else if( m_fPlaneZAngle < 0 )
		{
			m_vPlaneNormal	= m_vPlaneNormalLower;
			m_PrimaryPlane  = m_PlaneLower;

			D3DXVECTOR3 vRotateDegree = pMeshInstPlane->GetRotateDegree();
			vRotateDegree.z += _fElapsedTime * -120.f;

			if( vRotateDegree.z < m_fPlaneZAngle)
				vRotateDegree.z = m_fPlaneZAngle;

			pMeshInstPlane->SetRotateDegree( vRotateDegree );
			pMeshInstPlane->SetMoveAxisAngleDegree( vRotateDegree );
		}
		else
		{
			m_vPlaneNormal	= m_vPlaneNormalCenter;
			m_PrimaryPlane  = m_PlaneCenter;
			pMeshInstPlane->SetRotateDegree( m_vPlaneRotateDegreeCenter );
			pMeshInstPlane->SetMoveAxisAngleDegree( m_vPlaneRotateDegreeCenter );
		}

		CKTDGXMeshPlayer* pMajorMeshPlayer = g_pX2Game->GetMajorXMeshPlayer();
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal1 = pMajorMeshPlayer->GetMeshInstance( m_hEffectCrystal1 );
		CKTDXDeviceXSkinMesh::MultiAnimFrame* pMultiAnimFrame1 = pMeshInstPlane->GetCloneFrame( L"Dummy02" );
		pMeshInstCrystal1->SetPos( pMeshInstPlane->GetBonePos( L"Dummy02" ));

		CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal2 = pMajorMeshPlayer->GetMeshInstance( m_hEffectCrystal2 );
		CKTDXDeviceXSkinMesh::MultiAnimFrame* pMultiAnimFrame2 = pMeshInstPlane->GetCloneFrame( L"Dummy03" );
		pMeshInstCrystal2->SetPos( pMeshInstPlane->GetBonePos( L"Dummy03" ));

		CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal3 = pMajorMeshPlayer->GetMeshInstance( m_hEffectCrystal3 );
		CKTDXDeviceXSkinMesh::MultiAnimFrame* pMultiAnimFrame3 = pMeshInstPlane->GetCloneFrame( L"Dummy04" );
		pMeshInstCrystal3->SetPos( pMeshInstPlane->GetBonePos( L"Dummy04" ));


		CKTDGParticleSystem* pMajorParticleSystem = g_pX2Game->GetMajorParticle();
		CKTDGParticleSystem::CParticleEventSequence* pSeqPlane = pMajorParticleSystem->GetInstanceSequence( m_hParticlePlane );
		if( pSeqPlane != NULL )
		{
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pMultiAnimFrame = pMeshInstPlane->GetCloneFrame( L"Dummy01" );
			pSeqPlane->SetUseDXMatrix( pMultiAnimFrame->combineMatrix );
		}


		CKTDGParticleSystem::CParticleEventSequence* pSeqCrystal1 = pMajorParticleSystem->GetInstanceSequence( m_hParticleCrystal[0] );
		if( pSeqCrystal1 != NULL )
		{
			pSeqCrystal1->SetPosition( pMeshInstPlane->GetBonePos( L"Dummy02" ) );
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeqCrystal2 = pMajorParticleSystem->GetInstanceSequence( m_hParticleCrystal[1] );
		if( pSeqCrystal2 != NULL )
		{
			pSeqCrystal2->SetPosition( pMeshInstPlane->GetBonePos( L"Dummy03" ) );
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeqCrystal3 = pMajorParticleSystem->GetInstanceSequence( m_hParticleCrystal[2] );
		if( pSeqCrystal3 != NULL )
		{
			pSeqCrystal3->SetPosition( pMeshInstPlane->GetBonePos( L"Dummy04" ) );
		}

		if( pMeshInstPlane->EventTimerGlobal( 0.1f ) == true )
		{
			if( m_ePlaneFormationType == PFT_AMPLIFIER )
				m_hParticlePlane = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,
				L"eve_spectro_prism_Red_P01", pMeshInstPlane->GetBonePos( L"Dummy01" ) );
			else if( m_ePlaneFormationType == PFT_SPECTRUM )
				m_hParticlePlane = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,
				L"eve_spectro_prism_Blue_P01", pMeshInstPlane->GetBonePos( L"Dummy01" ) );
#ifdef SERV_EVE_BATTLE_SERAPH
			else if( m_ePlaneFormationType == PFT_INDUCTION )
				m_hParticlePlane = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,
				L"eve_spectro_prism_Green_P01", pMeshInstPlane->GetBonePos( L"Dummy01" ) );
			else if( m_ePlaneFormationType == PFT_FUSION )
				m_hParticlePlane = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,
				L"EBS_SA_energeticHeart_prism_White_P01", pMeshInstPlane->GetBonePos( L"Dummy01" ) );
#endif

		}
		else if( pMeshInstPlane->EventTimerGlobal( 0.2f ) == true )
		{
			// Plane Loop 이펙트 생성

			m_hParticleCrystal[0] = pMajorParticleSystem->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P01", pMeshInstPlane->GetBonePos( L"Dummy02" ) );
			m_hParticleCrystal[1] = pMajorParticleSystem->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P01", pMeshInstPlane->GetBonePos( L"Dummy03" ) );
			m_hParticleCrystal[2] = pMajorParticleSystem->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P01", pMeshInstPlane->GetBonePos( L"Dummy04" ) );
		}
		else if( pMeshInstPlane->EventTimerGlobal( pMeshInstPlane->GetMaxLifeTime() - 0.2333f ) == true )
		{
			// Plane End 이펙트 생성

			pMeshInstCrystal1->ChangeAnim( L"end", CKTDGXSkinAnim::XAP_ONE, 1.f );
			pMeshInstCrystal2->ChangeAnim( L"end", CKTDGXSkinAnim::XAP_ONE, 1.f );
			pMeshInstCrystal3->ChangeAnim( L"end", CKTDGXSkinAnim::XAP_ONE, 1.f );

			pMajorParticleSystem->DestroyInstanceHandle( m_hParticleCrystal[0] );
			pMajorParticleSystem->DestroyInstanceHandle( m_hParticleCrystal[1] );
			pMajorParticleSystem->DestroyInstanceHandle( m_hParticleCrystal[2] );
		}
		else if( pMeshInstPlane->EventTimerGlobal( pMeshInstPlane->GetMaxLifeTime() - 0.1f ) == true )
		{
			pMajorParticleSystem->DestroyInstanceHandle( m_hParticlePlane );
		}
	}
	else
	{
		m_hEffectPlane = INVALID_MESH_INSTANCE_HANDLE;	/// 시간에 의해 소멸 됬을 것이기에 INVALID_HANDLE 대입
		DestroyPlaneAndCrystalEffect();
		SetEnablePlane( false );
	}

}



void CX2GUEve::EveElectraSystem::ProcessGigaPlane( float _fElapsedTime )
{
	CKTDGXMeshPlayer::CXMeshInstance* pMeshInstPlane = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_hEffectGigaPlane );
	if( pMeshInstPlane != NULL )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal1 = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_hEffectGigaCrystal[0] );
		pMeshInstCrystal1->SetPos( pMeshInstPlane->GetBonePos( L"Dummy02" ));

		CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal2 = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_hEffectGigaCrystal[1] );
		pMeshInstCrystal2->SetPos( pMeshInstPlane->GetBonePos( L"Dummy03" ));

		CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal3 = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_hEffectGigaCrystal[2] );
		pMeshInstCrystal3->SetPos( pMeshInstPlane->GetBonePos( L"Dummy04" ));

		CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal4 = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_hEffectGigaCrystal[3] );
		pMeshInstCrystal4->SetPos( pMeshInstPlane->GetBonePos( L"Dummy05" ));

		CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal5 = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_hEffectGigaCrystal[4] );
		pMeshInstCrystal5->SetPos( pMeshInstPlane->GetBonePos( L"Dummy06" ));


		CKTDGParticleSystem::CParticleEventSequence* pSeqPlane = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleGigaPlane );
		if( pSeqPlane != NULL )
		{
			CKTDXDeviceXSkinMesh::MultiAnimFrame* pMultiAnimFrame = pMeshInstPlane->GetCloneFrame( L"Dummy01" );
			pSeqPlane->SetUseDXMatrix( pMultiAnimFrame->combineMatrix );
		}


		CKTDGParticleSystem::CParticleEventSequence* pSeqCrystal1 = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleGigaCrystal[0] );
		if( pSeqCrystal1 != NULL )
		{
			pSeqCrystal1->SetPosition( pMeshInstPlane->GetBonePos( L"Dummy02" ) );
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeqCrystal2 = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleGigaCrystal[1] );
		if( pSeqCrystal2 != NULL )
		{
			pSeqCrystal2->SetPosition( pMeshInstPlane->GetBonePos( L"Dummy03" ) );
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeqCrystal3 = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleGigaCrystal[2] );
		if( pSeqCrystal3 != NULL )
		{
			pSeqCrystal3->SetPosition( pMeshInstPlane->GetBonePos( L"Dummy04" ) );
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeqCrystal4 = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleGigaCrystal[3] );
		if( pSeqCrystal4 != NULL )
		{
			pSeqCrystal4->SetPosition( pMeshInstPlane->GetBonePos( L"Dummy05" ) );
		}

		CKTDGParticleSystem::CParticleEventSequence* pSeqCrystal5 = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleGigaCrystal[4] );
		if( pSeqCrystal5 != NULL )
		{
			pSeqCrystal5->SetPosition( pMeshInstPlane->GetBonePos( L"Dummy06" ) );
		}

		if( pMeshInstPlane->EventTimerGlobal( 0.1f ) == true )
		{
			m_hParticleGigaPlane = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,  L"eve_gigaStream_prism_red_P01", pMeshInstPlane->GetBonePos( L"Dummy01" ) );
		}
		else if( pMeshInstPlane->EventTimerGlobal( 0.2f ) == true )
		{
			// Plane Loop 이펙트 생성
			m_hParticleGigaCrystal[0] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P01", pMeshInstPlane->GetBonePos( L"Dummy02" ) );
			m_hParticleGigaCrystal[1] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P01", pMeshInstPlane->GetBonePos( L"Dummy03" ) );
			m_hParticleGigaCrystal[2] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P01", pMeshInstPlane->GetBonePos( L"Dummy04" ) );
			m_hParticleGigaCrystal[3] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P01", pMeshInstPlane->GetBonePos( L"Dummy05" ) );
			m_hParticleGigaCrystal[4] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P01", pMeshInstPlane->GetBonePos( L"Dummy06" ) );
		}
		else if( pMeshInstPlane->EventTimerGlobal( pMeshInstPlane->GetMaxLifeTime() - 0.2333f ) == true )
		{
			// Plane End 이펙트 생성

			pMeshInstCrystal1->ChangeAnim( L"end", CKTDGXSkinAnim::XAP_ONE, 1.f );
			pMeshInstCrystal2->ChangeAnim( L"end", CKTDGXSkinAnim::XAP_ONE, 1.f );
			pMeshInstCrystal3->ChangeAnim( L"end", CKTDGXSkinAnim::XAP_ONE, 1.f );
			pMeshInstCrystal4->ChangeAnim( L"end", CKTDGXSkinAnim::XAP_ONE, 1.f );
			pMeshInstCrystal5->ChangeAnim( L"end", CKTDGXSkinAnim::XAP_ONE, 1.f );

			g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaCrystal[0] );
			g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaCrystal[1] );
			g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaCrystal[2] );
			g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaCrystal[3] );
			g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaCrystal[4] );
		}
		else if( pMeshInstPlane->EventTimerGlobal( pMeshInstPlane->GetMaxLifeTime() - 0.1f ) == true )
		{
			g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleGigaPlane );
		}
	}
	else
	{
#ifdef  X2OPTIMIZE_HANDLE_VALIDITY_CHECK
        m_hParticleGigaPlane = INVALID_PARTICLE_SEQUENCE_HANDLE;	/// 시간에 의해 종료됬을 것이기에 INVALID 처리함
#else   X2OPTIMIZE_HANDLE_VALIDITY_CHECK
		m_hParticleGigaPlane = INVALID_MESH_INSTANCE_HANDLE;	/// 시간에 의해 종료됬을 것이기에 INVALID 처리함
#endif  X2OPTIMIZE_HANDLE_VALIDITY_CHECK
		DestroyGigaPlaneAndCrystalEffect();
		SetEnableGigaPlane( false );
	}

}


void CX2GUEve::EveElectraSystem::SetPlaneFormation( PlaneFormationType _ePlaneFormationType )
{
	m_ePlaneFormationType = _ePlaneFormationType;
	return;
}

void CX2GUEve::EveElectraSystem::ChangePlaneFormation()
{
	switch( m_ePlaneFormationType )
	{
	case PFT_AMPLIFIER:
		SetPlaneFormation( PFT_SPECTRUM );
		break;

	case PFT_SPECTRUM:
		{
#ifdef SERV_EVE_BATTLE_SERAPH		/// 초광학 연구
			if ( GetEnableHyperOpticalResearch() )
				SetPlaneFormation( PFT_INDUCTION );
			else
#endif //SERV_EVE_BATTLE_SERAPH
				SetPlaneFormation( PFT_AMPLIFIER );
		} break;

	case PFT_INDUCTION:
		SetPlaneFormation( PFT_AMPLIFIER );
		break;

	default:
		break;
	}
}

void CX2GUEve::EveElectraSystem::StartFormationEffect()
{
	m_fFormationSetElapsedTime = 0.f;

	DestroyFormationMarkAndMsgParticle();

	switch( m_ePlaneFormationType )
	{
	case PFT_AMPLIFIER:
		{
			m_hParticleFormationMark[0] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,
				L"eve_spectro_MsgMark_red_01", m_pGUEve->GetBonePos( L"Bip01" ) );
			m_hParticleFormationMark[1] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,
				L"eve_spectro_MsgMark_red_02", m_pGUEve->GetBonePos( L"Bip01" ) );
			m_hParticleFormationMark[2] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,
				L"eve_spectro_MsgMark_red_03", m_pGUEve->GetBonePos( L"Bip01" ) );
		} break;
	case PFT_SPECTRUM:
		{
			m_hParticleFormationMark[0] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,
				L"eve_spectro_MsgMark_Blue_01", m_pGUEve->GetBonePos( L"Bip01" ) );
			m_hParticleFormationMark[1] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,
				L"eve_spectro_MsgMark_Blue_02", m_pGUEve->GetBonePos( L"Bip01" ) );
			m_hParticleFormationMark[2] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,
				L"eve_spectro_MsgMark_Blue_03", m_pGUEve->GetBonePos( L"Bip01" ) );
		} break;
#ifdef SERV_EVE_BATTLE_SERAPH
	case PFT_INDUCTION:
		{
			m_hParticleFormationMark[0] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,
				L"eve_spectro_MsgMark_Green_01", m_pGUEve->GetBonePos( L"Bip01" ) );
			m_hParticleFormationMark[1] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,
				L"eve_spectro_MsgMark_Green_02", m_pGUEve->GetBonePos( L"Bip01" ) );
			m_hParticleFormationMark[2] = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,
				L"eve_spectro_MsgMark_Green_03", m_pGUEve->GetBonePos( L"Bip01" ) );
		} break;
#endif
	}
}

void CX2GUEve::EveElectraSystem::ProcessFormation( float _fElapsedTime )
{
	if ( GetEnableSystem() )
	{
		float fElapsedTimeBefore = m_fFormationSetElapsedTime;
		m_fFormationSetElapsedTime += _fElapsedTime;	

		for( UINT i = 0; i < 3; ++i )
		{
			CKTDGParticleSystem::CParticleEventSequence* pSeqFormationMark = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleFormationMark[i] );
			if( pSeqFormationMark != NULL )
			{
				pSeqFormationMark->SetPosition(  m_pGUEve->GetBonePos( L"Bip01" ) );
			}
		}

		for( UINT i = 0; i < 3; ++i )
		{
			CKTDGParticleSystem::CParticleEventSequence* pSeqFormationMsg = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hParticleFormationMsg[i] );
			if( pSeqFormationMsg != NULL )
			{
				pSeqFormationMsg->SetPosition(  m_pGUEve->GetBonePos( L"Bip01" ), true, true );
			}
		}


		if( fElapsedTimeBefore <= 0.0f && m_fFormationSetElapsedTime > 0.0f )
		{
			if( m_ePlaneFormationType == PFT_AMPLIFIER )
			{
				CKTDGParticleSystem::CParticleEventSequence* pSeqFormationMsg = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_Msg_red_01", m_pGUEve->GetBonePos( L"Bip01" ) );
				if( pSeqFormationMsg != NULL )
				{
					pSeqFormationMsg->SetAxisAngle( m_pGUEve->GetRotateDegree() );
					pSeqFormationMsg->SetAddRotate( m_pGUEve->GetRotateDegree() );
					m_hParticleFormationMsg[0] = pSeqFormationMsg->GetHandle();
				}
			}
			else if( m_ePlaneFormationType == PFT_SPECTRUM )
			{
				CKTDGParticleSystem::CParticleEventSequence* pSeqFormationMsg = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_Msg_Blue_01", m_pGUEve->GetBonePos( L"Bip01" ) );
				if( pSeqFormationMsg != NULL )
				{
					pSeqFormationMsg->SetAxisAngle( m_pGUEve->GetRotateDegree() );
					pSeqFormationMsg->SetAddRotate( m_pGUEve->GetRotateDegree() );
					m_hParticleFormationMsg[0] = pSeqFormationMsg->GetHandle();
				}
			}
#ifdef SERV_EVE_BATTLE_SERAPH
			else if( m_ePlaneFormationType == PFT_INDUCTION )
			{
				CKTDGParticleSystem::CParticleEventSequence* pSeqFormationMsg = g_pX2Game->GetMajorParticle()->CreateSequence(
					(CKTDGObject*) m_pGUEve, L"eve_spectro_Msg_Green_01", m_pGUEve->GetBonePos( L"Bip01" ) );

				if( pSeqFormationMsg != NULL )
				{
					pSeqFormationMsg->SetAxisAngle( m_pGUEve->GetRotateDegree() );
					pSeqFormationMsg->SetAddRotate( m_pGUEve->GetRotateDegree() );
					m_hParticleFormationMsg[0] = pSeqFormationMsg->GetHandle();
				}
			}
#endif
		}
		else if( fElapsedTimeBefore <= 0.8f && m_fFormationSetElapsedTime > 0.8f )
		{
			if( m_ePlaneFormationType == PFT_AMPLIFIER )
			{
				CKTDGParticleSystem::CParticleEventSequence* pSeqFormationMsg = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_Msg_red_02", m_pGUEve->GetBonePos( L"Bip01" ) );
				if( pSeqFormationMsg != NULL )
				{
					pSeqFormationMsg->SetAxisAngle( m_pGUEve->GetRotateDegree() );
					pSeqFormationMsg->SetAddRotate( m_pGUEve->GetRotateDegree() );
					m_hParticleFormationMsg[1] = pSeqFormationMsg->GetHandle();
				}
			}
			else if( m_ePlaneFormationType == PFT_SPECTRUM )
			{
				CKTDGParticleSystem::CParticleEventSequence* pSeqFormationMsg = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_Msg_Blue_02", m_pGUEve->GetBonePos( L"Bip01" ) );
				if( pSeqFormationMsg != NULL )
				{
					pSeqFormationMsg->SetAxisAngle( m_pGUEve->GetRotateDegree() );
					pSeqFormationMsg->SetAddRotate( m_pGUEve->GetRotateDegree() );
					m_hParticleFormationMsg[1] = pSeqFormationMsg->GetHandle();
				}
			}
#ifdef SERV_EVE_BATTLE_SERAPH
			else if( m_ePlaneFormationType == PFT_INDUCTION )
			{
				CKTDGParticleSystem::CParticleEventSequence* pSeqFormationMsg = g_pX2Game->GetMajorParticle()->CreateSequence(
					(CKTDGObject*) m_pGUEve,  L"eve_spectro_Msg_Green_02", m_pGUEve->GetBonePos( L"Bip01" ) );

				if( pSeqFormationMsg != NULL )
				{
					pSeqFormationMsg->SetAxisAngle( m_pGUEve->GetRotateDegree() );
					pSeqFormationMsg->SetAddRotate( m_pGUEve->GetRotateDegree() );
					m_hParticleFormationMsg[1] = pSeqFormationMsg->GetHandle();
				}
			}
#endif
		}
		else if( fElapsedTimeBefore <= 1.6f && m_fFormationSetElapsedTime > 1.6f )
		{
			if( m_ePlaneFormationType == PFT_AMPLIFIER )
			{
				CKTDGParticleSystem::CParticleEventSequence* pSeqFormationMsg = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_Msg_red_03", m_pGUEve->GetBonePos( L"Bip01" ) );
				if( pSeqFormationMsg != NULL )
				{
					pSeqFormationMsg->SetAxisAngle( m_pGUEve->GetRotateDegree() );
					pSeqFormationMsg->SetAddRotate( m_pGUEve->GetRotateDegree() );
					m_hParticleFormationMsg[2] = pSeqFormationMsg->GetHandle();
				}
			}
			else if( m_ePlaneFormationType == PFT_SPECTRUM )
			{
				CKTDGParticleSystem::CParticleEventSequence* pSeqFormationMsg = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_Msg_Blue_03", m_pGUEve->GetBonePos( L"Bip01" ) );
				if( pSeqFormationMsg != NULL )
				{
					pSeqFormationMsg->SetAxisAngle( m_pGUEve->GetRotateDegree() );
					pSeqFormationMsg->SetAddRotate( m_pGUEve->GetRotateDegree() );
					m_hParticleFormationMsg[2] = pSeqFormationMsg->GetHandle();
				}
			}
#ifdef SERV_EVE_BATTLE_SERAPH
			else if( m_ePlaneFormationType == PFT_INDUCTION )
			{
				CKTDGParticleSystem::CParticleEventSequence* pSeqFormationMsg = g_pX2Game->GetMajorParticle()->CreateSequence(
					(CKTDGObject*) m_pGUEve,  L"eve_spectro_Msg_Green_03", m_pGUEve->GetBonePos( L"Bip01" ) );

				if( pSeqFormationMsg != NULL )
				{
					pSeqFormationMsg->SetAxisAngle( m_pGUEve->GetRotateDegree() );
					pSeqFormationMsg->SetAddRotate( m_pGUEve->GetRotateDegree() );
					m_hParticleFormationMsg[2] = pSeqFormationMsg->GetHandle();
				}
			}
#endif
		}
	}
}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
void CX2GUEve::EveElectraSystem::ProcessSystem( float fElapsedTime )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
void CX2GUEve::EveElectraSystem::ProcessSystem()
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
{
	//#ifdef SERV_EVE_BATTLE_SERAPH
	//			if ( false == m_bExceptionSystem )
	//				m_bSystemEnable = false;
	//#else
	//			m_bSystemEnable			= false;
	//#endif
	//#ifdef SERV_EVE_BATTLE_SERAPH
	//				if ( true == GetEnableHyperOpticalResearch() )
	//					const_cast<CX2SkillTree::SkillTemplet*>(pSkillTemplet)->m_eActiveSkillUseCondtion = CX2SkillTree::ASUT_GROUND;
	//#endif
	//#ifdef SERV_EVE_BATTLE_SERAPH
	//			if( false == m_bExceptionSystem && 
	//				m_pGUEve->m_pThousandStar != NULL && m_pGUEve->m_pThousandStar->m_pEffect != NULL 
	//				&& true == g_pX2Game->GetDamageEffect()->IsLiveInstance( m_pGUEve->m_pThousandStar->m_pEffect ) )
	//#else
	//			if( m_pGUEve->m_pThousandStar != NULL && m_pGUEve->m_pThousandStar->m_pEffect != NULL && true == g_pX2Game->GetDamageEffect()->IsLiveInstance( m_pGUEve->m_pThousandStar->m_pEffect ) )
	//#endif
	//			{
	//				g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleThousandStarFormation );
	//				m_hParticleThousandStarFormation = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve,  L"eve_thousandsOfStars_model_P01", m_pGUEve->m_pThousandStar->m_pEffect->GetPos() );
	//			}

	/*
	#ifdef SERV_EVE_BATTLE_SERAPH
	if ( m_fExceptionSystemRemainTime > 0 )
	{
	m_fExceptionSystemRemainTime -= _fElapsedTime;

	if ( m_fExceptionSystemRemainTime < 0 )
	{
	m_fExceptionSystemRemainTime = 0.f;
	m_bExceptionSystem = false;

	if ( true == IsSamef( m_fSystemRemainTime ) )
	m_bSystemEnable = false;

	m_pGUEve->m_iAddBoostAttack = 0;

	if ( INVALID_EFFECTSET_HANDLE != m_pGUEve->m_hEffectEnergeticHeart  )
	{
	g_pX2Game->GetEffectSet()->StopEffectSet( m_pGUEve->m_hEffectEnergeticHeart );
	g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Seraph_Energetic_Heart_End", m_pGUEve );
	}

	if ( false == m_pGUEve->m_FrameDataNow.stateParam.bAttackState )
	{
	SetPlaneFormation( m_ePrevSpectro );
	g_pX2Game->UpdateSkillSlotUI();
	}

	if( m_pGUEve->m_pThousandStar != NULL && m_pGUEve->m_pThousandStar->m_pEffect != NULL
	&& true == g_pX2Game->GetDamageEffect()->IsLiveInstance( m_pGUEve->m_pThousandStar->m_pEffect ) )
	{
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hParticleThousandStarFormation );
	m_hParticleThousandStarFormation = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) m_pGUEve, 
	L"eve_thousandsOfStars_model_P01", m_pGUEve->m_pThousandStar->m_pEffect->GetPos() );
	}
	}
	}
	else
	{
	if ( PFT_FUSION == GetPlaneFormation() && false == m_pGUEve->m_FrameDataNow.stateParam.bAttackState )
	{
	SetPlaneFormation( m_ePrevSpectro );
	g_pX2Game->UpdateSkillSlotUI();
	}
	}
	#endif
	*/

#ifndef X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	const float fElapsedTime = g_pKTDXApp->GetElapsedTime();
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	ProcessPlane( fElapsedTime );

	ProcessGigaPlane( fElapsedTime );

	ProcessFormation( fElapsedTime );

	if ( !m_EveElectraLaserDataList.empty() )
	{
		std::list< EveElectraLaserData >::iterator lit_Laser;
		for( lit_Laser = m_EveElectraLaserDataList.begin(); lit_Laser != m_EveElectraLaserDataList.end(); )
		{
			EveElectraLaserData& kEveElectraLaserData = *lit_Laser;

			if( kEveElectraLaserData.m_TraceBone != L"" )
				kEveElectraLaserData.m_vLaserStartPos = m_pGUEve->GetBonePos( kEveElectraLaserData.m_TraceBone.c_str() );

			kEveElectraLaserData.OnFrameMove( fElapsedTime );
			if( kEveElectraLaserData.m_bDie == true )
				lit_Laser = m_EveElectraLaserDataList.erase( lit_Laser );
			else
				++lit_Laser;
		}
	}

	if ( !m_EveElectraEffectDataList.empty() )
	{
		std::list< EveElectraEffectData >::iterator lit_Effect;
		for( lit_Effect = m_EveElectraEffectDataList.begin(); lit_Effect != m_EveElectraEffectDataList.end(); )
		{
			EveElectraEffectData& kEveElectraEffectData = *lit_Effect;
			kEveElectraEffectData.OnFrameMove( fElapsedTime );
			if( kEveElectraEffectData.m_bDie == true )
				lit_Effect = m_EveElectraEffectDataList.erase( lit_Effect );
			else
				++lit_Effect;
		}
	}

	if ( !m_EveElectraLockonDataList.empty() )
	{
		std::list< EveElectraLockonData >::iterator lit_Lockon;
		for( lit_Lockon = m_EveElectraLockonDataList.begin(); lit_Lockon != m_EveElectraLockonDataList.end(); )
		{
			EveElectraLockonData& kEveElectraLockonData = *lit_Lockon;
			kEveElectraLockonData.OnFrameMove( fElapsedTime );
			if( kEveElectraLockonData.m_bDie == true )
				lit_Lockon = m_EveElectraLockonDataList.erase( lit_Lockon );
			else
				++lit_Lockon;
		}
	}

}

#ifdef SERV_EVE_BATTLE_SERAPH
void CX2GUEve::EveElectraSystem::AddLaserToSystem( CX2DamageEffect::CEffect* _pDamageEffect,
	wstring _TraceBone, D3DXVECTOR3& _vLaserStartPos, D3DXVECTOR3&_vDirVector,	float _fVelocity,
	float _fLaserPropagateTime /*= 0.3f*/, float _fLaserWidthScale /*= 1.f*/, 
	wstring AmplifyDamageEffectName /*= L""*/, wstring SpectrumDamageEffectName /*= L""*/, wstring InductionDamageEffectName /*= L""*/,
	bool _bApplyLaserRangePassive /*= true*/,  float _fRadiusScale /*= 1.f*/ )
#else
void CX2GUEve::EveElectraSystem::AddLaserToSystem( CX2DamageEffect::CEffect* _pDamageEffect, 
	wstring _TraceBone, D3DXVECTOR3& _vLaserStartPos, D3DXVECTOR3& _vDirVector, float _fVelocity, 
	float _fLaserPropagateTime /*= 0.3f */, float _fLaserWidthScale /*= 1.f */, 
	wstring AmplifyDamageEffectName /*= L""*/, wstring SpectrumDamageEffectName /*= L""*/, bool _bApplyLaserRangePassive /*= true */, float _fRadiusScale /* = 1.f*/ )
#endif
{
	if( _pDamageEffect == NULL )
		return;

	EveElectraLaserData kEveElectraLaserData( this );
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    kEveElectraLaserData.m_vecDamageEffect.push_back(_pDamageEffect->GetHandle());
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	kEveElectraLaserData.m_vecDamageEffect.push_back(_pDamageEffect);
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	kEveElectraLaserData.m_vLaserStartPos	= _vLaserStartPos;

	kEveElectraLaserData.m_vDirVector		= _vDirVector;
	kEveElectraLaserData.m_fVelocity		= _fVelocity;
	kEveElectraLaserData.m_fLaserPropagateTime	= _fLaserPropagateTime;
	kEveElectraLaserData.m_TraceBone		= _TraceBone;
	kEveElectraLaserData.m_fElapsedTime		= 0.f;
	kEveElectraLaserData.m_fPenetrateTime	= 0.0f;
	kEveElectraLaserData.m_fLaserWidthScale = _fLaserWidthScale;
	kEveElectraLaserData.m_bApplyLaserRangePassive = _bApplyLaserRangePassive;

    
    CKTDGXMeshPlayer::CXMeshInstance* pMainEffect = _pDamageEffect->GetMainEffect();
	kEveElectraLaserData.m_vInitRotateLocalDegree = ( pMainEffect != NULL ) ? pMainEffect->GetRotateLocalDegree() : D3DXVECTOR3(0,0,0);


	kEveElectraLaserData.m_AmplifyDamageEffectName	= AmplifyDamageEffectName;
	kEveElectraLaserData.m_SpectrumDamageEffectName = SpectrumDamageEffectName;
#ifdef SERV_EVE_BATTLE_SERAPH
	kEveElectraLaserData.m_InductionDamageEffectName = InductionDamageEffectName;
	kEveElectraLaserData.m_iFireCount = 0;
#endif

	if( AmplifyDamageEffectName == L"" )
		kEveElectraLaserData.m_AmplifyDamageEffectName = L"EVE_PROTO_PURITY_LASER";

	if( SpectrumDamageEffectName == L"" )
		kEveElectraLaserData.m_SpectrumDamageEffectName = L"EVE_PROTO_PURITY_LASER";

#ifdef SERV_EVE_BATTLE_SERAPH
	if( InductionDamageEffectName == L"" )
		kEveElectraLaserData.m_InductionDamageEffectName = L"EVE_PROTO_PURITY_LASER";
#endif

	m_EveElectraLaserDataList.push_back( kEveElectraLaserData );

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	_pDamageEffect->SetLaserGroupID( m_iLaserGroupNum );
	++m_iLaserGroupNum;
	if ( m_iLaserGroupNum > 2 )
		m_iLaserGroupNum = 1;
#else //UPGRADE_SKILL_SYSTEM_2013
	_pDamageEffect->SetLaserGroupID( 1 );
#endif //UPGRADE_SKILL_SYSTEM_2013

	LaserAttackLineSet( _pDamageEffect, _fRadiusScale );
	_pDamageEffect = NULL;
	return;
}

void CX2GUEve::EveElectraSystem::LaserAttackLineSet( CX2DamageEffect::CEffect* _pDamageEffect, float _fRadiusScale /*= 1.0f*/ )
{
	if( _pDamageEffect == NULL )
		return;
    CKTDGXMeshPlayer::CXMeshInstance* pMainEffect = _pDamageEffect->GetMainEffect();
    if ( pMainEffect == NULL || pMainEffect->GetXSkinAnim() == NULL )
        return;
	CKTDXCollision::CollisionDataList* pCollisionDataList = &pMainEffect->GetXSkinAnim()->GetAttackDataListNonConst();
    if ( pCollisionDataList == NULL )
        return;

	BOOST_TEST_FOREACH( CKTDXCollision::CollisionData*, pColA, *pCollisionDataList )
	{
		ASSERT( pColA != NULL );
		if( pColA->m_bEnable == false )
			continue;

		if( pColA->m_CollisionType == CKTDXCollision::CT_LINE )
		{
			pColA->m_bUseRadiusScaleY = true;
			pColA->m_fRadiusScale = _fRadiusScale;
		}
	}
	return;
}

void CX2GUEve::EveElectraSystem::DeleteLaserFromSystem()
{

	std::list< EveElectraLaserData >::iterator lit_Laser;
	for( lit_Laser = m_EveElectraLaserDataList.begin(); lit_Laser != m_EveElectraLaserDataList.end(); )
	{
		EveElectraLaserData& kEveElectraLaserData = *lit_Laser;
		kEveElectraLaserData.Delete();
		lit_Laser = m_EveElectraLaserDataList.erase( lit_Laser );

	}
	return;
}


#ifdef SERV_EVE_BATTLE_SERAPH
void CX2GUEve::EveElectraSystem::AddEffectToSystem( CX2DamageEffect::CEffect* _pDamageEffect, wstring AmplifyDamageEffectName /*= L""*/,
	wstring SpectrumDamageEffectName /*= L""*/, wstring InductionDamageEffectName /*= L""*/,
	wstring FusionDamageEffectName /*= L""*/ )
#else
void CX2GUEve::EveElectraSystem::AddEffectToSystem( CX2DamageEffect::CEffect* _pDamageEffect, 
	wstring AmplifyDamageEffectName /*= L""*/, wstring SpectrumDamageEffectName /*= L""*/ )
#endif
{
	if( GetEnablePlane() == false )
		return;

	if( _pDamageEffect == NULL )
		return;

	EveElectraEffectData kEveElectraEffectData( this );
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    kEveElectraEffectData.m_hDamageEffect =  _pDamageEffect->GetHandle();
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	kEveElectraEffectData.m_pDamageEffect =  _pDamageEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

	if( AmplifyDamageEffectName == L"" )
		kEveElectraEffectData.m_AmplifyDamageEffectName = _pDamageEffect->GetName();
	else
		kEveElectraEffectData.m_AmplifyDamageEffectName = AmplifyDamageEffectName;

	if( SpectrumDamageEffectName == L"" )
		kEveElectraEffectData.m_SpectrumDamageEffectName = _pDamageEffect->GetName();
	else
		kEveElectraEffectData.m_SpectrumDamageEffectName = SpectrumDamageEffectName;

#ifdef SERV_EVE_BATTLE_SERAPH
	if( InductionDamageEffectName == L"" )
		kEveElectraEffectData.m_InductionDamageEffectName = _pDamageEffect->GetName();
	else
		kEveElectraEffectData.m_InductionDamageEffectName = InductionDamageEffectName;

	if( FusionDamageEffectName == L"" )
		kEveElectraEffectData.m_FusionDamageEffectName = _pDamageEffect->GetName();
	else
		kEveElectraEffectData.m_FusionDamageEffectName = FusionDamageEffectName;
#endif

	m_EveElectraEffectDataList.push_back( kEveElectraEffectData );

	_pDamageEffect = NULL;
	return;
}

#ifdef SERV_EVE_BATTLE_SERAPH
void CX2GUEve::EveElectraSystem::AddLockonToSystem( CX2DamageEffect::CEffect* _pDamageEffect, wstring AmplifyDamageEffectName /*= L""*/,
	wstring SpectrumDamageEffectName /*= L""*/, wstring InductionDamageEffectName /*= L""*/ )
#else
void CX2GUEve::EveElectraSystem::AddLockonToSystem( CX2DamageEffect::CEffect* _pDamageEffect,
	wstring AmplifyDamageEffectName /*= L""*/, wstring SpectrumDamageEffectName /*= L""*/  )
#endif
{
	if( GetEnablePlane() == false )
		return;

	if( _pDamageEffect == NULL )
		return;

	EveElectraLockonData kEveElectraLockonData( this );
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    kEveElectraLockonData.m_hDamageEffect =  _pDamageEffect->GetHandle();
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	kEveElectraLockonData.m_pDamageEffect =  _pDamageEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

	if( AmplifyDamageEffectName == L"" )
		kEveElectraLockonData.m_AmplifyDamageEffectName = _pDamageEffect->GetName();
	else
		kEveElectraLockonData.m_AmplifyDamageEffectName = AmplifyDamageEffectName;

	if( SpectrumDamageEffectName == L"" )
		kEveElectraLockonData.m_SpectrumDamageEffectName = _pDamageEffect->GetName();
	else
		kEveElectraLockonData.m_SpectrumDamageEffectName = SpectrumDamageEffectName;

#ifdef SERV_EVE_BATTLE_SERAPH
	if( InductionDamageEffectName == L"" )
		kEveElectraLockonData.m_InductionDamageEffectName = _pDamageEffect->GetName();
	else
		kEveElectraLockonData.m_InductionDamageEffectName = SpectrumDamageEffectName;
#endif

	m_EveElectraLockonDataList.push_back( kEveElectraLockonData );

	_pDamageEffect = NULL;
	return;
}

void CX2GUEve::ShowActiveSkillCutInAndLight( const WCHAR* szBoneName_, const float fTimeToShow_, const UINT uiCutInIndex_, const bool bOnlyLight_ /*= false */ )
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( fTimeToShow_ ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( fTimeToShow_ ) == true && EventCheck( fTimeToShow_, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if ( GetShowCutInAndChangeWorldColor() && GetShowActiveSkillShow() )
#ifdef SERV_APRIL_FOOLS_DAY
			( true == m_bIsFoolsDay )?
			ActiveSkillShow( szBoneName_, s_SkillCutInSetFoolsDay.fileName.c_str(), s_SkillCutInSetFoolsDay.vSize, s_SkillCutInSetFoolsDay.vPosition, IsHyperState(), bOnlyLight_ ) :
#endif //APRIL_FOOLS_DAY
			ActiveSkillShow( szBoneName_, s_SkillCutInSet[m_iSkillCutInSetIndex].cutIn[uiCutInIndex_].fileName.c_str(), s_SkillCutInSet[m_iSkillCutInSetIndex].cutIn[uiCutInIndex_].vSize, s_SkillCutInSet[m_iSkillCutInSetIndex].cutIn[uiCutInIndex_].vPosition, IsHyperState(), bOnlyLight_ );
	}
}

void CX2GUEve::EveElectraSystem::CreatePlane( float _fZAngle/* = 0.f*/, float _LifeTime/* = 2.f*/, float _fDistance/* = 300.f*/, float _fHeight/* = 130.f*/, wstring PlaneMeshName /*= L""*/ )
{
	if( GetEnableSystem() == false )
		return;

	_fDistance *= m_pGUEve->GetScaleByUnit().x;
	_fHeight *= m_pGUEve->GetScaleByUnit().y;


	D3DXVECTOR3 vPlanePos = m_pGUEve->GetPos();
	vPlanePos.y += _fHeight;
	D3DXVECTOR3 vZeroYDirVector = m_pGUEve->GetDirVector();
	vZeroYDirVector.y = 0.f;
	D3DXVec3Normalize( &vZeroYDirVector, &vZeroYDirVector );

	if(m_pGUEve->GetIsRight() == false)
	{
		vZeroYDirVector.x = -vZeroYDirVector.x;
		vZeroYDirVector.z = -vZeroYDirVector.z;
	}

	vPlanePos += (_fDistance * vZeroYDirVector);
	m_vPlanePoint	= vPlanePos;

	///{{

	D3DXVECTOR3 vRotationAxis;
	D3DXVec3Cross( &vRotationAxis, &vZeroYDirVector, &Y_AXIS );
	D3DXVec3Normalize( &vRotationAxis, &vRotationAxis );


	D3DXMATRIX matRotationCenter;
#ifdef SERV_EVE_BATTLE_SERAPH
	D3DXMatrixRotationAxis( &matRotationCenter, &vRotationAxis, _fZAngle );
#else
	D3DXMatrixRotationAxis( &matRotationCenter, &vRotationAxis, 0.f );
#endif
	D3DXVECTOR4 v4PlaneNormalCenter;
	D3DXVec3Transform( &v4PlaneNormalCenter, &vZeroYDirVector, &matRotationCenter );
	D3DXVECTOR3 vPlaneNormalCenter = v4PlaneNormalCenter;
	m_vPlaneNormalCenter = vPlaneNormalCenter;

	D3DXMATRIX matRotationUpper;
#ifdef SERV_EVE_BATTLE_SERAPH
	D3DXMatrixRotationAxis( &matRotationUpper, &vRotationAxis, D3DXToRadian( _fZAngle ) );
#else
	D3DXMatrixRotationAxis( &matRotationUpper, &vRotationAxis, D3DXToRadian(24.f) );
#endif
	D3DXVECTOR4 v4PlaneNormalUpper;
	D3DXVec3Transform( &v4PlaneNormalUpper, &vZeroYDirVector, &matRotationUpper );
	D3DXVECTOR3 vPlaneNormalUpper= v4PlaneNormalUpper;
	m_vPlaneNormalUpper = vPlaneNormalUpper;

	D3DXMATRIX matRotationLower;
#ifdef SERV_EVE_BATTLE_SERAPH
	D3DXMatrixRotationAxis( &matRotationLower, &vRotationAxis,  D3DXToRadian( _fZAngle ) );
#else
	D3DXMatrixRotationAxis( &matRotationLower, &vRotationAxis,  D3DXToRadian(-24.f) );
#endif
	D3DXVECTOR4 v4PlaneNormalLower;
	D3DXVec3Transform( &v4PlaneNormalLower, &vZeroYDirVector, &matRotationLower );
	D3DXVECTOR3 vPlaneNormalLower= v4PlaneNormalLower;
	m_vPlaneNormalLower = vPlaneNormalLower;


	D3DXPlaneFromPointNormal( &m_PlaneCenter, &m_vPlanePoint, &m_vPlaneNormalCenter );
	D3DXPlaneFromPointNormal( &m_PlaneUpper, &m_vPlanePoint, &m_vPlaneNormalUpper );
	D3DXPlaneFromPointNormal( &m_PlaneLower, &m_vPlanePoint, &m_vPlaneNormalLower );

	m_fPlaneZAngle	= _fZAngle;
	if( m_fPlaneZAngle > 0 )
	{
		m_vPlaneNormal	= m_vPlaneNormalUpper;
		m_PrimaryPlane  = m_PlaneUpper;
	}
	else if( m_fPlaneZAngle < 0 )
	{
		m_vPlaneNormal	= m_vPlaneNormalLower;
		m_PrimaryPlane  = m_PlaneLower;
	}
	else
	{
		m_vPlaneNormal	= m_vPlaneNormalCenter;
		m_PrimaryPlane  = m_PlaneCenter;
	}


	D3DXVECTOR3 vPlaneRotateDegree = m_pGUEve->GetRotateDegree();

	///{{
	m_vPlaneRotateDegreeCenter			= vPlaneRotateDegree;
	m_vPlaneRotateDegreeUpper			= vPlaneRotateDegree;
	m_vPlaneRotateDegreeUpper.z			+= 24.f;
	m_vPlaneRotateDegreeLower			= vPlaneRotateDegree;
	m_vPlaneRotateDegreeLower.z			-= 24.f;
	///}}

	vPlaneRotateDegree.z += _fZAngle;

	DestroyPlaneAndCrystalEffect();

	CKTDGXMeshPlayer* pMajorMeshPlayer = g_pX2Game->GetMajorXMeshPlayer();
	CKTDGXMeshPlayer::CXMeshInstance* pMeshInstPlane = pMajorMeshPlayer->CreateInstance( (CKTDGObject*) m_pGUEve,  L"EveProtoPurityPlane", vPlanePos, vPlaneRotateDegree, vPlaneRotateDegree );
    if ( pMeshInstPlane != NULL )
    {
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_SIMULATION
        pMeshInstPlane->SetPerFrameSimulation( true );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_SIMULATION
	    m_hEffectPlane = pMeshInstPlane->GetHandle();
	    pMeshInstPlane->SetMaxLifeTime( _LifeTime );
    }
	SetEnablePlane( true );

	CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal1 = pMajorMeshPlayer->CreateInstance( (CKTDGObject*) m_pGUEve,  L"EveProtoPurityCrystal", vPlanePos, m_pGUEve->GetRotateDegree(), m_pGUEve->GetRotateDegree() );
    if ( pMeshInstCrystal1 != NULL )
    {
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_SIMULATION
        pMeshInstCrystal1->SetPerFrameSimulation( true );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_SIMULATION
	    m_hEffectCrystal1 = pMeshInstCrystal1->GetHandle();
	    pMeshInstCrystal1->SetPos( pMeshInstPlane->GetBonePos( L"Dummy02" ));
    }

	CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal2 = pMajorMeshPlayer->CreateInstance( (CKTDGObject*) m_pGUEve,  L"EveProtoPurityCrystal", vPlanePos, m_pGUEve->GetRotateDegree(), m_pGUEve->GetRotateDegree() );
    if ( pMeshInstCrystal2 != NULL )
    {
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_SIMULATION
        pMeshInstCrystal2->SetPerFrameSimulation( true );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_SIMULATION
	    m_hEffectCrystal2 = pMeshInstCrystal2->GetHandle();
	    pMeshInstCrystal2->SetPos( pMeshInstPlane->GetBonePos( L"Dummy03" ));
    }


	CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal3 = pMajorMeshPlayer->CreateInstance( (CKTDGObject*) m_pGUEve,  L"EveProtoPurityCrystal", vPlanePos, m_pGUEve->GetRotateDegree(), m_pGUEve->GetRotateDegree() );
    if ( pMeshInstCrystal3 != NULL )
    {
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_SIMULATION
        pMeshInstCrystal3->SetPerFrameSimulation( true );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_SIMULATION
	    m_hEffectCrystal3 = pMeshInstCrystal3->GetHandle();
	    pMeshInstCrystal3->SetPos( pMeshInstPlane->GetBonePos( L"Dummy04" ));
    }


	// Plane Start 이펙트 생성
	CKTDGParticleSystem* pMajorParticleSystem = g_pX2Game->GetMajorParticle();
	if ( pMajorParticleSystem != NULL && pMeshInstPlane != NULL )
	{
		pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P02", pMeshInstPlane->GetBonePos( L"Dummy02" ) );
		pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P03", pMeshInstPlane->GetBonePos( L"Dummy02" ) );
		pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P02", pMeshInstPlane->GetBonePos( L"Dummy03" ) );
		pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P03", pMeshInstPlane->GetBonePos( L"Dummy03" ) );
		pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P02", pMeshInstPlane->GetBonePos( L"Dummy04" ) );
		pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P03", pMeshInstPlane->GetBonePos( L"Dummy04" ) );
	}

	return;
}


// 궁극기 사용 시, 역장 크기를 늘릴 수 있도록 _fScale 전달인자 추가, 김종훈
void CX2GUEve::EveElectraSystem::CreateGigaPlane( float _fZAngle/* = 0.f*/, float _LifeTime/* = 2.f*/, float _fDistance/* = 300.f*/, float _fHeight/* = 130.f*/, float _fScale /* = 1.0f */ )
{

	_fDistance *= m_pGUEve->GetScaleByUnit().x;
	_fHeight *= m_pGUEve->GetScaleByUnit().y;

	D3DXVECTOR3 vPlanePos = m_pGUEve->GetPos();
	vPlanePos.y += _fHeight;
	D3DXVECTOR3 vZeroYDirVector = m_pGUEve->GetDirVector();
	vZeroYDirVector.y = 0.f;
	D3DXVec3Normalize( &vZeroYDirVector, &vZeroYDirVector );

	if(m_pGUEve->GetIsRight() == false)
	{
		vZeroYDirVector.x = -vZeroYDirVector.x;
		vZeroYDirVector.z = -vZeroYDirVector.z;
	}

	D3DXVECTOR3 vRotateDegree = D3DXVECTOR3( 0.f, 0.f, 0.f );
	vRotateDegree.z = _fZAngle;

	D3DXVECTOR3 vRotationAxis;
	D3DXVec3Cross( &vRotationAxis, &vZeroYDirVector, &Y_AXIS );
	D3DXVec3Normalize( &vRotationAxis, &vRotationAxis );
	D3DXMATRIX matRotation;
	D3DXMatrixRotationAxis( &matRotation, &vRotationAxis, D3DX_PI / 180.f * vRotateDegree.z );
	D3DXVECTOR4 v4PlaneNormal;
	D3DXVec3Transform( &v4PlaneNormal, &vZeroYDirVector, &matRotation );


	D3DXVECTOR3 vPlaneNormal = v4PlaneNormal;

	vPlanePos += (_fDistance * vZeroYDirVector);

	m_vGigaPlanePoint	= vPlanePos;
	m_vGigaPlaneNormal	= vPlaneNormal;
	m_fGigaPlaneZAngle	= _fZAngle;

	D3DXPlaneFromPointNormal( &m_GigaStreamPlane, &m_vGigaPlanePoint, &m_vGigaPlaneNormal );

	D3DXVECTOR3 vPlaneRotateDegree = m_pGUEve->GetRotateDegree();
	vPlaneRotateDegree.z += _fZAngle;

	DestroyGigaPlaneAndCrystalEffect();

	CKTDGXMeshPlayer* pMajorMeshPlayer = g_pX2Game->GetMajorXMeshPlayer();
	CKTDGXMeshPlayer::CXMeshInstance* pMeshInstPlane = pMajorMeshPlayer->CreateInstance( (CKTDGObject*) m_pGUEve,  L"EveProtoPurityGigaPlane", vPlanePos, vPlaneRotateDegree, vPlaneRotateDegree );

	if ( NULL != pMeshInstPlane )
    {
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_SIMULATION
        pMeshInstPlane->SetPerFrameSimulation( true );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_SIMULATION
		pMeshInstPlane->SetScale ( D3DXVECTOR3 ( 1.f, _fScale, _fScale ) );
	    // X 축을 제외하고 Scale 을 키운다..
    	m_hEffectGigaPlane = pMeshInstPlane->GetHandle();
	    pMeshInstPlane->SetMaxLifeTime( _LifeTime );
    }
	SetEnableGigaPlane( true );

	CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal1 = pMajorMeshPlayer->CreateInstance( (CKTDGObject*) m_pGUEve,  L"EveProtoPurityGigaCrystal", vPlanePos, m_pGUEve->GetRotateDegree(), m_pGUEve->GetRotateDegree() );
    if ( pMeshInstCrystal1 != NULL )
    {
	m_hEffectGigaCrystal[0] = pMeshInstCrystal1->GetHandle();
	pMeshInstCrystal1->SetPos( pMeshInstPlane->GetBonePos( L"Dummy02" ));
    }

	CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal2 = pMajorMeshPlayer->CreateInstance( (CKTDGObject*) m_pGUEve,  L"EveProtoPurityGigaCrystal", vPlanePos, m_pGUEve->GetRotateDegree(), m_pGUEve->GetRotateDegree() );
    if ( pMeshInstCrystal2 != NULL )
    {
	m_hEffectGigaCrystal[1] = pMeshInstCrystal2->GetHandle();
	pMeshInstCrystal2->SetPos( pMeshInstPlane->GetBonePos( L"Dummy03" ));
    }

	CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal3 = pMajorMeshPlayer->CreateInstance( (CKTDGObject*) m_pGUEve,  L"EveProtoPurityGigaCrystal", vPlanePos, m_pGUEve->GetRotateDegree(), m_pGUEve->GetRotateDegree() );
    if ( pMeshInstCrystal3 != NULL )
    {
	m_hEffectGigaCrystal[2] = pMeshInstCrystal3->GetHandle();
	pMeshInstCrystal3->SetPos( pMeshInstPlane->GetBonePos( L"Dummy04" ));
    }

	CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal4 = pMajorMeshPlayer->CreateInstance( (CKTDGObject*) m_pGUEve,  L"EveProtoPurityGigaCrystal", vPlanePos, m_pGUEve->GetRotateDegree(), m_pGUEve->GetRotateDegree() );
    if ( pMeshInstCrystal4 != NULL )
    {
	m_hEffectGigaCrystal[3] = pMeshInstCrystal4->GetHandle();
	pMeshInstCrystal4->SetPos( pMeshInstPlane->GetBonePos( L"Dummy05" ));
    }

	CKTDGXMeshPlayer::CXMeshInstance* pMeshInstCrystal5 = pMajorMeshPlayer->CreateInstance( (CKTDGObject*) m_pGUEve,  L"EveProtoPurityGigaCrystal", vPlanePos, m_pGUEve->GetRotateDegree(), m_pGUEve->GetRotateDegree() );
    if ( pMeshInstCrystal5 != NULL )
    {
	m_hEffectGigaCrystal[4] = pMeshInstCrystal5->GetHandle();
	pMeshInstCrystal5->SetPos( pMeshInstPlane->GetBonePos( L"Dummy06" ));
    }

	// Plane Start 이펙트 생성
	CKTDGParticleSystem* pMajorParticleSystem = g_pX2Game->GetMajorParticle();
	pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P02", pMeshInstPlane->GetBonePos( L"Dummy02" ) );
	pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P03", pMeshInstPlane->GetBonePos( L"Dummy02" ) );
	pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P02", pMeshInstPlane->GetBonePos( L"Dummy03" ) );
	pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P03", pMeshInstPlane->GetBonePos( L"Dummy03" ) );
	pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P02", pMeshInstPlane->GetBonePos( L"Dummy04" ) );
	pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P03", pMeshInstPlane->GetBonePos( L"Dummy04" ) );
	pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P02", pMeshInstPlane->GetBonePos( L"Dummy05" ) );
	pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P03", pMeshInstPlane->GetBonePos( L"Dummy05" ) );
	pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P02", pMeshInstPlane->GetBonePos( L"Dummy06" ) );
	pMajorParticleSystem->CreateSequence( (CKTDGObject*) m_pGUEve,  L"eve_spectro_model_P03", pMeshInstPlane->GetBonePos( L"Dummy06" ) );

	return;
}

void CX2GUEve::EveElectraSystem::DestroyFormationMarkAndMsgParticle()
{
	CKTDGParticleSystem* pMajorParticleSystem = g_pX2Game->GetMajorParticle();
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleFormationMark[0] );
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleFormationMark[1] );
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleFormationMark[2] );

	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleFormationMsg[0] );
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleFormationMsg[1] );
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleFormationMsg[2] );
}

void CX2GUEve::EveElectraSystem::DestroyPlaneAndCrystalEffect()
{
	CKTDGXMeshPlayer* pMajorMeshPlayer = g_pX2Game->GetMajorXMeshPlayer();
	pMajorMeshPlayer->DestroyInstanceHandle( m_hEffectCrystal1 );
	pMajorMeshPlayer->DestroyInstanceHandle( m_hEffectCrystal2 );
	pMajorMeshPlayer->DestroyInstanceHandle( m_hEffectCrystal3 );
	pMajorMeshPlayer->DestroyInstanceHandle( m_hEffectPlane );

	CKTDGParticleSystem* pMajorParticleSystem = g_pX2Game->GetMajorParticle();
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleCrystal[0] );
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleCrystal[1] );
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleCrystal[2] );
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticlePlane );


}

void CX2GUEve::EveElectraSystem::DestroyGigaPlaneAndCrystalEffect()
{
	CKTDGXMeshPlayer* pMajorMeshPlayer = g_pX2Game->GetMajorXMeshPlayer();
	pMajorMeshPlayer->DestroyInstanceHandle( m_hEffectGigaCrystal[0] );
	pMajorMeshPlayer->DestroyInstanceHandle( m_hEffectGigaCrystal[1] );
	pMajorMeshPlayer->DestroyInstanceHandle( m_hEffectGigaCrystal[2] );
	pMajorMeshPlayer->DestroyInstanceHandle( m_hEffectGigaCrystal[3] );
	pMajorMeshPlayer->DestroyInstanceHandle( m_hEffectGigaCrystal[4] );
	pMajorMeshPlayer->DestroyInstanceHandle( m_hEffectGigaPlane );

	CKTDGParticleSystem* pMajorParticleSystem = g_pX2Game->GetMajorParticle();
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleGigaCrystal[0] );
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleGigaCrystal[1] );
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleGigaCrystal[2] );
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleGigaCrystal[3] );
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleGigaCrystal[4] );
	pMajorParticleSystem->DestroyInstanceHandle( m_hParticleGigaPlane );
}

BUFF_TEMPLET_ID CX2GUEve::EveElectraSystem::GetBuffTempletIdByPlaneFormation( const PlaneFormationType ePlaneFormationType_ ) const
{
	switch ( ePlaneFormationType_ )
	{
	case PFT_AMPLIFIER:
		return BTI_BUFF_AMPLIFICATION_PLACE;
		break;

	case PFT_SPECTRUM:
		return BTI_BUFF_SPECTRUM_PLACE;
		break;

	case PFT_INDUCTION:
		return BTI_BUFF_INDUCTION_PLACE;
		break;

	case PFT_FUSION:
		return BTI_BUFF_SI_SA_EBS_ENERGETIC_HEART;
		break;

	default:
		return BTI_NONE;
		break;
	}
}




CX2GUEve::FlyingImpactData::FlyingImpactData()
{
	m_vOffsetRotate = D3DXVECTOR3(0, 0, 0);
	m_vOffsetPos = D3DXVECTOR3( 0, 0, 0 );
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffect = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_pEffect = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
}

CX2GUEve::FlyingImpactData::~FlyingImpactData()
{
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( m_hEffect != INVALID_DAMAGE_EFFECT_HANDLE )
        g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_hEffect );
#else  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	if( NULL != m_pEffect )
		g_pX2Game->GetDamageEffect()->DestroyInstance( m_pEffect );
    m_pEffect = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
}

//{{ robobeg : 2013-08-30
CX2DamageEffect::CEffect*   CX2GUEve::FlyingImpactData::GetLiveDamageEffect()
{
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    return  g_pX2Game->GetDamageEffect()->GetInstance( m_hEffect );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    return  ( g_pX2Game->GetDamageEffect()->IsLiveInstance( m_pEffect ) == true ) ? m_pEffect : NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
}
//}} robobeg : 2013-08-30


void CX2GUEve::ClearThousandStar()
{
    if ( CX2DamageEffect::CEffect* pTSEffect =  ( m_pThousandStar != NULL ) ? m_pThousandStar->GetLiveDamageEffect() : NULL )
	{
        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pTSEffect->GetMainEffect() )
        {
            CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;
		    pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"EveThousandStarDie", pMeshInstance->GetPos(), GetRotateDegree(), GetRotateDegree() );
        }
	}


	if( m_pThousandStar != NULL )
		SAFE_DELETE( m_pThousandStar );

	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleThousandStarFormation );
#ifdef BALANCE_PATCH_20120329
	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hCountDownThousandStar );
	m_fElapsedTimeThousandStartCreated	 = 0.f;
#endif BALANCE_PATCH_20120329
	m_bLockOnNpc = false;
	m_iLockOnUid = -1;

	m_bEntireFireMode	= false;
	m_fDelayAttackTimeEntireFire	= 0.f;
	m_iThousandStarCount			= 0;

	m_pThousandStar = NULL;


}

void CX2GUEve::CreateThousandStar()
{
	m_fThousandStarPowerRate = 1.f;
	m_fElapsedTimeThousandStartCreated = 0.f;
	ClearThousandStar();
	if( m_pThousandStar == NULL )
	{		
		m_pThousandStar = new FlyingImpactData;
		m_pThousandStar->m_vOffsetPos = D3DXVECTOR3( -180*0.9f, 52*3.f, 0.f );		
	}
    if ( m_pThousandStar == NULL )
        return;

    if ( m_pThousandStar->GetLiveDamageEffect() == NULL )
	{
		D3DXVECTOR3 vRotDegree = GetRotateDegree();
		D3DXVECTOR3 vDirVec = GetDirVector();
		D3DXVECTOR3 vZVec = GetZVector();
		vDirVec.y = 0.f;

		D3DXVECTOR3 vPos = GetPos();
		if( false == GetIsRight() )
		{
			vRotDegree.y += 180.f;
		}

		CX2DamageEffect::CEffect *pEffectThounsandStar = g_pX2Game->GetDamageEffect()->CreateInstance( (CX2GameUnit*) this, L"EVE_THOUSAND_STAR", GetPowerRate(), vPos, 
			vRotDegree, vRotDegree, m_FrameDataNow.unitCondition.landPosition.y );

		if( pEffectThounsandStar == NULL )
		{
			ClearThousandStar();
			return;
		}

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        m_pThousandStar->m_hEffect = pEffectThounsandStar->GetHandle();
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
		m_pThousandStar->m_pEffect = pEffectThounsandStar;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

        CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffectThounsandStar->GetMainEffect();
        if ( pMeshInstance != NULL  )
        {
		    pMeshInstance->SetMoveAxisAngleDegree( GetRotateDegree() );
		    pMeshInstance->SetRotateDegree( GetRotateDegree() + m_pThousandStar->m_vOffsetRotate );
        }

		D3DXVECTOR3 vTargetPos = GetPos(); 
		if( true == GetIsRight() )
		{
			vTargetPos += m_pThousandStar->m_vOffsetPos.x * vDirVec;
			vTargetPos.y += m_pThousandStar->m_vOffsetPos.y;
			vTargetPos += m_pThousandStar->m_vOffsetPos.z * vZVec;
		}
		else
		{
			vTargetPos -= m_pThousandStar->m_vOffsetPos.x * vDirVec;
			vTargetPos.y += m_pThousandStar->m_vOffsetPos.y;
			vTargetPos += m_pThousandStar->m_vOffsetPos.z * vZVec;
		}

        if ( pMeshInstance != NULL )
		    pMeshInstance->SetPos( vTargetPos );

		m_iThousandStarCount = 100;
	}
}

void CX2GUEve::DoFrameMoveThousandStar()
{
#ifdef BALANCE_PATCH_20120329
	if( m_pThousandStar != NULL 
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        && m_pThousandStar->m_hEffect != INVALID_DAMAGE_EFFECT_HANDLE
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        && m_pThousandStar->m_pEffect != NULL 
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        )
	{
		m_fElapsedTimeThousandStartCreated += m_fElapsedTime;
	}
#else
	m_fElapsedTimeThousandStartCreated += m_fElapsedTime;
#endif BALANCE_PATCH_20120329
	if( m_bEntireFireMode == true )
	{
		m_fDelayAttackTimeEntireFire += m_fElapsedTime;
		if( m_fDelayAttackTimeEntireFire >= 0.033333f )
		{
			PlaySound( L"Raven_NasodCore_Attack.ogg" );
			for(UINT i=0; i<100; i++)
			{
				EntireAttackThousandStar();
				if( m_iThousandStarCount <= 0)
					break;
			}
			m_bEntireFireMode	= false;		//임시로 무한 사운드 재생 버그 방지

			m_fDelayAttackTimeEntireFire			= 0.f;
		}
	}
#ifdef BALANCE_PATCH_20120329
	else if( m_fElapsedTimeThousandStartCreated >= 55.f && m_fElapsedTimeThousandStartCreated - m_fElapsedTime < 55.f
		&& m_pThousandStar != NULL 
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        && m_pThousandStar->m_hEffect != INVALID_DAMAGE_EFFECT_HANDLE
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        && m_pThousandStar->m_pEffect != NULL 
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        )
	{
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        CX2DamageEffect::CEffect*   pTSEffect = g_pX2Game->GetDamageEffect()->GetInstance( m_pThousandStar->m_hEffect );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        CX2DamageEffect::CEffect*   pTSEffect = m_pThousandStar->m_pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        if ( pTSEffect != NULL )
			m_hCountDownThousandStar = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"CountDown5", pTSEffect->GetPos() );
	}
	else if( m_fElapsedTimeThousandStartCreated >= 60.f )
	{
		UpNowMp( m_iThousandStarCount * 1.25f );

		if( NULL != g_pData->GetPicCharBlue() )
		{
			WCHAR wszText[64] = L"";
			StringCchPrintfW( wszText, ARRAY_SIZE(wszText), L"MP+ %d", (int) (m_iThousandStarCount * 1.25f) );

			D3DXVECTOR3 pos = GetPos();
			pos.y += 50.f;

			g_pData->GetPicCharBlue()->DrawText( wszText, pos, GetDirVector(), CKTDGPicChar::AT_CENTER );
		}


		m_iThousandStarCount = 0;
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS );

		if( NULL != pSkillTemplet )
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			if ( NULL == GetUnit() )
				return;
	
			CX2UserSkillTree& userSkillTree = GetUnit()->AccessUnitData().m_UserSkillTree;
	
			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
			float fRemainCoolTime = pSkillTemplet->GetSkillCoolTimeValue( iSkillTempletLevel ) - m_fElapsedTimeThousandStartCreated; 
	#else // UPGRADE_SKILL_SYSTEM_2013

			CX2UserSkillTree& userSkillTree = GetUnit()->AccessUnitData().m_UserSkillTree;

			float fRemainCoolTime = pSkillTemplet->m_fSkillCoolTime - m_fElapsedTimeThousandStartCreated; 
	#endif // UPGRADE_SKILL_SYSTEM_2013
			if( fRemainCoolTime < 0.f )
				fRemainCoolTime = 0.f;

			userSkillTree.SetSkillCoolTimeLeft( CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS, fRemainCoolTime  );
			if ( IsMyUnit() )
				g_pX2Game->UpdateSkillSlotUI();
		}
		ClearThousandStar();
	}
#endif BALANCE_PATCH_20120329
	else if( m_bDelayAttackThousandStar == true )
	{
		m_fDelayAttackTime += m_fElapsedTime;
		if( m_fDelayAttackTime >= 0.3f )
		{
			AttackThousandStar();
			m_bDelayAttackThousandStar	= false;
			m_fDelayAttackTime			= 0.f;
		}
	}

	D3DXVECTOR3 vDirVec = GetDirVector();


	if( m_pThousandStar != NULL 
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        && m_pThousandStar->m_hEffect != INVALID_DAMAGE_EFFECT_HANDLE
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        && m_pThousandStar->m_pEffect != NULL 
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        )
	{
        if ( CX2DamageEffect::CEffect* pSTEffect = m_pThousandStar->GetLiveDamageEffect() )
		{
			D3DXVECTOR3 vZVec = GetZVector();
			D3DXVec3Normalize( &vDirVec, &vDirVec );

			CKTDGXMeshPlayer::CXMeshInstance* pThousandStarMeshInstance = pSTEffect->GetMainEffect();
			if( NULL != pThousandStarMeshInstance && m_bEntireFireMode == false )
			{
				D3DXVECTOR3 vTargetPos = GetPos();
				if( true == GetIsRight() )
				{
					vTargetPos += m_pThousandStar->m_vOffsetPos.x * vDirVec;
					vTargetPos.y += m_pThousandStar->m_vOffsetPos.y;
					vTargetPos += m_pThousandStar->m_vOffsetPos.z * vZVec;
				}
				else
				{
					vTargetPos -= m_pThousandStar->m_vOffsetPos.x * vDirVec;
					vTargetPos.y += m_pThousandStar->m_vOffsetPos.y;
					vTargetPos += m_pThousandStar->m_vOffsetPos.z * vZVec;
				}

				float coeff = 0.05f;
				D3DXVECTOR3 vRotateDegree = GetRotateDegree() + m_pThousandStar->m_vOffsetRotate;
				pThousandStarMeshInstance->SetRotateDegree( vRotateDegree );
				pThousandStarMeshInstance->SetMoveAxisAngleDegree( GetRotateDegree() );

				vTargetPos = vTargetPos * coeff + pThousandStarMeshInstance->GetPos() * ( 1.f-coeff );
				pThousandStarMeshInstance->SetPos( vTargetPos );

				CKTDGParticleSystem::CParticleEventSequence* pSeqThousandStarFormation = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_EveElectraSystem.m_hParticleThousandStarFormation );
				if( pSeqThousandStarFormation != NULL )
				{
					pSeqThousandStarFormation->SetPosition( pThousandStarMeshInstance->GetPos() );
				}
#ifdef BALANCE_PATCH_20120329
				CKTDGParticleSystem::CParticleEventSequence* pSeqCountDownThousandStar = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hCountDownThousandStar );
				if( pSeqCountDownThousandStar != NULL )
				{
					D3DXVECTOR3 vCountDownPos = pThousandStarMeshInstance->GetPos();
					vCountDownPos.y += 80.f;
					pSeqCountDownThousandStar->SetPosition( vCountDownPos );
				}
#endif BALANCE_PATCH_20120329
			}

			if( m_iLockOnUid != -1 )
			{
				CX2GameUnit* pGameUnit = NULL;
				if( m_bLockOnNpc )
					pGameUnit = g_pX2Game->GetNPCUnitByUID( (int)m_iLockOnUid );
				else
					pGameUnit = g_pX2Game->GetUserUnitByUID( m_iLockOnUid );

				D3DXVECTOR3 vPos( 0.f, 0.f, 0.f );
				
				if( pGameUnit != NULL )
				{
					const CKTDXCollision::CollisionDataListSet& AttackListSet = pGameUnit->GetCollisionListSet();
					vPos = pGameUnit->GetPos();
					vPos.y += 100.f;

					BOOST_FOREACH( const CKTDXCollision::CollisionDataList* collisionDataList, AttackListSet )
					{
						BOOST_FOREACH( CKTDXCollision::CollisionData* collisionData, *collisionDataList )
						{
							D3DXVECTOR3 vCollPos = collisionData->GetPointStart();
							float fDist = GetDistance( GetPos(), vCollPos );
							float fOldDist = GetDistance( GetPos(), vPos );

							if ( fDist <= fOldDist )
								vPos = vCollPos;
						}
					}
				}

				if( pGameUnit == NULL || 
					( pGameUnit != NULL && pGameUnit->GetNowHp() <= 0.f) ||
					( pGameUnit != NULL && GetDistance( GetPos(), vPos/*pGameUnit->GetPos()*/ ) > 1000.f ) )
				{
					m_iLockOnUid = -1;
				}

			}

		}
		else
		{				
			ClearThousandStar();				
		}			
	}

}

void CX2GUEve::EntireAttackThousandStar()
{
	if( CX2DamageEffect::CEffect* pTSEffect = ( m_pThousandStar != NULL ) ? m_pThousandStar->GetLiveDamageEffect() : NULL )
	{
		D3DXVECTOR3 vRotateDegree;
		vRotateDegree = GetRotateDegree();

		float fVarRotateZ = GetRandomFloat( m_iThousandStarCount ) * 270.f;
		fVarRotateZ += 45.f;
		float fVarRotateX = GetRandomFloat( m_iThousandStarCount + m_iThousandStarCount ) * 360.f;

		vRotateDegree.z += fVarRotateZ;

		vRotateDegree.x += fVarRotateX;
		wstring wstrDamageEffectName = L"EVE_THOUSANDSTAR_MAGICBALL_ENTIRE";

		CX2DamageEffect::CEffect* pEffect = NULL;
        CKTDGXMeshPlayer::CXMeshInstance* pThousandStarMeshInstance = pTSEffect->GetMainEffect();
		if( m_EveElectraSystem.GetEnableSystem() == true &&
			( m_EveElectraSystem.GetPlaneFormation() == PFT_AMPLIFIER 
			|| m_EveElectraSystem.GetPlaneFormation() == PFT_SPECTRUM
#ifdef SERV_EVE_BATTLE_SERAPH
			|| m_EveElectraSystem.GetPlaneFormation() == PFT_INDUCTION
			|| m_EveElectraSystem.GetPlaneFormation() == PFT_FUSION
#endif
			)
			)
		{
            if ( pThousandStarMeshInstance != NULL )
            {
			    pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, wstrDamageEffectName.c_str(), m_fThousandStarPowerRate, pThousandStarMeshInstance->GetPos(), vRotateDegree, vRotateDegree );

			    CX2DamageEffect::LockOnData* pLockOnData = &pEffect->GetLockOnData();
			    if( m_bLockOnNpc == true )
				    pLockOnData->m_LockOnNPCUID = (int)m_iLockOnUid;
			    else
				    pLockOnData->m_LockOnUnitUID = m_iLockOnUid;

			    pEffect->GetDamageData().damage.fPhysic *= 1.2f;
			    pEffect->GetDamageData().damage.fMagic *= 1.2f;

			    D3DXVECTOR3 vAmplifyScale = pEffect->GetMainEffectScaleByUnit();

                if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                {
			        D3DXVECTOR3 vScale = pMeshInstance->GetScale();

			        vAmplifyScale.x *= vScale.x;
			        vAmplifyScale.y *= vScale.y;
			        vAmplifyScale.z *= vScale.z;
			        vAmplifyScale *= 1.3f;

			        pEffect->SetScale( vAmplifyScale );
                }
            }

			// 			if( NULL != pEffect )
			// 				m_EveElectraSystem.AddLockonToSystem( pEffect, L"EVE_THOUSANDSTAR_MAGICBALL_FILTERED", L"EVE_THOUSANDSTAR_MAGICBALL_FILTERED" 
		}
		else
		{
            if ( pThousandStarMeshInstance != NULL )
            {
			    pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, wstrDamageEffectName.c_str(), m_fThousandStarPowerRate, pThousandStarMeshInstance->GetPos(), vRotateDegree, vRotateDegree );

			    CX2DamageEffect::LockOnData* pLockOnData = &pEffect->GetLockOnData();
			    if( m_bLockOnNpc == true )
				    pLockOnData->m_LockOnNPCUID = (int)m_iLockOnUid;
			    else
				    pLockOnData->m_LockOnUnitUID = m_iLockOnUid;
                }
			// 			if( NULL != pEffect )
			// 				m_EveElectraSystem.AddLockonToSystem( pEffect, L"EVE_THOUSANDSTAR_MAGICBALL_FILTERED", L"EVE_THOUSANDSTAR_MAGICBALL_FILTERED" 
		}

        if ( pThousandStarMeshInstance != NULL )
		    g_pX2Game->GetMajorParticle()->CreateSequence( static_cast<CKTDGObject*>( this ),  L"eve_thousandsOfStars_model_P02", pThousandStarMeshInstance->GetPos() );




		m_iThousandStarCount--;
		if( m_iThousandStarCount <= 0 )
		{
			const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS );
			if( NULL != pSkillTemplet )
			{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
				if ( NULL == GetUnit() )
					return;
	
				CX2UserSkillTree& cUserSkillTree = GetUnit()->AccessUnitData().m_UserSkillTree;
	
				const int iSkillTempletLevel = max( 1, cUserSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
				float fRemainCoolTime = pSkillTemplet->GetSkillCoolTimeValue( iSkillTempletLevel ) - m_fElapsedTimeThousandStartCreated; 
	#else // UPGRADE_SKILL_SYSTEM_2013

				CX2UserSkillTree& cUserSkillTree = GetUnit()->AccessUnitData().m_UserSkillTree;

				float fRemainCoolTime = pSkillTemplet->m_fSkillCoolTime - m_fElapsedTimeThousandStartCreated; 
	#endif // UPGRADE_SKILL_SYSTEM_2013
				
				if( fRemainCoolTime < 5.f )
					fRemainCoolTime = 5.f;

				cUserSkillTree.SetSkillCoolTimeLeft( CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS, fRemainCoolTime  );
				if ( IsMyUnit() )
					g_pX2Game->UpdateSkillSlotUI();
			}
			ClearThousandStar();
		}

	}
}


void CX2GUEve::AttackThousandStar()
{
	if( CX2DamageEffect::CEffect* pTSEffect = ( m_pThousandStar != NULL ) ? m_pThousandStar->GetLiveDamageEffect() : NULL )
	{

		D3DXVECTOR3 vRotateDegree;
		vRotateDegree = GetRotateDegree();

		float fVarRotateX = GetRandomFloat( m_iThousandStarCount ) * 360.f;
		vRotateDegree.x += fVarRotateX;

		wstring wstrDamageEffectName = L"";

		if( m_bEntireFireMode == true )
		{
			wstrDamageEffectName = L"EVE_THOUSANDSTAR_MAGICBALL_ENTIRE";
		}
		else
		{
			wstrDamageEffectName = L"EVE_THOUSANDSTAR_MAGICBALL";
		}


		CX2DamageEffect::CEffect* pEffect = NULL;
         CKTDGXMeshPlayer::CXMeshInstance* pThousandStarMeshInstance = pTSEffect->GetMainEffect();
		if( m_EveElectraSystem.GetEnableSystem() == true && m_EveElectraSystem.GetPlaneFormation() == PFT_AMPLIFIER )
		{
            if ( pThousandStarMeshInstance != NULL )
            {
			    pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, wstrDamageEffectName.c_str(), m_fThousandStarPowerRate, pThousandStarMeshInstance->GetPos(), vRotateDegree, vRotateDegree );

			    CX2DamageEffect::LockOnData* pLockOnData = &pEffect->GetLockOnData();
			    if( m_bLockOnNpc == true )
				    pLockOnData->m_LockOnNPCUID = (int)m_iLockOnUid;
			    else
				    pLockOnData->m_LockOnUnitUID = m_iLockOnUid;

			    pEffect->GetDamageData().damage.fPhysic *= 1.2f;
			    pEffect->GetDamageData().damage.fMagic *= 1.2f;

			    D3DXVECTOR3 vAmplifyScale = pEffect->GetMainEffectScaleByUnit();

                if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                {
			        D3DXVECTOR3 vScale = pMeshInstance->GetScale();

			        vAmplifyScale.x *= vScale.x;
			        vAmplifyScale.y *= vScale.y;
			        vAmplifyScale.z *= vScale.z;
			        vAmplifyScale *= 1.3f;

			        pEffect->SetScale( vAmplifyScale );
                }
            }

			// 			if( NULL != pEffect )
			// 				m_EveElectraSystem.AddLockonToSystem( pEffect, L"EVE_THOUSANDSTAR_MAGICBALL_FILTERED", L"EVE_THOUSANDSTAR_MAGICBALL_FILTERED" 
		}
		else if( m_EveElectraSystem.GetEnableSystem() == true && m_EveElectraSystem.GetPlaneFormation() == PFT_SPECTRUM )
		{
			for(UINT i=0; i<3; i++)
			{
				if( i == 1 )
				{
					vRotateDegree.x += 120.f;
				}
				else if( i == 2)
				{
					vRotateDegree.x += 120.f;
				}

                if ( pThousandStarMeshInstance != NULL )
                {
				    pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, wstrDamageEffectName.c_str(), m_fThousandStarPowerRate, pThousandStarMeshInstance->GetPos(), vRotateDegree, vRotateDegree );

				    CX2DamageEffect::LockOnData* pLockOnData = &pEffect->GetLockOnData();
				    if( m_bLockOnNpc == true )
					    pLockOnData->m_LockOnNPCUID = (int)m_iLockOnUid;
				    else
					    pLockOnData->m_LockOnUnitUID = m_iLockOnUid;


				    pEffect->GetDamageData().damage.fPhysic *= 0.5f;
				    pEffect->GetDamageData().damage.fMagic *= 0.5f;

				    D3DXVECTOR3 vSpectrumScale = pEffect->GetMainEffectScaleByUnit();
                    if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                    {
				        D3DXVECTOR3 vScale = pMeshInstance->GetScale();

				        vSpectrumScale.x *= vScale.x;
				        vSpectrumScale.y *= vScale.y;
				        vSpectrumScale.z *= vScale.z;
				        vSpectrumScale *= 0.8f;

				        pEffect->SetScale( vSpectrumScale );
                    }
                }


				// 				if( NULL != pEffect )
				// 					m_EveElectraSystem.AddLockonToSystem( pEffect, L"EVE_THOUSANDSTAR_MAGICBALL_FILTERED", L"EVE_THOUSANDSTAR_MAGICBALL_FILTERED" 			
			}
		}
#ifdef SERV_EVE_BATTLE_SERAPH
		else if ( m_EveElectraSystem.GetEnableSystem() == true && m_EveElectraSystem.GetPlaneFormation() == PFT_INDUCTION )
		{
            if ( pThousandStarMeshInstance != NULL )
            {
			    pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, wstrDamageEffectName.c_str(), m_fThousandStarPowerRate,
				    pThousandStarMeshInstance->GetPos(), vRotateDegree, vRotateDegree );

			    CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();

			    pEffect->SetDamageTime( pEffect->GetDamageTime() + 1 );
			    pEffect->GetDamageData().damage.fPhysic *= 0.55f;
			    pEffect->GetDamageData().damage.fMagic *= 0.55f;
			    pEffect->GetDamageData().fHitGap = 1.0f;

			    pDamageData->bReAttack  = true;
			    pDamageData->fHitGap	= 1.f;
			    pDamageData->fHitAddMP			*= 0.55f;
			    pDamageData->m_fRateModifier	*= 0.55f;
			    pDamageData->techPoint			= int(pDamageData->techPoint * 0.55);

			    CX2DamageEffect::LockOnData* pLockOnData = &pEffect->GetLockOnData();
			    if( m_bLockOnNpc == true )
				    pLockOnData->m_LockOnNPCUID = (int)m_iLockOnUid;
			    else
				    pLockOnData->m_LockOnUnitUID = m_iLockOnUid;

			    D3DXVECTOR3 vInductionScale = pEffect->GetMainEffectScaleByUnit();
                if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                {
			        D3DXVECTOR3 vScale = pMeshInstance->GetScale();

			        vInductionScale.x *= vScale.x;
			        vInductionScale.y *= vScale.y;
			        vInductionScale.z *= vScale.z;
			        vInductionScale *= 0.8f;

			        pEffect->SetScale( vInductionScale );
                }
            }
		}
		else if ( m_EveElectraSystem.GetEnableSystem() == true && m_EveElectraSystem.GetPlaneFormation() == PFT_FUSION )
		{
			for(UINT i = 0; i < 3; ++i)
			{
				if( i == 1 )
				{
					vRotateDegree.x += 120.f;
				}
				else if( i == 2)
				{
					vRotateDegree.x += 120.f;
				}

                if ( pThousandStarMeshInstance != NULL )
                {
				    pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, wstrDamageEffectName.c_str(), m_fThousandStarPowerRate,
					    pThousandStarMeshInstance->GetPos(), vRotateDegree, vRotateDegree );

				    CX2DamageManager::DamageData* pDamageData = &pEffect->GetDamageData();

				    pEffect->SetDamageTime( pEffect->GetDamageTime() + 1 );
				    pEffect->GetDamageData().damage.fPhysic *= 0.25f;
				    pEffect->GetDamageData().damage.fMagic *= 0.25f;
				    pEffect->GetDamageData().fHitGap = 1.0f;

				    pDamageData->bReAttack  = true;
				    pDamageData->fHitGap	= 1.f;
				    pDamageData->fHitAddMP			*= 0.25f;
				    pDamageData->m_fRateModifier	*= 0.25f;
				    pDamageData->techPoint			= int(pDamageData->techPoint * 0.25);

				    CX2DamageEffect::LockOnData* pLockOnData = &pEffect->GetLockOnData();
				    if( m_bLockOnNpc == true )
					    pLockOnData->m_LockOnNPCUID = (int)m_iLockOnUid;
				    else
					    pLockOnData->m_LockOnUnitUID = m_iLockOnUid;

				    D3DXVECTOR3 vInductionScale = pEffect->GetMainEffectScaleByUnit();
                    if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
                    {
				        D3DXVECTOR3 vScale = pMeshInstance->GetScale();

				        vInductionScale.x *= vScale.x;
				        vInductionScale.y *= vScale.y;
				        vInductionScale.z *= vScale.z;
				        vInductionScale *= 0.75f;

				        pEffect->SetScale( vInductionScale );
                    }
                }
			}
		}
#endif
		else
		{
            if ( pThousandStarMeshInstance != NULL )
            {
			    pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, wstrDamageEffectName.c_str(), m_fThousandStarPowerRate, pThousandStarMeshInstance->GetPos(), vRotateDegree, vRotateDegree );

			    CX2DamageEffect::LockOnData* pLockOnData = &pEffect->GetLockOnData();
			    if( m_bLockOnNpc == true )
				    pLockOnData->m_LockOnNPCUID = (int)m_iLockOnUid;
			    else
				    pLockOnData->m_LockOnUnitUID = m_iLockOnUid;
            }
			// 			if( NULL != pEffect )
			// 				m_EveElectraSystem.AddLockonToSystem( pEffect, L"EVE_THOUSANDSTAR_MAGICBALL_FILTERED", L"EVE_THOUSANDSTAR_MAGICBALL_FILTERED" 		
		}


        if ( pThousandStarMeshInstance != NULL )
		    g_pX2Game->GetMajorParticle()->CreateSequence( static_cast<CKTDGObject*>( this ),  L"eve_thousandsOfStars_model_P02", pThousandStarMeshInstance->GetPos() );


		PlaySound( L"Raven_NasodCore_Attack.ogg" );

		m_iThousandStarCount--;
		if( m_iThousandStarCount <= 0 )
		{
			const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS );

			if( NULL != pSkillTemplet )
			{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
				if ( NULL == GetUnit() )
					return;
	
				CX2UserSkillTree& cUserSkillTree = GetUnit()->AccessUnitData().m_UserSkillTree;
	
				const int iSkillTempletLevel = max( 1, cUserSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
				float fRemainCoolTime = pSkillTemplet->GetSkillCoolTimeValue( iSkillTempletLevel ) - m_fElapsedTimeThousandStartCreated; 
	#else // UPGRADE_SKILL_SYSTEM_2013
			    CX2UserSkillTree& cUserSkillTree =  GetUnit()->AccessUnitData().m_UserSkillTree;

				float fRemainCoolTime = pSkillTemplet->m_fSkillCoolTime - m_fElapsedTimeThousandStartCreated; 
	#endif // UPGRADE_SKILL_SYSTEM_2013
				
				if( fRemainCoolTime < 0.f )
					fRemainCoolTime = 0.f;

				cUserSkillTree.SetSkillCoolTimeLeft( CX2SkillTree::SI_SA_EEL_THOUSANDS_OF_STARS, fRemainCoolTime  );
				if ( IsMyUnit() )
					g_pX2Game->UpdateSkillSlotUI();
			}
			ClearThousandStar();
		}

	}
}

void CX2GUEve::AttackResultByType( CX2DamageManager::DamageData &pDamageData )
{
	CX2GUUser::AttackResultByType( pDamageData );

	// 	if( pDamageData.pDefenderUnit == NULL || pDamageData.pDefenderUnit->GetNowHp() <= 0.f )
	// 		return;

	if( pDamageData.optrDefenderGameUnit->GetGameUnitType() == CX2GameUnit::GUT_NPC )
	{
		CX2GUNPC *pNpc = static_cast<CX2GUNPC *>( pDamageData.optrDefenderGameUnit.GetObservable() );
		if( pNpc != NULL && pNpc->GetNPCTemplet().m_ClassType != CX2UnitManager::NCT_BASIC )
			return;
	}

	if( m_bDelayAttackThousandStar == false &&
		pDamageData.m_eDamageTrigger != CX2DamageManager::DTT_EVE_THOUSAND_STAR &&
		pDamageData.m_fHpPercentUp <= 0.f &&
		m_pThousandStar != NULL &&
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        m_pThousandStar->m_hEffect != INVALID_DAMAGE_EFFECT_HANDLE
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        m_pThousandStar->m_pEffect != NULL 
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        )
    {
	    if( CX2DamageEffect::CEffect* pTSEffect = m_pThousandStar->GetLiveDamageEffect() )
        {
            CKTDGXMeshPlayer::CXMeshInstance* pThousandStarMeshInstance = pTSEffect->GetMainEffect();
		    if ( pThousandStarMeshInstance != NULL
                && pThousandStarMeshInstance->GetGlobalTime() > 3.f )
	        {
		        // 발사		
		        m_bDelayAttackThousandStar = true;
		        m_fDelayAttackTime = 0.f;
		        m_fThousandStarAttackTime = 0.f;

		        if( CX2DamageManager::AT_UNIT == pDamageData.defenderType )
		        {
			        if( null != pDamageData.optrDefenderGameUnit )
			        {				
				        if( CX2GameUnit::GUT_USER == pDamageData.optrDefenderGameUnit->GetGameUnitType() )
				        {
					        m_bLockOnNpc = false;
					        m_iLockOnUid = pDamageData.optrDefenderGameUnit->GetUnitUID();
				        }
				        else if( CX2GameUnit::GUT_NPC == pDamageData.optrDefenderGameUnit->GetGameUnitType() )
				        {
					        m_bLockOnNpc = true;
					        m_iLockOnUid = pDamageData.optrDefenderGameUnit->GetUnitUID();
				        }
			        }
		        }		

		        pThousandStarMeshInstance->SetDirSpeed( 0.f );


		        // PlaySound( L"Raven_NasodCore_Trans_Attack.ogg" );
#ifndef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
				// 해당 구문으로 인해 기동 게이지가 차지 않고 반응하지 않던 문제 수정
				return;
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
            }
        }
	}
	if( pDamageData.m_fHpPercentUp <= 0.f )
	{
		if( CX2DamageManager::AT_UNIT == pDamageData.defenderType )
		{
			if( null != pDamageData.optrDefenderGameUnit )
			{				
				if( CX2GameUnit::GUT_USER == pDamageData.optrDefenderGameUnit->GetGameUnitType() )
				{
					m_bLockOnNpc = false;
					m_iLockOnUid = pDamageData.optrDefenderGameUnit->GetUnitUID();
				}
				else if( CX2GameUnit::GUT_NPC == pDamageData.optrDefenderGameUnit->GetGameUnitType() )
				{
					m_bLockOnNpc = true;
					m_iLockOnUid = pDamageData.optrDefenderGameUnit->GetUnitUID();
				}
			}
		}
	}


#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	// 각성 상태에서 AT Special Type 의 공격 이라면 기동 게이지를 증가 시킨다.
	if ( pDamageData.attackType != CX2DamageManager::AT_SPECIAL && GetRemainHyperModeTime() > 0.f )
	{
		// 기동 게이지 관련 처리
		if( IsMyUnit() == true )
			m_fManeuverGauge += ( max( pDamageData.damage.fPhysic, pDamageData.damage.fMagic ) * pDamageData.m_fRateModifier * 4.f );

		if( m_fManeuverGauge > 100.f )
			m_fManeuverGauge = 100.f;
	}
	
	// 기동 코어가 발사될 조건
	if ( true == ( pDamageData.m_eDamageTrigger == CX2DamageManager::DTT_EVE_MANEUVER_ATTACK &&			// 데미지 데이터의 데미지 트리거가 이브 기동 코어 공격이고
		NULL != m_pManeuverCore && IsWaitManeuverCore() == true )										// 기동 코어가 대기 중일 때		
		)	
	{
		SetAttackManeuverCore ( pDamageData );			
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
		m_wstrManeuverCoreTargetBoneName = GetBoneNameNearestImpactPoint ( pDamageData.impactPoint );
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	}
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
}

void CX2GUEve::ENSI_COMBO_X_Start()
{
	CommonStateStart();
	m_fPlaneZAngle	= 0.f;
}

void CX2GUEve::ENSI_COMBO_XX_Start()
{
	CommonStateStart();
	m_fPlaneZAngle	= 0.f;
}

void CX2GUEve::ENSI_COMBO_XXX_Start()
{
	CommonStateStart();
	m_fPlaneZAngle	= 0.f;
}

void CX2GUEve::ENSI_EPR_COMBO_ZZZfrontZ_Start()
{
	CommonStateStart();
	m_fPlaneZAngle	= 0.f;
	m_bNotEnoughMPZZZfrontZLaser = false;
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectElectraLaserZZZfrontZ = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectElectraLaserZZZfrontZ = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

	m_EveElectraSystem.m_fLaserEndOffsetX = 0.f;
	m_EveElectraSystem.m_fLaserEndOffsetY = 0.f;
}

void CX2GUEve::ENSI_EPR_COMBO_ZZZfrontZ_FrameMove()
{

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.02f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.02f ) == true && EventCheck( 0.02f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( 0.f, 2.0f, 240.f, 130.f );
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.3666f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.3666f ) == true && EventCheck( 0.3666f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.m_fPlaneZAngle = m_fPlaneZAngle;
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{

		D3DXVECTOR3 vDamageEffectPos = GetPos();
		vDamageEffectPos.y += 130.f;
		D3DXVECTOR3 vZeroYDirVector = GetDirVector();
		vZeroYDirVector.y = 0.f;
		D3DXVec3Normalize( &vZeroYDirVector, &vZeroYDirVector );


		if(GetIsRight() == false)
		{
			vZeroYDirVector.x = -vZeroYDirVector.x;
			vZeroYDirVector.z = -vZeroYDirVector.z;
		}
		vDamageEffectPos += (130.f * vZeroYDirVector);

		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_ZZZFZ_LASER", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        m_hEffectElectraLaserZZZfrontZ = pEffect->GetHandle();
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
		m_EffectElectraLaserZZZfrontZ = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

#ifdef SERV_EVE_BATTLE_SERAPH
		m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Finger2Nub", vDamageEffectPos,
			vZeroYDirVector, 5000.f, 0.108f, 0.5f, L"", L"", L"", true, 2.f );
#else
		m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Finger2Nub", vDamageEffectPos, vZeroYDirVector, 5000.f, 0.108f, 0.5f, L"", L"", true, 2.f );
#endif
	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.4f && m_pXSkinAnim->GetNowAnimationTime() < 1.23333f )
	{
		if( m_bNotEnoughMPZZZfrontZLaser == false && FlushMp(13.3333f * m_fElapsedTime ) == false )
		{
			m_EveElectraSystem.DeleteLaserFromSystem();
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger2Nub" );

			CreateNotEnoughMPEffect( vBonePos, 0.f, 0.f, 0.f );
			m_bNotEnoughMPZZZfrontZLaser = true;
		}
	}

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CX2DamageEffect::CEffect* pEffectElectraLaserZZZfrontZ = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffectElectraLaserZZZfrontZ ) )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	if ( CX2DamageEffect::CEffect* pEffectElectraLaserZZZfrontZ = g_pX2Game->GetDamageEffect()->IsLiveInstance( m_EffectElectraLaserZZZfrontZ ) ? m_EffectElectraLaserZZZfrontZ : NULL )
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	{
		if( m_pXSkinAnim->GetNowAnimationTime() >= 0.4f && m_pXSkinAnim->GetNowAnimationTime() < 1.0f )
		{
			if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffectElectraLaserZZZfrontZ->GetMainEffect() )
			{
				D3DXVECTOR3 vRotateLocalDegree = pMeshInstance->GetRotateLocalDegree();
				vRotateLocalDegree.z += (78.3f * m_fElapsedTime);
				pMeshInstance->SetRotateLocalDegree(vRotateLocalDegree);
			}

			m_EveElectraSystem.m_fLaserEndOffsetY = 15.f;
			m_EveElectraSystem.m_fLaserEndOffsetX = -8.f;
		}
		else
		{
			m_EveElectraSystem.m_fLaserEndOffsetY = 0.f;
			m_EveElectraSystem.m_fLaserEndOffsetX = 0.f;
		}
	}

	CommonFrameMove();
}


void CX2GUEve::ENSI_EPR_COMBO_ZZZfrontZ_EventProcess()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.3666f )
	{
		if( m_InputData.pureUp == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
		}
		else if( m_InputData.pureDown == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
		}
	}
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
		if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{	
			StateChange( USI_WAIT );
		}

		CommonEventProcess();
}

void CX2GUEve::ENSI_EPR_COMBO_ZZZfrontZ_End()
{
	m_EveElectraSystem.DeleteLaserFromSystem();
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectElectraLaserZZZfrontZ = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectElectraLaserZZZfrontZ = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

	m_EveElectraSystem.m_fLaserEndOffsetX = 0.f;
	m_EveElectraSystem.m_fLaserEndOffsetY = 0.f;
	CommonStateEnd();
}

void CX2GUEve::ENSI_EPR_COMBO_XXZ_Start()
{
	CommonStateStart();
	m_bXXZLaserEnd = false;
	m_bNotEnoughMPXXZLaser = false;
	m_fPlaneZAngle	= 0.f;
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectElectraLaserXXZ = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectElectraLaserXXZ = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	SetNoDetonation(true);

	m_EveElectraSystem.m_fLaserEndOffsetX = 0.f;
	m_EveElectraSystem.m_fLaserEndOffsetY = 0.f;
}

void CX2GUEve::ENSI_EPR_COMBO_XXZ_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.02f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.02f ) == true && EventCheck( 0.02f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( m_fPlaneZAngle, 2.4f, 220.f, 130.f );
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.m_fPlaneZAngle = m_fPlaneZAngle;
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.23333f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.23333f ) == true && EventCheck( 0.23333f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{

		D3DXVECTOR3 vDamageEffectPos = GetPos();
		vDamageEffectPos.y += 130.f;
		D3DXVECTOR3 vZeroYDirVector = GetDirVector();
		vZeroYDirVector.y = 0.f;
		D3DXVec3Normalize( &vZeroYDirVector, &vZeroYDirVector );


		if(GetIsRight() == false)
		{
			vZeroYDirVector.x = -vZeroYDirVector.x;
			vZeroYDirVector.z = -vZeroYDirVector.z;
		}
		vDamageEffectPos += (130.f * vZeroYDirVector);

		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_COMBO_XXZ_LASER", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        m_hEffectElectraLaserXXZ = pEffect->GetHandle();
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
		m_EffectElectraLaserXXZ = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

#ifdef SERV_EVE_BATTLE_SERAPH
		m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Finger2", vDamageEffectPos, vZeroYDirVector, 5000.f, 0.108f, 0.5f,
			L"EVE_COMBO_XXZ_LASER_NEXT", L"EVE_COMBO_XXZ_LASER_NEXT", L"EVE_COMBO_XXZ_LASER_NEXT", true, 2.f );
#else
		m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Finger2", vDamageEffectPos, vZeroYDirVector, 5000.f, 0.108f, 0.5f,
			L"EVE_COMBO_XXZ_LASER_NEXT", L"EVE_COMBO_XXZ_LASER_NEXT", true, 2.f );
#endif
	}

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CX2DamageEffect::CEffect* pEffectElectraLaserXXZ = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffectElectraLaserXXZ ) )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	if ( CX2DamageEffect::CEffect* pEffectElectraLaserXXZ = g_pX2Game->GetDamageEffect()->IsLiveInstance( m_EffectElectraLaserXXZ ) ? m_EffectElectraLaserXXZ : NULL )
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	{
		if( m_pXSkinAnim->GetNowAnimationTime() >= 0.83333f && m_pXSkinAnim->GetNowAnimationTime() < 1.93333f )
		{
			if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstanceLaserXXZ = pEffectElectraLaserXXZ->GetMainEffect() )
			{
				D3DXVECTOR3 vRotateLocalDegree = pMeshInstanceLaserXXZ->GetRotateLocalDegree();
				vRotateLocalDegree.z += (41.904f * m_fElapsedTime);
				pMeshInstanceLaserXXZ->SetRotateLocalDegree(vRotateLocalDegree);
				m_EveElectraSystem.m_fLaserEndOffsetY = 2.f;
			}
		}
		else
		{
			m_EveElectraSystem.m_fLaserEndOffsetY = 0.f;
		}
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 1.76666f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 1.76666f ) == true && EventCheck( 1.76666f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_bXXZLaserEnd = true;
		g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EVE_COMBO_XXZ_END", this );
	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.23333f && m_pXSkinAnim->GetNowAnimationTime() < 1.8666f )
	{
		if( m_bNotEnoughMPXXZLaser == false && FlushMp(13.3333f * m_fElapsedTime) == false )
		{
			m_EveElectraSystem.DeleteLaserFromSystem();
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger2Nub" );

			CreateNotEnoughMPEffect( vBonePos, 0.f, 0.f, 0.f );
			m_bNotEnoughMPXXZLaser = true;
		}
	}


	CommonFrameMove();
}

void CX2GUEve::ENSI_EPR_COMBO_XXZ_EventProcess()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.3f )
	{
		if( m_InputData.pureUp == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
		}
		else if( m_InputData.pureDown == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
		}
	}
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	if( m_InputData.pureZ == false )
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.9f )
		{
			StateChange( USI_WAIT );
		}
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
		if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
		{	
			StateChange( USI_WAIT );
		}

		CommonEventProcess();
}

void CX2GUEve::ENSI_EPR_COMBO_XXZ_End()
{
	m_EveElectraSystem.DeleteLaserFromSystem();
	if( m_bXXZLaserEnd == false )
		g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EVE_COMBO_XXZ_END", this );
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectElectraLaserXXZ = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectElectraLaserXXZ = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	SetNoDetonation(false);

	m_EveElectraSystem.m_fLaserEndOffsetX = 0.f;
	m_EveElectraSystem.m_fLaserEndOffsetY = 0.f;
	CommonStateEnd();
}


void CX2GUEve::ENSI_EPR_DASH_COMBO_ZZ_Init()
{
#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	XSkinMeshReadyInBackground( L"Eve_AT_DashComboZ2_mesh.X" );
#else	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	XSkinMeshReady( L"Eve_AT_DashComboZ2_mesh.X" );
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
}

void CX2GUEve::ENSI_EPR_DASH_COMBO_ZZ_StartFuture()
{
	CommonStateStartFuture();
}

void CX2GUEve::ENSI_EPR_DASH_COMBO_ZZ_Start()
{
	CommonStateStart();

	D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
	CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"EvePurityDashComboZBladeLoopEnd", vBonePos, GetRotateDegree(), GetRotateDegree() );
	if( NULL != pMeshInst )
	{
		m_hElectraDashComboZMesh = pMeshInst->GetHandle();
	}
#ifdef EVE_ELECTRA
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectElectraDashComboZZ = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectElectraDashComboZZ = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
#endif EVE_ELECTRA
}

void CX2GUEve::ENSI_EPR_DASH_COMBO_ZZ_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}
	ELSE_IF_STATE_CHANGE_ON_EX_( 0, m_fEventTime[0].keyInputStart, m_fEventTime[0].keyInputEnd, m_fEventTime[0].stateChange, m_InputData.oneZ == true, ENSI_EPR_DASH_COMBO_ZZZ )
		SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )

		CommonEventProcess();
}

void CX2GUEve::ENSI_EPR_DASH_COMBO_ZZ_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.2f ) == true && EventCheck( 0.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        m_hEffectElectraDashComboZZ = g_pX2Game->GetDamageEffect()->CreateInstanceHandle( 
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
		m_EffectElectraDashComboZZ = g_pX2Game->GetDamageEffect()->CreateInstance( 
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
            this, L"EVE_PR_DASH_COMBO_ZZ", GetPowerRate(), vBonePos, GetRotateDegree(), GetRotateDegree() );

	}

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if( CX2DamageEffect::CEffect* pEffectElectraDashComboZZ = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffectElectraDashComboZZ ) )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	if( CX2DamageEffect::CEffect* pEffectElectraDashComboZZ = g_pX2Game->GetDamageEffect()->IsLiveInstance( m_EffectElectraDashComboZZ ) ? m_EffectElectraDashComboZZ : NULL )
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    {
        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffectElectraDashComboZZ->GetMainEffect() )
	    {
		    D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );
		    pMeshInstance->SetPos( vBonePos );
	    }
    }

	CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->GetMeshInstance( m_hElectraDashComboZMesh );
	if( NULL != pMeshInst )
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
		pMeshInst->SetPos( vBonePos );
	}


	CommonFrameMove();
}

void CX2GUEve::ENSI_EPR_DASH_COMBO_ZZ_End()
{
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( m_hEffectElectraDashComboZZ != INVALID_DAMAGE_EFFECT_HANDLE )
        g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_hEffectElectraDashComboZZ );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	g_pX2Game->GetDamageEffect()->DestroyInstance( m_EffectElectraDashComboZZ );
    m_EffectElectraDashComboZZ = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	g_pX2Game->GetMajorXMeshPlayer()->DestroyInstanceHandle( m_hElectraDashComboZMesh );
	CommonStateEnd();
}



void CX2GUEve::ENSI_EPR_DASH_COMBO_ZZZ_Init()
{
	//XSkinMeshReady( L"Eve_AT_DashComboZ2_mesh.X" );
}

void CX2GUEve::ENSI_EPR_DASH_COMBO_ZZZ_StartFuture()
{
	CommonStateStartFuture();
	m_bDisableGravity = true;
}
void CX2GUEve::ENSI_EPR_DASH_COMBO_ZZZ_Start()
{
	CommonStateStart();

	m_bNotEnoughMPDashZZZ = false;

	D3DXVECTOR3 vBonePosL = GetBonePos( L"Dummy2_Lhand" );
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectElectraDashComboZ = g_pX2Game->GetDamageEffect()->CreateInstanceHandle( 
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectElectraDashComboZ = g_pX2Game->GetDamageEffect()->CreateInstance( 
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        this, L"EVE_PR_DASH_COMBO_ZZZ_L", GetPowerRate(), vBonePosL, GetRotateDegree(), GetRotateDegree() );

	D3DXVECTOR3 vBonePosR = GetBonePos( L"Dummy1_Rhand" );
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectElectraDashComboZZ = g_pX2Game->GetDamageEffect()->CreateInstanceHandle( 
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectElectraDashComboZZ = g_pX2Game->GetDamageEffect()->CreateInstance( 
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        this, L"EVE_PR_DASH_COMBO_ZZZ_R", GetPowerRate(), vBonePosR, GetRotateDegree(), GetRotateDegree() );

	m_fBlinkInvisibilityAlpha	= 1.f;
	m_bBlinkInvisibility		= true;

	SetAlphaObject( true );
	m_RenderParam.bAlphaBlend = true;
}

void CX2GUEve::ENSI_EPR_DASH_COMBO_ZZZ_EventProcess()
{

	if( false == IsOnSomethingFuture() )
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.6f )
		{
			StateChange( USI_JUMP_DOWN );
		}
	}
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )

		CommonEventProcess();
}

void CX2GUEve::ENSI_EPR_DASH_COMBO_ZZZ_FrameMove()
{
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CX2DamageEffect::CEffect* pEffectElectraDashComboZ = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffectElectraDashComboZ ) )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	if ( CX2DamageEffect::CEffect* pEffectElectraDashComboZ = g_pX2Game->GetDamageEffect()->IsLiveInstance( m_EffectElectraDashComboZ ) ? m_EffectElectraDashComboZ : NULL )
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    {
        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffectElectraDashComboZ->GetMainEffect() )
	    {
		    D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
		    pMeshInstance->SetPos( vBonePos );
        }
	}

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CX2DamageEffect::CEffect* pEffectElectraDashComboZZ = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffectElectraDashComboZZ ) )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	if ( CX2DamageEffect::CEffect* pEffectElectraDashComboZZ = g_pX2Game->GetDamageEffect()->IsLiveInstance( m_EffectElectraDashComboZZ ) ? m_EffectElectraDashComboZZ : NULL )
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	{
		if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffectElectraDashComboZZ->GetMainEffect() )
        {
		    D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy1_Rhand" );
		    pMeshInstance->SetPos( vBonePos );
        }
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.43333f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.43333f ) == true && EventCheck( 0.43333f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		m_bNotEnoughMPDashZZZ == false )
	{
		if( FlushMp( 10.f ) == false )
		{
			m_bNotEnoughMPDashZZZ = true;
		}
		else
		{
			D3DXVECTOR3 vDamageEffectPos = GetBonePos( L"Dummy2_Lhand" );
			vDamageEffectPos.y += 0.f;
			CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_PR_DASH_COMBO_ZZZ_EXPLOSION", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
            if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
			    pMeshInstance->SetGlobalTime( 0.2f);
		}
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.46666f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.46666f ) == true && EventCheck( 0.46666f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		m_bNotEnoughMPDashZZZ == false )
	{
		D3DXVECTOR3 vDamageEffectPos = GetBonePos( L"Dummy1_Rhand" );
		vDamageEffectPos.y += 20.f;
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_PR_DASH_COMBO_ZZZ_EXPLOSION", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
		    pMeshInstance->SetGlobalTime( 0.16666f);

	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.5f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.5f ) == true && EventCheck( 0.5f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		m_bNotEnoughMPDashZZZ == false )
	{
		D3DXVECTOR3 vDamageEffectPos = GetBonePos( L"Dummy2_Lhand" );
		vDamageEffectPos.y += -40.f;
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_PR_DASH_COMBO_ZZZ_EXPLOSION", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
		    pMeshInstance->SetGlobalTime( 0.13333f);

	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.53333f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.53333f ) == true && EventCheck( 0.53333f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if( m_bNotEnoughMPDashZZZ == true )
		{
			D3DXVECTOR3 vBonePosR = GetBonePos( L"Dummy2_Lhand" );

			vBonePosR.y += 30.f;
			CreateNotEnoughMPEffect( vBonePosR, 0.f, 180.f, 0.f );
		}
		else
		{
			D3DXVECTOR3 vDamageEffectPos = GetBonePos( L"Dummy1_Rhand" );
			vDamageEffectPos.y += 10.f;
			CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_PR_DASH_COMBO_ZZZ_EXPLOSION", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
            if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
			    pMeshInstance->SetGlobalTime( 0.1f);
		}
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.56666f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.56666f ) == true && EventCheck( 0.56666f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		m_bNotEnoughMPDashZZZ == false )
	{
		D3DXVECTOR3 vDamageEffectPos = GetBonePos( L"Dummy2_Lhand" );
		vDamageEffectPos.y += -20.f;
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_PR_DASH_COMBO_ZZZ_EXPLOSION", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
		    pMeshInstance->SetGlobalTime( 0.06666f);
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.6f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.6f ) == true && EventCheck( 0.6f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		m_bNotEnoughMPDashZZZ == false )
	{
		D3DXVECTOR3 vDamageEffectPos = GetBonePos( L"Dummy1_Rhand" );
		vDamageEffectPos.y += 40.f;
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_PR_DASH_COMBO_ZZZ_EXPLOSION", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect() )
		    pMeshInstance->SetGlobalTime( 0.03333f);
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.6333f ) &&
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.6333f ) == true && EventCheck( 0.63333f, false ) == true &&
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
		m_bNotEnoughMPDashZZZ == false )
	{
		D3DXVECTOR3 vDamageEffectPos = GetBonePos( L"Dummy2_Lhand" );
		vDamageEffectPos.y += 10.f;
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_PR_DASH_COMBO_ZZZ_EXPLOSION", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.2f && m_pXSkinAnim->GetNowAnimationTime() < 0.43333f)
	{
		m_fBlinkInvisibilityAlpha -= m_fElapsedTime * 20.f;
		if( m_fBlinkInvisibilityAlpha < 0.3333f )
			m_fBlinkInvisibilityAlpha = 0.3333f;
	}
	else if( m_pXSkinAnim->GetNowAnimationTime() > 0.43333f )
	{
		m_fBlinkInvisibilityAlpha += m_fElapsedTime * 20.f;
		if( m_fBlinkInvisibilityAlpha > 1.f )
			m_fBlinkInvisibilityAlpha = 1.f;
	}

	CommonFrameMove();
}


void CX2GUEve::ENSI_EPR_DASH_COMBO_ZZZ_EndFuture()
{
	m_bDisableGravity = false;
	CommonStateEndFuture();
}

void CX2GUEve::ENSI_EPR_DASH_COMBO_ZZZ_End()
{
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( m_hEffectElectraDashComboZ != INVALID_DAMAGE_EFFECT_HANDLE )
	    g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_hEffectElectraDashComboZ );
    if ( m_hEffectElectraDashComboZZ != INVALID_DAMAGE_EFFECT_HANDLE )
    	g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_hEffectElectraDashComboZZ );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	g_pX2Game->GetDamageEffect()->DestroyInstance( m_EffectElectraDashComboZ );
	g_pX2Game->GetDamageEffect()->DestroyInstance( m_EffectElectraDashComboZZ );
    m_EffectElectraDashComboZ = NULL;
    m_EffectElectraDashComboZZ = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	CommonStateEnd();

	m_bBlinkInvisibility			= false;

	if( m_bInvisibility == false )
	{
		SetAlphaObject( false );
		m_RenderParam.bAlphaBlend = false;
		m_RenderParam.outLineColor.a	= 1.f;
		m_RenderParam.color.a			= 1.f;
	}
}




void CX2GUEve::ENSI_A_EVE_PHOTON_BLINK_Init()
{
	//XSkinMeshReady( L"Eve_EP_SI_SA_Spit_Fire_Mesh01.X" );
	//XSkinMeshReady( L"Eve_EP_SI_SA_Spit_Fire_Mesh02.X" );
	//XMeshReady( L"Wind_Liner02.Y" );
	//TextureReady( L"GuideArrow02.tga" );
	//TextureReady( L"ColorBallGray.tga" );
}


void CX2GUEve::ENSI_A_EVE_PHOTON_BLINK_Start()
{
	CommonStateStart();

	m_fPhotonBlinkBackSpeedX = 0.f;
	m_fPhotonBlinkDummyLifeTime = 0.f;
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet(CX2SkillTree::SI_A_EN_PHOTON_BLINK);
#else //UPGRADE_SKILL_SYSTEM_2013
	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EVE_PHOTON_BLINK );
#endif //UPGRADE_SKILL_SYSTEM_2013
	if( NULL != pSkillTemplet )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		if ( NULL == GetUnit() )
			return;

		const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

		const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( CX2SkillTree::SI_A_EN_PHOTON_BLINK ) );	/// 스킬 레벨

		m_fPhotonBlinkBackSpeedX	= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_TELEPORT_RANGE_ABS, iSkillTempletLevel );
		m_fPhotonBlinkDummyLifeTime = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillTempletLevel );
	#else // UPGRADE_SKILL_UI
		m_fPhotonBlinkBackSpeedX	= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_TELEPORT_RANGE_ABS );
		m_fPhotonBlinkDummyLifeTime = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME );
	#endif // UPGRADE_SKILL_UI
	}

	m_fBlinkInvisibilityAlpha	= 1.f;
	m_bBlinkInvisibility		= true;

	SetAlphaObject( true );
	m_RenderParam.bAlphaBlend = true;
}

void CX2GUEve::ENSI_A_EVE_PHOTON_BLINK_StartFuture()
{
	CommonStateStartFuture();
	m_bDisableGravity = true;
}

void CX2GUEve::ENSI_A_EVE_PHOTON_BLINK_FrameMoveFuture()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnimFuture->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnimFuture->EventTimer( 0.1f ) == true && EventCheck( 0.1f, true ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_PhysicParam.nowSpeed.x = -m_fPhotonBlinkBackSpeedX;
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnimFuture->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnimFuture->EventTimer( 0.4f ) == true && EventCheck( 0.4f, true ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_PhysicParam.nowSpeed.x = -300.f;
	}
	CommonFrameMoveFuture();
}

void CX2GUEve::ENSI_A_EVE_PHOTON_BLINK_FrameMove()
{

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_PHOTON_BLINK_DUMMY", GetPowerRate(), 
			GetPos(), GetRotateDegree(), GetRotateDegree() );
		if( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = ( pEffect != NULL ) ? pEffect->GetMainEffect() : NULL )
		{
			pMeshInstance->SetMaxLifeTime( m_fPhotonBlinkDummyLifeTime );
		}
	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.03f && m_pXSkinAnim->GetNowAnimationTime() < 0.3f)
	{
		m_fBlinkInvisibilityAlpha -= m_fElapsedTime * 10.f;
		if( m_fBlinkInvisibilityAlpha < 0.f )
			m_fBlinkInvisibilityAlpha = 0.f;
	}
	else if( m_pXSkinAnim->GetNowAnimationTime() > 0.3f && m_pXSkinAnim->GetNowAnimationTime() < 0.8f )
	{
		m_fBlinkInvisibilityAlpha += m_fElapsedTime * 5.f;
		if( m_fBlinkInvisibilityAlpha > 1.f )
			m_fBlinkInvisibilityAlpha = 1.f;
	}
	CommonFrameMove();
}

void CX2GUEve::ENSI_A_EVE_PHOTON_BLINK_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.7f )
		{
			StateChange( USI_JUMP_DOWN );
		}
	}
	else if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( USI_WAIT );
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_A_EVE_PHOTON_BLINK_EndFuture()
{
	CommonStateEndFuture();
	m_bDisableGravity = false;
	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );
}

void CX2GUEve::ENSI_A_EVE_PHOTON_BLINK_End()
{
	CommonStateEnd();

	m_bBlinkInvisibility			= false;

	if( m_bInvisibility == false )
	{
		SetAlphaObject( false );
		m_RenderParam.bAlphaBlend = false;
		m_RenderParam.outLineColor.a	= 1.f;
		m_RenderParam.color.a			= 1.f;
	}
}

void CX2GUEve::ENSI_A_EPR_SPECTRO_EL_CRYSTAL_Init()
{
	//XSkinMeshReady( L"Eve_EP_SI_SA_Spit_Fire_Mesh01.X" );
	//XSkinMeshReady( L"Eve_EP_SI_SA_Spit_Fire_Mesh02.X" );
	//XMeshReady( L"Wind_Liner02.Y" );
	//TextureReady( L"GuideArrow02.tga" );
	//TextureReady( L"ColorBallGray.tga" );
}

void CX2GUEve::ENSI_A_EPR_SPECTRO_EL_CRYSTAL_Start()
{
	CommonStateStart();
	StartElCrystalSystem();
}

void CX2GUEve::ENSI_A_EPR_SPECTRO_EL_CRYSTAL_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.5f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.5f ) == true && EventCheck( 0.5f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if( m_EveElectraSystem.GetEnableSystem() == true )
		{
			m_EveElectraSystem.StartFormationEffect();	
			g_pX2Game->GetDamageEffect()->CreateInstance( this, L"SPECTRO_EL_CRYSTAL_COMBO_DAMAGE", GetPowerRate(), GetBonePos(L"Bip01"), GetRotateDegree(), GetRotateDegree() );
		}
	}
	CommonFrameMove();
}
void CX2GUEve::ENSI_A_EPR_SPECTRO_EL_CRYSTAL_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
	WALK_CANCEL_AFTER( m_fWalkCancelAfter )
	DASH_CANCEL_AFTER( m_fDashCancelAfter )
	CommonEventProcess();
}

void CX2GUEve::ENSI_SA_EPR_PARTICLE_RAY_Init()
{
	//TextureReady( L"Nasod_King_Laser03.tga" );
}
void CX2GUEve::ENSI_SA_EPR_PARTICLE_RAY_Start()
{
	CommonStateStart();
	m_fPlaneZAngle	= 0.f;
}
void CX2GUEve::ENSI_SA_EPR_PARTICLE_RAY_StartFuture()
{
	CommonStateStartFuture();
	m_bApplyMotionOffset = false;
}
void CX2GUEve::ENSI_SA_EPR_PARTICLE_RAY_FrameMoveFuture()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnimFuture->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnimFuture->EventTimer( 0.01f ) == true && EventCheck( 0.01f, true ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_PhysicParam.nowSpeed.x = 0.f;
	}
	CommonFrameMoveFuture();
}

void CX2GUEve::ENSI_SA_EPR_PARTICLE_RAY_EventProcess()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.4f )
	{
		if( m_InputData.pureUp == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
		}
		else if( m_InputData.pureDown == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
		}
	}

	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )

		CommonEventProcess();
}

void CX2GUEve::ENSI_SA_EPR_PARTICLE_RAY_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy1_Rhand", 0.01f, 0 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.02f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.02f ) == true && EventCheck( 0.02f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( m_fPlaneZAngle, 2.4f, 160.f, 130.f );
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.m_fPlaneZAngle = m_fPlaneZAngle;
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.43333f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.43333f ) == true && EventCheck( 0.43333f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{

		D3DXVECTOR3 vDamageEffectPos = GetPos();
		vDamageEffectPos.y += 130.f;
		D3DXVECTOR3 vZeroYDirVector = GetDirVector();
		vZeroYDirVector.y = 0.f;
		D3DXVec3Normalize( &vZeroYDirVector, &vZeroYDirVector );


		if(GetIsRight() == false)
		{
			vZeroYDirVector.x = -vZeroYDirVector.x;
			vZeroYDirVector.z = -vZeroYDirVector.z;
		}
		vDamageEffectPos += (100.f * vZeroYDirVector);

		CX2DamageEffect::CEffect* pEffect = NULL;
		if( GetRemainHyperModeTime() > 0.f )
		{
#ifdef ADDITIONAL_MEMO
#ifdef SERV_EVE_BATTLE_SERAPH
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO14 ) == true )
			{
				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_MEMO", GetPowerRate(),
					vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

				m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.12f, 1.0f, 
					L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_NEXT_MEMO", L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_NEXT_MEMO",
					L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_NEXT_MEMO", false );
			}
			else
			{
				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_PARTICLE_RAY_LASER_HYPER", GetPowerRate(),
					vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

				m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.12f, 1.0f, 
					L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_NEXT", L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_NEXT",
					L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_NEXT", false );
			}
#else
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO14 ) == true )
			{
				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_MEMO", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
				m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.12f, 1.0f, 
					L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_NEXT_MEMO", L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_NEXT_MEMO", false );
			}
			else
			{
				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_PARTICLE_RAY_LASER_HYPER", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
				m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.12f, 1.0f, 
					L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_NEXT", L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_NEXT", false );
			}
#endif
#else
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_PARTICLE_RAY_LASER_HYPER", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
			m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.12f, 1.0f, 
				L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_NEXT", L"EVE_EPR_PARTICLE_RAY_LASER_HYPER_NEXT", false );
#endif
		}
		else
		{
#ifdef ADDITIONAL_MEMO
#ifdef SERV_EVE_BATTLE_SERAPH
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO14 ) == true )
			{
				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_PARTICLE_RAY_LASER_MEMO", GetPowerRate(),
					vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

				m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.12f, 1.0f, 
					L"EVE_EPR_PARTICLE_RAY_LASER_NEXT_MEMO", L"EVE_EPR_PARTICLE_RAY_LASER_NEXT_MEMO",
					L"EVE_EPR_PARTICLE_RAY_LASER_NEXT_MEMO", false );
			}
			else
			{
				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_PARTICLE_RAY_LASER", GetPowerRate(),
					vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

				m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.12f, 1.0f, 
					L"EVE_EPR_PARTICLE_RAY_LASER_NEXT", L"EVE_EPR_PARTICLE_RAY_LASER_NEXT",
					L"EVE_EPR_PARTICLE_RAY_LASER_NEXT", false );
			}
#else
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO14 ) == true )
			{
				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_PARTICLE_RAY_LASER_MEMO", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
				m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.12f, 1.0f, 
					L"EVE_EPR_PARTICLE_RAY_LASER_NEXT_MEMO", L"EVE_EPR_PARTICLE_RAY_LASER_NEXT_MEMO", false );
			}
			else
			{
				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_PARTICLE_RAY_LASER", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
				m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.12f, 1.0f, 
					L"EVE_EPR_PARTICLE_RAY_LASER_NEXT", L"EVE_EPR_PARTICLE_RAY_LASER_NEXT", false );
			}
#endif
#else
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_PARTICLE_RAY_LASER", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
			m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.12f, 1.0f, 
				L"EVE_EPR_PARTICLE_RAY_LASER_NEXT", L"EVE_EPR_PARTICLE_RAY_LASER_NEXT", false );
#endif
		}
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EPR_PARTICLE_RAY_End()
{
	CommonStateEnd();
	m_EveElectraSystem.DeleteLaserFromSystem();
}


void CX2GUEve::ENSI_SA_EPR_PHOTON_FLARE_Init()
{
	XMeshReadyInBackground( L"eve_SA_photonFlare_lightLine.Y" );
	TextureReadyInBackground( L"eve_SA_photonFlare_lightLine.tga" );
	TextureReadyInBackground( L"WhitePoint.tga" );
	TextureReadyInBackground( L"Explosion_Sphere.tga" );
	TextureReadyInBackground( L"AeroTornado04.tga" );
	TextureReadyInBackground( L"Particle_Blur.tga" );
	TextureReadyInBackground( L"WhiteCircle02.tga" );
	TextureReadyInBackground( L"CenterLight_Gray01.tga" );
}
void CX2GUEve::ENSI_SA_EPR_PHOTON_FLARE_StateStart()
{
	CommonStateStart();

	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );

}

void CX2GUEve::ENSI_SA_EPR_PHOTON_FLARE_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy1_Rhand", 0.01f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.99f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.99f ) == true && EventCheck( 0.99f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		const float fBasicEffectRange = 600.f;
		float fEffectRange = 0.f;
		float fEffectiveTime = 0.f;
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_SA_EEL_PHOTON_FLARE );
		if( NULL != pSkillTemplet )
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			if ( NULL == GetUnit() )
				return;

			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( CX2SkillTree::SI_SA_EEL_PHOTON_FLARE ) );	/// 스킬 레벨

			if( GetRemainHyperModeTime() > 0.f )
			{
				fEffectRange = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SCOPE_ABS_HYPER, iSkillTempletLevel );
				fEffectiveTime = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME_HYPER, iSkillTempletLevel );
			}
			else
			{
				fEffectRange = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SCOPE_ABS, iSkillTempletLevel );
				fEffectiveTime = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillTempletLevel );
			}
	#else // UPGRADE_SKILL_UI
			if( GetRemainHyperModeTime() > 0.f )
			{
				fEffectRange = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SCOPE_ABS_HYPER );
				fEffectiveTime = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME_HYPER );
			}
			else
			{
				fEffectRange = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_SCOPE_ABS );
				fEffectiveTime = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME );
			}
	#endif // UPGRADE_SKILL_UI
		}

		D3DXVECTOR3 vDamageEffectPos = GetBonePos( L"Bip01_Spine" );

		if( IsMyUnit() == true )
			g_pX2Game->GetMajorParticle()->CreateSequence( NULL,  L"WhiteOut", D3DXVECTOR3(0,0,0) );

		CX2DamageEffect::CEffect* pEffectDamage = NULL;

		if( GetRemainHyperModeTime() > 0.f )
			pEffectDamage = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_PHOTON_FLARE_HYPER", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
		else
			pEffectDamage = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_PHOTON_FLARE", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );


		float fEffectScale = fEffectRange / fBasicEffectRange;
		pEffectDamage->SetScale( D3DXVECTOR3( fEffectScale, fEffectScale, fEffectScale ));
		pEffectDamage->GetDamageData().m_ExtraDamage.m_fTime = fEffectiveTime;
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EPR_PHOTON_FLARE_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 1.7f )
		{
			StateChange( USI_JUMP_DOWN );
		}
	}
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_SA_EPR_PHOTON_FLARE_StateEnd()
{
	m_bDisableGravity = false;
	CommonStateEnd();
} 


void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_READY_Init()
{
	XMeshReadyInBackground( L"eve_SA_photonFlare_lightLine.Y" );
	TextureReadyInBackground( L"eve_SA_photonFlare_lightLine.tga" );
	TextureReadyInBackground( L"WhitePoint.tga" );
	TextureReadyInBackground( L"Explosion_Sphere.tga" );
	TextureReadyInBackground( L"AeroTornado04.tga" );
	TextureReadyInBackground( L"Particle_Blur.tga" );
	TextureReadyInBackground( L"WhiteCircle02.tga" );
	TextureReadyInBackground( L"CenterLight_Gray01.tga" );
}
void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_READY_Start()
{
	CommonStateStart();
	m_fPlaneZAngle = 0.f;
}

//////// READY ///////////
void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_READY_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy1_Rhand", 0.01f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( 0.f, 7.0f, 340.f, 130.f, L"EveProtoPuritySweepParadePlane" );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_READY_EventProcess()
{
	if( m_InputData.pureUp == true )
	{
		m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
	}
	else if( m_InputData.pureDown == true )
	{
		m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
	}
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( ENSI_SA_EPR_SWEEP_ROLLING_CHARGE );
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_READY_End()
{
	CommonStateEnd();
}


//////// CHARGE ///////////
void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_CHARGE_Start()
{
	CommonStateStart();
	D3DXVECTOR3 vDamageEffectPos = GetBonePos( L"Bip01_R_Hand" );

	if(GetIsRight() == true)
		vDamageEffectPos += (150.f * GetDirVector() );
	else
		vDamageEffectPos -= (150.f * GetDirVector() );

    CX2DamageEffect::CEffect* pEffectSweepParadeTriangle;
#ifdef ADDITIONAL_MEMO
	if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO15 ) == true )
		pEffectSweepParadeTriangle = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_SWEEP_PARADE_TRIANGLE_MEMO", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
	else
		pEffectSweepParadeTriangle = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_SWEEP_PARADE_TRIANGLE", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
#else
	pEffectSweepParadeTriangle = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_SWEEP_PARADE_TRIANGLE", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
#endif
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectSweepParadeTriangle = pEffectSweepParadeTriangle->GetHandle();
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_EffectSweepParadeTriangle = pEffectSweepParadeTriangle;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

	m_EveElectraSystem.AddEffectToSystem( pEffectSweepParadeTriangle );
    if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffectSweepParadeTriangle->GetMainEffect() )
	    pMeshInstance->SetVelocity( D3DXVECTOR3( 0.f, 0.f, 0.f ) );

#ifdef VERIFY_STAT_BY_BUFF
	m_vInitScaleByUnitSweepParade	= GetVec3ScaleByUnit();
#else	// VERIFY_STAT_BY_BUFF
	m_vInitScaleByUnitSweepParade	= GetScaleByUnit();
#endif // VERIFY_STAT_BY_BUFF

#ifdef ADDITIONAL_MEMO
	if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO15 ) == true )
		m_vInitScaleByUnitSweepParade *= 1.2f;
#endif

	m_fSweepParadeTriangleLIfeTime	= m_FrameDataNow.unitCondition.fStateTime;
	m_fInitDamageSweepParade		= pEffectSweepParadeTriangle->GetDamageData().damage.fMagic;

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectSweepParadeElectric		= g_pX2Game->GetDamageEffect()->CreateInstanceHandle( 
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectSweepParadeElectric		= g_pX2Game->GetDamageEffect()->CreateInstance( 
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        this, L"EVE_SWEEP_PARADE_ELECTRIC", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectSweepParadeLight		= g_pX2Game->GetDamageEffect()->CreateInstanceHandle( 
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectSweepParadeLight		= g_pX2Game->GetDamageEffect()->CreateInstance( 
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        this, L"EVE_SWEEP_PARADE_LIGHT", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

	m_FrameDataNow.stateParam.bSuperArmorNotRed = false;
}

void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_CHARGE_FrameMove()
{	
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CX2DamageEffect::CEffect* pEffectSweepParadeTriangle = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffectSweepParadeTriangle ) )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CX2DamageEffect::CEffect* pEffectSweepParadeTriangle = g_pX2Game->GetDamageEffect()->IsLiveInstance( m_EffectSweepParadeTriangle ) ? m_EffectSweepParadeTriangle : NULL )
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	{
		float fScaleEffect = (1.f + m_FrameDataNow.unitCondition.fStateTime * 0.16667f) * m_vInitScaleByUnitSweepParade.x;
		pEffectSweepParadeTriangle->SetScaleByUnit( D3DXVECTOR3( fScaleEffect, fScaleEffect, fScaleEffect ) );

#ifdef BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
		// 수치 변경 : 0.06667f -> 0.075
		float fScaleDamage = (1.f + m_FrameDataNow.unitCondition.fStateTime * 0.075f);
#else // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
		float fScaleDamage = (1.f + m_FrameDataNow.unitCondition.fStateTime * 0.06667f);
#endif // BALANCE_PATCH_20131107					// 김종훈 / 13-10-16, 2013년 후반기 밸런스 개편
		pEffectSweepParadeTriangle->GetDamageData().damage.fMagic = m_fInitDamageSweepParade * fScaleDamage;

		m_fSweepParadeTriangleLIfeTime = m_FrameDataNow.unitCondition.fStateTime; 

		float fScaleEffectElectric	= (1.f + m_FrameDataNow.unitCondition.fStateTime * 0.15f) * m_vInitScaleByUnitSweepParade.x;
		float fScaleEffectLight		= (1.f + m_FrameDataNow.unitCondition.fStateTime * 0.1f) * m_vInitScaleByUnitSweepParade.x;

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        if ( CX2DamageEffect::CEffect* pEffectSweepParadeElectric = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffectSweepParadeElectric ) )
            pEffectSweepParadeElectric->SetScaleByUnit( D3DXVECTOR3( fScaleEffectElectric, fScaleEffectElectric, fScaleEffectElectric ) );
        if ( CX2DamageEffect::CEffect* pEffectSweepParadeLight = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffectSweepParadeLight ) )
            pEffectSweepParadeLight->SetScaleByUnit( D3DXVECTOR3( fScaleEffectLight, fScaleEffectLight, fScaleEffectLight ) );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
		m_EffectSweepParadeElectric->SetScaleByUnit( D3DXVECTOR3( fScaleEffectElectric, fScaleEffectElectric, fScaleEffectElectric ) );
		m_EffectSweepParadeLight->SetScaleByUnit( D3DXVECTOR3( fScaleEffectLight, fScaleEffectLight, fScaleEffectLight ) );
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE


		D3DXVECTOR3 vDamageEffectPos = GetBonePos( L"Bip01_R_Hand" );

		if(GetIsRight() == true)
			vDamageEffectPos += (150.f * GetDirVector() );
		else
			vDamageEffectPos -= (150.f * GetDirVector() );
		pEffectSweepParadeTriangle->SetPos( vDamageEffectPos );
	}
	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_CHARGE_EventProcess()
{
#ifdef ADDITIONAL_MEMO
	float fFireTime = 5.f;
	if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO15 ) == true )
		fFireTime = 5.5f;
#endif
	if( m_InputData.pureUp == true )
	{
		m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
	}
	else if( m_InputData.pureDown == true )
	{
		m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
	}

	if( m_eSpecialAttackKeyPressed == SAKP_A && m_InputData.pureA != true ||
		m_eSpecialAttackKeyPressed == SAKP_S && m_InputData.pureS != true ||
		m_eSpecialAttackKeyPressed == SAKP_D && m_InputData.pureD != true ||
		m_eSpecialAttackKeyPressed == SAKP_C && m_InputData.pureC != true 
		|| m_eSpecialAttackKeyPressed == SAKP_Q && m_InputData.pureQ != true 
		|| m_eSpecialAttackKeyPressed == SAKP_W && m_InputData.pureW != true 
		|| m_eSpecialAttackKeyPressed == SAKP_E && m_InputData.pureE != true 
		|| m_eSpecialAttackKeyPressed == SAKP_R && m_InputData.pureR != true 
		)
	{
		StateChange( ENSI_SA_EPR_SWEEP_ROLLING_FIRE );
	}
#ifdef ADDITIONAL_MEMO
	else if( EventTimer( fFireTime, true ) == true )
	{
		StateChange( ENSI_SA_EPR_SWEEP_ROLLING_END );
	}
#else
	else if( EventTimer( 5.0f, true ) == true )
	{
		StateChange( ENSI_SA_EPR_SWEEP_ROLLING_END );
	}
#endif

	CommonEventProcess();
}

void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_CHARGE_End()
{
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( m_hEffectSweepParadeLight != INVALID_DAMAGE_EFFECT_HANDLE )
        g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_hEffectSweepParadeLight );
    if ( m_hEffectSweepParadeElectric != INVALID_DAMAGE_EFFECT_HANDLE )
        g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_hEffectSweepParadeElectric );
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	if( m_EffectSweepParadeLight != NULL )
		g_pX2Game->GetDamageEffect()->DestroyInstance( m_EffectSweepParadeLight );
	if( m_EffectSweepParadeElectric != NULL )
		g_pX2Game->GetDamageEffect()->DestroyInstance( m_EffectSweepParadeElectric );
    m_EffectSweepParadeLight = NULL;
    m_EffectSweepParadeElectric = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	CommonStateEnd();
	m_FrameDataNow.stateParam.bSuperArmorNotRed = true;
}

//////// FIRE ///////////
void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_FIRE_Start()
{
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CX2DamageEffect::CEffect* pEffectSweepParadeTriangle = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffectSweepParadeTriangle ) )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CX2DamageEffect::CEffect* pEffectSweepParadeTriangle = g_pX2Game->GetDamageEffect()->IsLiveInstance( m_EffectSweepParadeTriangle ) ? m_EffectSweepParadeTriangle : NULL )
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    {
        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffectSweepParadeTriangle->GetMainEffect() )
	    {
    #ifdef ADDITIONAL_MEMO
		    if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO15 ) == true )
		    {
			    pMeshInstance->SetMaxLifeTime( 5.6f );
		    }
		    else
		    {
			    pMeshInstance->SetMaxLifeTime( 5.1f );
		    }
    #else		
		    pMeshInstance->SetMaxLifeTime( 5.1f );
    #endif
		    pMeshInstance->SetVelocity( D3DXVECTOR3( 400.f, 0.f, 0.f ) );
		    pMeshInstance->SetNowLifeTime( m_fSweepParadeTriangleLIfeTime );
		    pEffectSweepParadeTriangle->GetDamageData().reActType = CX2DamageManager::RT_BIG_DAMAGE;

    #ifndef SERV_EVE_BATTLE_SERAPH
		    pEffectSweepParadeTriangle->GetDamageData().backSpeed.y	= 525.f;
		    pEffectSweepParadeTriangle->GetDamageData().bArrangedFly	= true;
    #endif
	    }
    }
	CommonStateStart();
}

void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_FIRE_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.01f ) == true && EventCheck( 0.01f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.m_fPlaneZAngle = m_fPlaneZAngle;
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_FIRE_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
		CommonEventProcess();
}

void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_FIRE_End()
{
	CommonStateEnd();
}

//////// END ///////////
void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_END_Start()
{
	CommonStateStart();
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CX2DamageEffect::CEffect* pEffectSweepParadeTriangle = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffectSweepParadeTriangle ) )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if ( CX2DamageEffect::CEffect* pEffectSweepParadeTriangle = g_pX2Game->GetDamageEffect()->IsLiveInstance( m_pEffectSweepParadeTriangle ) ? m_pEffectSweepParadeTriangle : NULL )
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
#ifdef SWEEP_ROLLING_END_NULL_CHECK
	{
        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffectSweepParadeTriangle->GetMainEffect() )
		{
			pMeshInstance->SetMaxLifeTime( 5.1f );
			pMeshInstance->SetNowLifeTime( 5.0f );
			pEffectSweepParadeTriangle->GetDamageData().reActType = CX2DamageManager::RT_FLY;
			pEffectSweepParadeTriangle->GetDamageData().backSpeed.x = 1500.f;
			pEffectSweepParadeTriangle->GetDamageData().backSpeed.y = 1500.f;
			pEffectSweepParadeTriangle->GetDamageData().hitUnitList.clear();
			pEffectSweepParadeTriangle->GetDamageData().bReAttack = false;
		}
	}	
#else
	{
        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffectSweepParadeTriangle->GetMainEffect() )
		{
		    pMeshInstance->SetMaxLifeTime( 5.1f );
		    pMeshInstance->SetNowLifeTime( 5.0f );
        }
		pEffectSweepParadeTriangle->GetDamageData().reActType = CX2DamageManager::RT_FLY;
		pEffectSweepParadeTriangle->GetDamageData().backSpeed.x = 1500.f;
		pEffectSweepParadeTriangle->GetDamageData().backSpeed.y = 1500.f;
		pEffectSweepParadeTriangle->GetDamageData().hitUnitList.clear();
		pEffectSweepParadeTriangle->GetDamageData().bReAttack = false;
	}
#endif //SWEEP_ROLLING_END_NULL_CHECK
}

void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_END_FrameMove()
{
	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_END_EventProcess()
{
	if( EventTimer( 1.0f, true ) == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_SA_EPR_SWEEP_ROLLING_END_End()
{
	CommonStateEnd();
}



void CX2GUEve::ENSI_SA_EPR_THOUSANDS_OF_STARS_Init()
{

}

void CX2GUEve::ENSI_SA_EPR_THOUSANDS_OF_STARS_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy1_Rhand", 0.01f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CreateThousandStar();
		m_fThousandStarPowerRate = GetPowerRate();
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"THOUSANDS_OF_STARS_COMBO_DAMAGE", m_fThousandStarPowerRate, GetBonePos(L"Bip01"), GetRotateDegree(), GetRotateDegree() );

		if ( IsMyUnit() )
			g_pX2Game->UpdateSkillSlotUI();
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 1.93333f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 1.93333f ) == true && EventCheck( 1.93333f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		ChangeThousandsOfStarsFormation();
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EPR_THOUSANDS_OF_STARS_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )

		CommonEventProcess();
}



void CX2GUEve::ENSI_SA_EPR_GIGA_STREAM_Init()
{
	//TextureReady( L"Nasod_King_Laser03.tga" );
}
void CX2GUEve::ENSI_SA_EPR_GIGA_STREAM_Start()
{
	CommonStateStart();
	m_fPlaneZAngle	= 0.f;
}

void CX2GUEve::ENSI_SA_EPR_GIGA_STREAM_StartFuture()
{
	CommonStateStartFuture();
	m_bApplyMotionOffset = false;
}

void CX2GUEve::ENSI_SA_EPR_GIGA_STREAM_EventProcess()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.4f )
	{
		if( m_InputData.pureUp == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
		}
		else if( m_InputData.pureDown == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
		}
	}

	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
		BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
		WALK_CANCEL_AFTER( m_fWalkCancelAfter )
		DASH_CANCEL_AFTER( m_fDashCancelAfter )
		CommonEventProcess();
}

void CX2GUEve::ENSI_SA_EPR_GIGA_STREAM_FrameMoveFuture()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnimFuture->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnimFuture->EventTimer( 0.01f ) == true && EventCheck( 0.01f, true ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_PhysicParam.nowSpeed.x = 0.f;
	}
	CommonFrameMoveFuture();
}

void CX2GUEve::ENSI_SA_EPR_GIGA_STREAM_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy1_Rhand", 0.01f, 0 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.02f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.02f ) == true && EventCheck( 0.02f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( 0.f, 3.0f, 110.f, 130.f );
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.m_fPlaneZAngle = m_fPlaneZAngle;
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.5f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.5f ) == true && EventCheck( 0.5f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if( m_fPlaneZAngle > 0 && m_EveElectraSystem.GetEnablePlane() == true )
			m_EveElectraSystem.CreateGigaPlane( m_fPlaneZAngle, 2.5f, 110.f + 120.f, 130.f + 69.24f );
		//m_EveElectraSystem.CreateGigaPlane( m_fPlaneZAngle, 3.0f, 110.f + 100.f, 130.f + 57.7f );
		else if( m_fPlaneZAngle < 0 && m_EveElectraSystem.GetEnablePlane() == true )
			m_EveElectraSystem.CreateGigaPlane( m_fPlaneZAngle, 2.5f, 110.f + 120.f, 130.f - 69.24f );
		//m_EveElectraSystem.CreateGigaPlane( m_fPlaneZAngle, 3.0f, 110.f + 100.f, 130.f - 57.7f );
		else
			m_EveElectraSystem.CreateGigaPlane( m_fPlaneZAngle, 2.5f, 110.f + 139.56f, 130.f );
		//m_EveElectraSystem.CreateGigaPlane( m_fPlaneZAngle, 3.0f, 110.f + 116.3f, 130.f );
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.9f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.9f ) == true && EventCheck( 0.9f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{

		D3DXVECTOR3 vDamageEffectPos = GetPos();
		vDamageEffectPos.y += 130.f;
		D3DXVECTOR3 vZeroYDirVector = GetDirVector();
		vZeroYDirVector.y = 0.f;
		D3DXVec3Normalize( &vZeroYDirVector, &vZeroYDirVector );


		if(GetIsRight() == false)
		{
			vZeroYDirVector.x = -vZeroYDirVector.x;
			vZeroYDirVector.z = -vZeroYDirVector.z;
		}
		vDamageEffectPos += (100.f * vZeroYDirVector);

		CX2DamageEffect::CEffect* pEffect = NULL;

#ifdef SERV_EVE_BATTLE_SERAPH
		if( GetRemainHyperModeTime() > 0.f )
		{
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_GIGA_STREAM_LASER_HYPER", GetPowerRate(),
				vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

			m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.3f, 1.0f, 
				L"EVE_EPR_GIGA_STREAM_LASER_HYPER_NEXT", L"EVE_EPR_GIGA_STREAM_LASER_HYPER_NEXT",
				L"EVE_EPR_GIGA_STREAM_LASER_HYPER_NEXT", false );
		}
		else
		{
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_GIGA_STREAM_LASER", GetPowerRate(),
				vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

			m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.3f, 1.0f, 
				L"EVE_EPR_GIGA_STREAM_LASER_NEXT", L"EVE_EPR_GIGA_STREAM_LASER_NEXT",
				L"EVE_EPR_GIGA_STREAM_LASER_NEXT", false );
		}
#else
		if( GetRemainHyperModeTime() > 0.f )
		{
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_GIGA_STREAM_LASER_HYPER", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
			m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.3f, 1.0f, 
				L"EVE_EPR_GIGA_STREAM_LASER_HYPER_NEXT", L"EVE_EPR_GIGA_STREAM_LASER_HYPER_NEXT", false );
		}
		else
		{
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_GIGA_STREAM_LASER", GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
			m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.3f, 1.0f, 
				L"EVE_EPR_GIGA_STREAM_LASER_NEXT", L"EVE_EPR_GIGA_STREAM_LASER_NEXT", false );
		}
#endif
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EPR_GIGA_STREAM_End()
{
	CommonStateEnd();
	m_EveElectraSystem.DeleteLaserFromSystem();
}
#endif EVE_ELECTRA

void CX2GUEve::DeleteMinorParticle()
{
	CX2GUUser::DeleteMinorParticle();

	DeleteEveMinorParticle();
}

/** @function : HyperModeBuffEffectStart
@brief : 각성 시 나와야하는 이펙트들 시작
*/
/*virtual*/ void CX2GUEve::HyperModeBuffEffectStart()
{
	CX2GUUser::HyperModeBuffEffectStart();

	if ( INVALID_PARTICLE_SEQUENCE_HANDLE == m_hHyperBoostRFoot )
		m_hHyperBoostRFoot = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"HyperBoostRightEve",		0, 0, 0, 0, 0);

	if ( INVALID_PARTICLE_SEQUENCE_HANDLE == m_hHyperBoostLFoot )
		m_hHyperBoostLFoot = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"HyperBoostLeftEve",		0, 0, 0, 0, 0);

	if ( INVALID_PARTICLE_SEQUENCE_HANDLE == m_hHyperBoostRArm )
		m_hHyperBoostRArm = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"HyperBoostRightEve",		0, 0, 0, 0, 0);

	if ( INVALID_PARTICLE_SEQUENCE_HANDLE == m_hHyperBoostLArm )
		m_hHyperBoostLArm = g_pX2Game->GetMinorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"HyperBoostLeftEve",		0, 0, 0, 0, 0);

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
	// 각성 시 기동 게이지 값 세팅
	m_fManeuverGauge = min( m_fManeuverGauge + 40.0f, 100.0f );	
#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어
}

/** @function : GetAdditionalAccelBuffTime
@brief : 엑셀레이터류 버프의 추가시간을 얻어오는 함수
@param : 어떤 엑셀레이터가 발동됐는지에 대한 스킬아이디(eSkillID_)
@return : 추가시간(float)
*/
/*virtual*/ float CX2GUEve::GetAdditionalAccelBuffTime( const CX2SkillTree::SKILL_ID eSkillID_ ) const
{
	float fAdditionalAccelBuffTime = 0.0f;

	/// 엑조틱, 격려의 기운
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	const int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_COMMON_SUPPORT_AURA, true );
#else // UPGRADE_SKILL_SYSTEM_2013
	const int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_COMMON_SUPPORT_AURA );
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if ( iSkillLevel > 0 )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_COMMON_SUPPORT_AURA );
		if( NULL != pSkillTemplet )
		{
			fAdditionalAccelBuffTime += pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillLevel );
		}
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_COMMON_SUPPORT_AURA, iSkillLevel );
		if( NULL != pSkillTemplet )
		{
			fAdditionalAccelBuffTime += pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME );
		}
	#endif // UPGRADE_SKILL_SYSTEM_2013
	}

	return fAdditionalAccelBuffTime;
}

/** @function : ApplyAuraAcceleratorBuffToGameUnit
@brief : 액셀러레이터버프를 특정 범위내의 유닛에게 적용, 이브는 부가적인 효과 처리를 위해 overriding
@param : 앨셀러레이터스킬템플릿(pSkillTemplet_), 외부요인(fAddtionalAccelBuffTime_)
*/
/*virtual*/ void CX2GUEve::ApplyAuraAcceleratorBuffToGameUnit( const CX2SkillTree::SkillTemplet* pSkillTemplet_, const float fAddtionalAccelBuffTime_, const D3DXVECTOR3& vMyPos_ )
{
	CX2BuffFactorPtr ptrEnergyOfConcentrationFactor
		= GetEnergyOfConcentrationBuffFactorClonePtr();

	/// 집중의 기운을 안배웠으면
	if ( NULL == ptrEnergyOfConcentrationFactor )
		CX2GUUser::ApplyAuraAcceleratorBuffToGameUnit( pSkillTemplet_, fAddtionalAccelBuffTime_, vMyPos_ );
	else	/// 집중의 기운을 배웠으면
	{
		if ( false == pSkillTemplet_->m_vecBuffFactorPtr.empty() )
		{
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
			if ( NULL == GetUnit() )
				return;

			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet_->m_eID ) );	/// 스킬 레벨

			CX2BuffFactorPtr ptrBuffFactorClone = pSkillTemplet_->m_vecBuffFactorPtr[0]->GetClonePtr( iSkillTempletLevel );		
#else //UPGRADE_SKILL_SYSTEM_2013
			CX2BuffFactorPtr ptrBuffFactorClone = pSkillTemplet_->m_vecBuffFactorPtr[0]->GetClonePtr();
#endif //UPGRADE_SKILL_SYSTEM_2013
			if ( NULL != ptrBuffFactorClone )
			{
				ptrBuffFactorClone->SetGameUnitBuffFactor( this );
				ptrBuffFactorClone->ApplyExternalFactorToFinalizer( BFT_TIME, fAddtionalAccelBuffTime_ );

				ptrEnergyOfConcentrationFactor->SetGameUnitBuffFactor( this );	/// 집중의 기운 버프팩터 셋팅

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경

				if ( NULL == GetUnit() )
					return;

				const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

				const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet_->m_eID ) );	/// 스킬 레벨

				ptrEnergyOfConcentrationFactor->ApplyExternalFactorToFinalizer( BFT_TIME, /// 액셀러레이터시간 + fAddtionalAccelBuffTime 만큼 지속
					pSkillTemplet_->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillTempletLevel ) 
					+ fAddtionalAccelBuffTime_ );
	#else // UPGRADE_SKILL_UI
				ptrEnergyOfConcentrationFactor->ApplyExternalFactorToFinalizer( BFT_TIME, /// 액셀러레이터시간 + fAddtionalAccelBuffTime 만큼 지속
					pSkillTemplet_->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME ) 
					+ fAddtionalAccelBuffTime_ );
	#endif // UPGRADE_SKILL_UI

				const WCHAR* pwsCoreParticleName = CX2SkillTree::GetAccelCoreParticleName( pSkillTemplet_->m_eID );	
				ASSERT( NULL != pwsCoreParticleName );

				for ( int i = 0; i < g_pX2Game->GetUnitNum(); i++ )
				{
					CX2GameUnit* pGameUnit = g_pX2Game->GetUnit( i );
					if( pGameUnit != NULL && 
						pGameUnit->GetTeam() == GetTeam() && pGameUnit->GetGameUnitType() == GUT_USER && 
						GetDistance3Sq( vMyPos_, pGameUnit->GetPos() ) < 490000.f &&
						pGameUnit->CanApplyBuffToGameUnit() )	/// 거리 제한, 같은 팀
					{
						if ( g_pX2Game->GetGameType() == CX2Game::GT_PVP || pGameUnit->GetUnitUID() == GetUnitUID() ||
							( NULL != g_pData && NULL != g_pData->GetPartyManager() && true == g_pData->GetPartyManager()->IsMyPartyMember( pGameUnit->GetUnitUID() ) ) )
						{
							if ( pGameUnit->SetBuffFactorToGameUnit( *ptrBuffFactorClone ) && /// 액셀러레이터
								pGameUnit->SetBuffFactorToGameUnit( *ptrEnergyOfConcentrationFactor ) )	/// 집중의기운
							{
								D3DXVECTOR3 vGameUnitPos = pGameUnit->GetPos();
								vGameUnitPos.y += 100.0f;
								g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  pwsCoreParticleName, vGameUnitPos );
							}
						}
					}
				}	// for
			}
		}
	}
}

/** @function : GetEnergyOfConcentrationBuffFactorClonePtr
@brief : 집중의기운(네메) 패시브 스킬이 가지고 있는 버프팩터를 얻어오는 함수
@param : 사용한 액셀러레이터스킬 ID(eSkillIdAccelerator_)
@return : 집중의기운을 배우지 않았으면 빈 스마트포인터 리턴
*/
CX2BuffFactorPtr CX2GUEve::GetEnergyOfConcentrationBuffFactorClonePtr() const
{
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	const int iSkillLevelEnergyOfConcentration = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_ENS_ENERGY_OF_CONCENTRATION, true );
#else // UPGRADE_SKILL_SYSTEM_2013
	const int iSkillLevelEnergyOfConcentration = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_ENS_ENERGY_OF_CONCENTRATION );
#endif // UPGRADE_SKILL_SYSTEM_2013
	
	if( iSkillLevelEnergyOfConcentration > 0 )
	{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		const CX2SkillTree::SkillTemplet* pSkillTempletEnergyOfConcentration 
			= g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_ENS_ENERGY_OF_CONCENTRATION );
	#else // UPGRADE_SKILL_SYSTEM_2013
		const CX2SkillTree::SkillTemplet* pSkillTempletEnergyOfConcentration 
			= g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_ENS_ENERGY_OF_CONCENTRATION, iSkillLevelEnergyOfConcentration );
	#endif // UPGRADE_SKILL_SYSTEM_2013
		if ( NULL != pSkillTempletEnergyOfConcentration &&
			false == pSkillTempletEnergyOfConcentration->m_vecBuffFactorPtr.empty() )
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
			return pSkillTempletEnergyOfConcentration->m_vecBuffFactorPtr[0]->GetClonePtr( iSkillLevelEnergyOfConcentration );
#else //UPGRADE_SKILL_SYSTEM_2013
			return pSkillTempletEnergyOfConcentration->m_vecBuffFactorPtr[0]->GetClonePtr();
#endif //UPGRADE_SKILL_SYSTEM_2013
	}

	return CX2BuffFactorPtr();
}

/** @function : CX2GetActualMPConsume
@brief : 스킬의 MP 소모량을 얻어옴
@param : 스킬의 ID, 사용한 스킬의 레벨
@return : 소모될 MP 수치
*/
/*virtual*/ float CX2GUEve::GetActualMPConsume( const CX2SkillTree::SKILL_ID eSkillID_, const int iSkillLevel_ ) const
{
	float fMpConsumption = CX2GUUser::GetActualMPConsume( eSkillID_, iSkillLevel_ );

	switch ( eSkillID_ )
	{
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 공통 스킬 개편, 김종훈
	case CX2SkillTree::SI_SA_COMMON_AURA_CRITICAL_ACCEL:				
	case CX2SkillTree::SI_SA_COMMON_AURA_ADDATK_ACCEL:
#endif // UPGRADE_SKILL_SYSTEM_2013 // 공통 스킬 개편, 김종훈
	case CX2SkillTree::SI_SA_COMMON_AURA_POWER_ACCEL:
	case CX2SkillTree::SI_SA_COMMON_AURA_MAGIC_ACCEL:				
	case CX2SkillTree::SI_SA_COMMON_AURA_SHIELD_ACCEL:	
	case CX2SkillTree::SI_SA_COMMON_AURA_SPEED_ACCEL:
		{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			const int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_COMMON_SUPPORT_AURA, true );
	#else // UPGRADE_SKILL_SYSTEM_2013
			const int iSkillLevel = GetUnit()->GetUnitData().m_UserSkillTree.GetSkillLevel( CX2SkillTree::SI_P_COMMON_SUPPORT_AURA );
	#endif // UPGRADE_SKILL_SYSTEM_2013
			
			if ( iSkillLevel > 0 )
			{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
				const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_COMMON_SUPPORT_AURA );
				if( NULL != pSkillTemplet )
				{
					const float fAuraMpConsumptionMultiplier 
						= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_CONSUME_REL, iSkillLevel );

					fMpConsumption *= fAuraMpConsumptionMultiplier;
				}
	#else // UPGRADE_SKILL_SYSTEM_2013
				const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( CX2SkillTree::SI_P_COMMON_SUPPORT_AURA, iSkillLevel );
				if( NULL != pSkillTemplet )
				{
					const float fAuraMpConsumptionMultiplier 
						= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_MP_CONSUME_REL );

					fMpConsumption *= fAuraMpConsumptionMultiplier;
				}
	#endif // UPGRADE_SKILL_SYSTEM_2013
			}
		} break;

	case CX2SkillTree::SI_SA_EN_ILLUSION_STINGER:
		{
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO8 ) == true )
			{
				fMpConsumption -= 20.f;
			}
		} break;

#ifdef FINALITY_SKILL_SYSTEM //김창한
		/// 엠프레스 궁극기 - 링크 오버차지 썬더볼트 피니쉬 타격에는 엠피가 소모되지 않음.
	case CX2SkillTree::SI_HA_EEP_LINK_OVERCHARGE_ILLUSION: 
		{
			if( true == GetActiveLinkOverChargeIllusion() )
				fMpConsumption = 0.f;
		} break;
#endif //FINALITY_SKILL_SYSTEM
#ifdef ADD_MEMO_1ST_CLASS //김창한
	case CX2SkillTree::SI_SA_EEG_JUNK_BREAK:
		{
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO18 ) == true )
				fMpConsumption -= 30.f;
		} break;

	case CX2SkillTree::SI_SA_EAT_GENOCIDE_RIPPER:
		{
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO19 ) == true )
				fMpConsumption *= 0.9f;
		} break;

	case CX2SkillTree::SI_SA_EEL_PHOTON_FLARE:
		{
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO23 ) == true )
				fMpConsumption -= 20.f;
		} break;

	case CX2SkillTree::SI_SA_EEL_GIGA_STREAM:
		{
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO25 ) == true )
				fMpConsumption *= 0.9f;
		} break;
#endif //ADD_MEMO_1ST_CLASS
	default:
		break;
	}

	if ( 0.0f > fMpConsumption )
		fMpConsumption = 0.f;

#ifdef SERV_BALANCE_FINALITY_SKILL_EVENT	
	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( eSkillID_ );
	float fMpDecreaseRate = 1.0f;
	if( NULL != pSkillTemplet )
		fMpDecreaseRate  =  g_pData->GetMyUser()->GetSelectUnit()->GetSkillMpDecreaseRate(eSkillID_, pSkillTemplet->m_eType);

	return fMpConsumption * fMpDecreaseRate;
#else SERV_BALANCE_FINALITY_SKILL_EVENT
	return fMpConsumption;
#endif //SERV_BALANCE_FINALITY_SKILL_EVENT
}

/** @function : AddUnitSlashData
@brief : 유닛에 트레이스 붙이기 (실행은 아님)
@param : 트레이스 종류(eSlashTraceCondition_)
*/
/*virtual*/ void CX2GUEve::AddUnitSlashData( const CX2UnitSlashTraceManager::SLASH_TRACE_CONDITION eSlashTraceCondition_ )
{
#ifdef UNIT_SLASH_TRACE_MANAGER_TEST
	if( NULL == m_pUnitSlashTraceManager )
		m_pUnitSlashTraceManager = CX2UnitSlashTraceManager::CreateUnitSlashTraceManager( this, GetXSkinAnimPtr() );

	if( NULL != m_pUnitSlashTraceManager )
	{
		const int vertexNum = (IsMyUnit() ? 400 : 150);

		switch ( eSlashTraceCondition_ )
		{
		case CX2UnitSlashTraceManager::STC_NONE:
			{
				m_pUnitSlashTraceManager->AddSlashTraceData( L"Bip01_L_Finger2Nub", L"Bip01_L_Hand", 
					D3DXCOLOR(0xcc5555ff), D3DXCOLOR(0xccff3333), D3DXCOLOR(0, 0, 0, 0), D3DXCOLOR(0, 0, 0, 0),
					vertexNum, 0.4f, 1, 
					0, 0, 0,
					false, 0.f, L"" );


				m_pUnitSlashTraceManager->AddSlashTraceData( L"Bip01_R_Finger2Nub", L"Bip01_R_Hand", 
					D3DXCOLOR(0xcc5555ff), D3DXCOLOR(0xccff3333), D3DXCOLOR(0, 0, 0, 0), D3DXCOLOR(0, 0, 0, 0),
					vertexNum, 0.4f, 1, 
					0, 0, 0,
					false, 0.f, L"" );
			} break;

		default:
			break;
		}
	}
#endif UNIT_SLASH_TRACE_MANAGER_TEST	
}
#ifdef BALANCE_CODE_NEMESIS_20121213
/*virtual*/ void CX2GUEve::ModifyFinalDamageByGameUnitType( OUT CX2DamageManager::DAMAGE_TYPE& damageType_, OUT float& fAttackerPhysicDamage_, OUT float& fAttackerMagicDamage_ , OUT float& fForceDownValue_ )
{
	if ( GetUnitClass() == CX2Unit::UC_EVE_CODE_NEMESIS && false == DidHitNasodWeapon() )
	{
		if ( NULL != GetUnit() )
		{
			const CX2SkillTree::SkillTemplet* pSkillTemplet =
				GetUnit()->GetUnitData().m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_P_ENS_NASOD_WEAPON );

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			if ( NULL != pSkillTemplet )
			{
				if ( NULL == GetUnit() )
					return;

				const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

				const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID, true ) );	/// 스킬 레벨

				if ( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_RATE, iSkillTempletLevel ) > GetRandomFloat() )
				{
					damageType_		= CX2DamageManager::DT_MIX;
					fAttackerMagicDamage_	+= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_DAMAGE_REL, iSkillTempletLevel );	
					fAttackerPhysicDamage_	*= 2;
					fAttackerMagicDamage_	*= 2;
					SetHitNasodWeapon( true );
#ifdef BALANCE_CODE_NEMESIS_20121213
					fForceDownValue_ -= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FORCE_DOWN_ABS, iSkillTempletLevel );
#endif //BALANCE_CODE_NEMESIS_20121213
				}
			}
	#else // UPGRADE_SKILL_SYSTEM_2013
			if ( NULL != pSkillTemplet &&
				pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_RATE ) > GetRandomFloat() )
			{
				damageType_		= CX2DamageManager::DT_MIX;
				fAttackerMagicDamage_	+= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_DAMAGE_REL );	
				fAttackerPhysicDamage_	*= 2;
				fAttackerMagicDamage_	*= 2;
				SetHitNasodWeapon( true );
		#ifdef BALANCE_CODE_NEMESIS_20121213
				fForceDownValue_ -= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FORCE_DOWN_ABS );
		#endif //BALANCE_CODE_NEMESIS_20121213
			}
	#endif // UPGRADE_SKILL_SYSTEM_2013
		}
	}
}
#else
/*virtual*/ void CX2GUEve::ModifyFinalDamageByGameUnitType( OUT CX2DamageManager::DAMAGE_TYPE& damageType_, OUT float& fAttackerPhysicDamage_, OUT float& fAttackerMagicDamage_ )
{
	if ( GetUnitClass() == CX2Unit::UC_EVE_CODE_NEMESIS && false == DidHitNasodWeapon() )
	{
		if ( NULL != GetUnit() )
		{
			const CX2SkillTree::SkillTemplet* pSkillTemplet =
				GetUnit()->GetUnitData().m_UserSkillTree.GetUserSkillTemplet( CX2SkillTree::SI_P_ENS_NASOD_WEAPON );

			if ( NULL != pSkillTemplet &&
				pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_RATE ) > GetRandomFloat() )
			{
				damageType_		= CX2DamageManager::DT_MIX;
				fAttackerMagicDamage_	+= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_DAMAGE_REL );	
				fAttackerPhysicDamage_	*= 2;
				fAttackerMagicDamage_	*= 2;
				SetHitNasodWeapon( true );
#ifdef BALANCE_CODE_NEMESIS_20121213
				//m_DamageData.fForceDownValue = -pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FORCE_DOWN_ABS );
#endif //BALANCE_CODE_NEMESIS_20121213
			}
		}
	}
}
#endif //BALANCE_CODE_NEMESIS_20121213

/** @function : SetSpecificValueByBuffTempletID
@brief : 각 유닛마다 특정 버프가 실행 될 때 셋팅해야 하는 함수 실행(ex: 매지컬메이크업이 시전중이라는 플래그 설정 등...)
@param : 버프템플릿ID(eBuffTempletId_)
*/
/*virtual*/ void CX2GUEve::SetSpecificValueByBuffTempletID( const BUFF_TEMPLET_ID eBuffTempletId_ )
{
	CX2GUUser::SetSpecificValueByBuffTempletID( eBuffTempletId_ );

	switch ( eBuffTempletId_ )
	{
	case BTI_BUFF_AMPLIFICATION_PLACE:
		ChangePlaneForamtionSystem( PFT_AMPLIFIER );
		break;

	case BTI_BUFF_SPECTRUM_PLACE:
		ChangePlaneForamtionSystem( PFT_SPECTRUM );
		break;
		
	case BTI_BUFF_INDUCTION_PLACE:
		ChangePlaneForamtionSystem( PFT_INDUCTION );
		break;

#ifdef SERV_EVE_BATTLE_SERAPH		/// 초광학 연구
	case BTI_BUFF_SI_SA_EBS_ENERGETIC_HEART:
		{
		
			const CX2SkillTree::SkillTemplet* pSkillTemplet
				= GetEquippedActiveSkillTemplet( CX2SkillTree::SI_SA_EBS_ENERGETIC_HEART );
			
			if ( NULL != pSkillTemplet )
			{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
				if ( NULL == GetUnit() )
					return;

				const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

				const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨

				m_iAddBoostAttack = static_cast<int>( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_COUNT, iSkillTempletLevel ) );
	#else // UPGRADE_SKILL_UI
				m_iAddBoostAttack = static_cast<int>( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_COUNT ) );
	#endif // UPGRADE_SKILL_UI
			}
			
			m_EveElectraSystem.SetEnableSystem( true );
			m_EveElectraSystem.SetEnableExceptionSystem( true );
			m_EveElectraSystem.m_ePrevSpectro = m_EveElectraSystem.GetPlaneFormation();
			m_EveElectraSystem.SetPlaneFormation( PFT_FUSION );
			if ( IsMyUnit() )
				g_pX2Game->UpdateSkillSlotUI();
		} break;
#endif //SERV_EVE_BATTLE_SERAPH

	default:
		break;
	}
}

/** @function : UnSetSpecificValueByBuffTempletID
@brief : 각 유닛마다 특정 버프가 해제 될 때 셋팅해야 하는 함수 실행(ex: 매지컬메이크업이 해제 됬다는 플래그 설정 등...)
@param : 버프템플릿ID(eBuffTempletId_)
*/
/*virtual*/ void CX2GUEve::UnSetSpecificValueByBuffTempletID( const BUFF_TEMPLET_ID eBuffTempletId_ )
{
	CX2GUUser::UnSetSpecificValueByBuffTempletID( eBuffTempletId_ );

	switch ( eBuffTempletId_ )
	{
#ifdef FIX_EVE_ELCRYSTAL_BUG
	case BTI_BUFF_AMPLIFICATION_PLACE:
	case BTI_BUFF_SPECTRUM_PLACE:
	case BTI_BUFF_INDUCTION_PLACE:
	case BTI_BUFF_SI_SA_EBS_ENERGETIC_HEART:
		{			
			m_eReserveEndElCrystalBuffID = eBuffTempletId_;
			m_bIsCheckEndElCrystal = true;

			// 현재 진행 중인 역장에 반응하는 스킬을 체크하여, 반응 중이라면 역장 해제 시간을 미루기 
			if ( false == m_EveElectraSystem.m_EveElectraLaserDataList.empty() )
			{
				std::list< EveElectraLaserData >::iterator lit_Laser;
				for( lit_Laser = m_EveElectraSystem.m_EveElectraLaserDataList.begin(); lit_Laser != m_EveElectraSystem.m_EveElectraLaserDataList.end(); ++lit_Laser )
				{
					if( true == lit_Laser->m_bPenetrate )
					{
						m_bIsCheckEndElCrystal = false;
						break;
					}
				}
			}
		} break;
#else
	case BTI_BUFF_AMPLIFICATION_PLACE:
		{
			if ( PFT_AMPLIFIER == m_EveElectraSystem.GetPlaneFormation() )
				EndElCrystalSystem();
		} break;

	case BTI_BUFF_SPECTRUM_PLACE:
		{
			if ( PFT_SPECTRUM == m_EveElectraSystem.GetPlaneFormation() )
				EndElCrystalSystem();
		} break;

	case BTI_BUFF_INDUCTION_PLACE:
		{
			if ( PFT_INDUCTION == m_EveElectraSystem.GetPlaneFormation() )
				EndElCrystalSystem();
		} break;

#ifdef SERV_EVE_BATTLE_SERAPH		/// 초광학 연구
	case BTI_BUFF_SI_SA_EBS_ENERGETIC_HEART:
		{
			if ( PFT_FUSION == m_EveElectraSystem.GetPlaneFormation() )
			{
				m_EveElectraSystem.SetEnableExceptionSystem( false );
				const BUFF_TEMPLET_ID eBuffTempletID = 
					m_EveElectraSystem.GetBuffTempletIdByPlaneFormation( m_EveElectraSystem.m_ePrevSpectro );

				if ( BTI_NONE != eBuffTempletID )
				{
					if ( HaveThisBuff( eBuffTempletID ) )	/// 이전의 분광결정이 아직 끝나지 않았으면
					{		
						m_EveElectraSystem.SetPlaneFormation( m_EveElectraSystem.m_ePrevSpectro );
						
						if ( IsMyUnit() )
							g_pX2Game->UpdateSkillSlotUI();
					}
					else	/// 이전의 분광결정이 끝났으면
					{
						EndElCrystalSystem( true );
					}
				}
				else	/// 에너제틱 하트 이전에 진행 중인 역장이 없으면
				{
					EndElCrystalSystem( true );
				}

				g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Seraph_Energetic_Heart_End", this );
			}
			m_iAddBoostAttack = 0;
		} break;
#endif //SERV_EVE_BATTLE_SERAPH
#endif // FIX_EVE_ELCRYSTAL_BUG

	default:
		break;
	}
}


/** @function : ApplyRenderParam
	@brief : 버프에 의한 renderparam과 함께 추가적으로 해비스텐스에 대한 renderparam을 설정하는 함수
	@param : SkinAnim의 RenderParam 포인터(pRenderParam_)

*/
/*virtual*/ void CX2GUEve::ApplyRenderParam( CKTDGXRenderer::RenderParam* pRenderParam_ )
{
#ifdef RIDING_SYSTEM
	if ( m_bPassDash )
		return;
#endif //RIDING_SYSTEM

	if( true == m_bInvisibility )
	{
		if( 0.f == m_fInvisibilityAlpha )
		{
			// commonframemove에서 공격 상태가 아니라면 setshowobject(false) 되서 아예 렌더링이 되지 않는다.
			if( true == GetAbsoluteInvisibility() )
			{
				pRenderParam_->renderType		= CKTDGXRenderer::RT_CARTOON_COLOR_EDGE;
				pRenderParam_->outLineColor.a	= m_fInvisibilityAlpha;
				m_RenderParam.color.a			= m_fInvisibilityAlpha;
			}
			else
			{
				pRenderParam_->renderType		= CKTDGXRenderer::RT_CARTOON_BLACK_EDGE;
				pRenderParam_->outLineColor.a	= m_fInvisibilityAlpha;
				m_RenderParam.color.a			= m_fInvisibilityAlpha;
			}
		}
		else
		{
			pRenderParam_->renderType		= CKTDGXRenderer::RT_CARTOON_COLOR_EDGE;
			pRenderParam_->outLineColor.a	= m_fInvisibilityAlpha;
			m_RenderParam.color.a			= m_fInvisibilityAlpha;
		}
	}
#ifdef EVE_ELECTRA
	else if( true == m_bBlinkInvisibility )
	{
		pRenderParam_->renderType		= CKTDGXRenderer::RT_CARTOON_COLOR_EDGE;
		pRenderParam_->outLineColor.a	= m_fBlinkInvisibilityAlpha;
		m_RenderParam.color.a			= m_fBlinkInvisibilityAlpha;
	}
#endif EVE_ELECTRA
	else 
		CX2GameUnit::ApplyRenderParam( pRenderParam_ );
}

/*virtual*/ void CX2GUEve::ApplyRenderParamOnEmptyRenderParamByBuff( CKTDGXRenderer::RenderParam* pRenderParam_ )
{
	if( GetRemainHyperModeTime() > 0.0f )
	{
		pRenderParam_->renderType		= CKTDGXRenderer::RT_CARTOON_COLOR_EDGE;
		pRenderParam_->cartoonTexType	= CKTDGXRenderer::CTT_RED;
		pRenderParam_->outLineColor		= D3DXCOLOR( 1.f, 0.694f, 0.737f, 1.f );
	}
	else
	{
		pRenderParam_->renderType		= CKTDGXRenderer::RT_CARTOON_BLACK_EDGE;
		pRenderParam_->cartoonTexType	= CKTDGXRenderer::CTT_NORMAL;
		pRenderParam_->outLineColor		= 0xffffffff;
	}
}


/** @function : ChangePlaneForamtionSystem
	@brief : 포메이션을 변경 하는 함수
	@param : ePlaneFormatinoSystem_ (인자로 넘긴 이 포메이션이 아닌 경우 변경)
*/
void CX2GUEve::ChangePlaneForamtionSystem( const PlaneFormationType ePlaneFormatinoSystem_ )
{
#ifdef FIX_SPECTRO_EL_CRYSTAL_ACTIVE_BUG
	if ( true == IsMyUnit() && false == GetStartSpectroElCrystal() )		/// 만약 스킬을 눌러 시작하지 않고 버프로 인해 시작 되었을 때, 설정해야 할 값들 설정
	{
		SetStartSpectroElCrystal( true );		/// 분광결정이 스킬을 눌러 시작 되었는지, 버프로 시작 되었는지에 대한 여부

		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet(CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL);

		if( NULL != pSkillTemplet && NULL != GetUnit() )
		{
			CX2UserSkillTree& cUserSkillTree =  GetUnit()->AccessUnitData().m_UserSkillTree;

			float fAdditionalTime = 0.f;	/// 분광결정 종료시 계산할 추가 쿨타임

			/// 메모가 있는 경우 3초 증가
			if ( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO13) )
				fAdditionalTime = 3.0f;

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			const int iSkillTempletLevel = max( 1, cUserSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨

			/// 분광결정 버프가 끝난 후 쿨타임 셋팅을 위해 지속시간 저장
			m_EveElectraSystem.SetSystemOperationTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillTempletLevel ) + fAdditionalTime );
	#else // UPGRADE_SKILL_UI
			/// 분광결정 버프가 끝난 후 쿨타임 셋팅을 위해 지속시간 저장
			m_EveElectraSystem.SetSystemOperationTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME ) + fAdditionalTime );
	#endif // UPGRADE_SKILL_UI

			cUserSkillTree.SetSkillCoolTimeLeft( CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL, 0.f  );		/// 분광 결정 적용 중이니, 쿨타임 제거
		}

		m_EveElectraSystem.SetPlaneFormation( ePlaneFormatinoSystem_ );	/// 변경시킬 분광결정 타입으로 설정
	}
#endif FIX_SPECTRO_EL_CRYSTAL_ACTIVE_BUG

	m_EveElectraSystem.SetEnableSystem( true );
	if ( ePlaneFormatinoSystem_ != m_EveElectraSystem.GetPlaneFormation() )
		m_EveElectraSystem.ChangePlaneFormation();
	ChangeThousandsOfStarsFormation();
}

/** @function : StartElCrystalSystem 
@brief : 분광결정 스킬 사용시 실행되는 함수로 분광결정을 Enable 하거나, 역장을 변경한다.
*/
void CX2GUEve::StartElCrystalSystem()
{
#ifdef FIX_SPECTRO_EL_CRYSTAL_ACTIVE_BUG
	SetStartSpectroElCrystal( true );		/// 분광결정이 스킬을 눌러 시작 되었는지, 버프로 시작 되었는지에 대한 여부
#endif FIX_SPECTRO_EL_CRYSTAL_ACTIVE_BUG
	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet(CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL);

	if( NULL != pSkillTemplet )
	{
	    const CX2UserSkillTree& cUserSkillTree =  GetUnit()->GetUnitData().m_UserSkillTree;

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
		if ( NULL == GetUnit() )
			return;
	
		const int iSkillTempletLevel = max( 1, cUserSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	#endif // UPGRADE_SKILL_UI

		/// 분광결정을 사용 중이고, 분광장을 사용 할 수 있으면
		if( m_EveElectraSystem.GetEnableSystem() == true && 
			m_EveElectraSystem.GetEnableSpectrumDynamics() == true )
		{
			switch ( m_EveElectraSystem.GetPlaneFormation() )
			{
			case PFT_AMPLIFIER:	/// 기존의 분광결정이 증폭장인 경우
				{
					m_EveElectraSystem.ChangePlaneFormation();
					
					vector<CX2BuffFinalizerTempletPtr>	vecFinalizerPtr;
					GetBuffFinalizerTempletPtrList( BTI_BUFF_AMPLIFICATION_PLACE, vecFinalizerPtr );

					ASSERT( !vecFinalizerPtr.empty() );
					if ( !vecFinalizerPtr.empty() )
					{
						EraseBuffTempletFromGameUnit( BTI_BUFF_AMPLIFICATION_PLACE );	/// 증폭장 버프 삭제

						SetBuffFactorToGameUnit( pSkillTemplet, 1 );	/// 분광장 버프 적용
						ChangeBuffFinalizerTempletPtrList( BTI_BUFF_SPECTRUM_PLACE, vecFinalizerPtr );
					}
				} break;

			case PFT_SPECTRUM:	/// 기존의 분광결정이 분광장인 경우
				{
					m_EveElectraSystem.ChangePlaneFormation();					

					vector<CX2BuffFinalizerTempletPtr>	vecFinalizerPtr;
					GetBuffFinalizerTempletPtrList( BTI_BUFF_SPECTRUM_PLACE, vecFinalizerPtr );
					
					ASSERT( !vecFinalizerPtr.empty() );
					if ( !vecFinalizerPtr.empty() )
					{
						EraseBuffTempletFromGameUnit( BTI_BUFF_SPECTRUM_PLACE );	/// 분광장 버프 삭제
#ifdef SERV_EVE_BATTLE_SERAPH
						if ( m_EveElectraSystem.GetEnableHyperOpticalResearch() )	/// 반응장이 있는 경우
						{
							SetBuffFactorToGameUnit( pSkillTemplet, 2 );	/// 반응장 적용
							ChangeBuffFinalizerTempletPtrList( BTI_BUFF_INDUCTION_PLACE, vecFinalizerPtr );
						}
						else	/// 반응장을 배우지 않은 경우
						{
							SetBuffFactorToGameUnit( pSkillTemplet, 0 );	/// 증폭장 버프 적용
							ChangeBuffFinalizerTempletPtrList( BTI_BUFF_AMPLIFICATION_PLACE, vecFinalizerPtr );
						}
					}
#else	
						SetBuffFactorToGameUnit( pSkillTemplet, 0 );	/// 증폭장 버프 적용
						ChangeBuffFinalizerTempletPtrList( BTI_BUFF_AMPLIFICATION_PLACE, vecFinalizerPtr );
					}
#endif //SERV_EVE_BATTLE_SERAPH
				} break;

			case PFT_INDUCTION:	/// 반응장인 경우
				{
					m_EveElectraSystem.ChangePlaneFormation();

					vector<CX2BuffFinalizerTempletPtr>	vecFinalizerPtr;
					GetBuffFinalizerTempletPtrList( BTI_BUFF_INDUCTION_PLACE, vecFinalizerPtr );
					
					ASSERT( !vecFinalizerPtr.empty() );
					if ( !vecFinalizerPtr.empty() )
					{
						EraseBuffTempletFromGameUnit( BTI_BUFF_INDUCTION_PLACE );	/// 반응장 버프 삭제
						SetBuffFactorToGameUnit( pSkillTemplet, 0 );	/// 증폭장 버프 적용
						ChangeBuffFinalizerTempletPtrList( BTI_BUFF_AMPLIFICATION_PLACE, vecFinalizerPtr );
					}
				} break;

			default:
				ASSERT( !L"This PlaneFormation doesn't exist" );
				break;
			}			

			if ( IsMyUnit() )
				g_pX2Game->UpdateSkillSlotUI();
		}
		else if ( !m_EveElectraSystem.GetEnableSystem() )	/// 분광결정을 사용중이지 않으면
		{
			if ( CanApplyBuffToGameUnit() && false == pSkillTemplet->m_vecBuffFactorPtr.empty() )
			{
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
				CX2BuffFactorPtr ptrBuffFactorClone = pSkillTemplet->m_vecBuffFactorPtr[0]->GetClonePtr( iSkillTempletLevel );
#else //UPGRADE_SKILL_SYSTEM_2013
				CX2BuffFactorPtr ptrBuffFactorClone = pSkillTemplet->m_vecBuffFactorPtr[0]->GetClonePtr();
#endif //UPGRADE_SKILL_SYSTEM_2013
				if ( NULL != ptrBuffFactorClone )
				{
					ptrBuffFactorClone->SetGameUnitBuffFactor( this );	/// 엑셀러레이터 버프팩터 셋팅

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
					/// 메모가 있는 경우 3초 증가
					if ( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO13) )
					{
						const float fAdditionalTime = 3.0f;
						ptrBuffFactorClone->ApplyExternalFactorToFinalizer( BFT_TIME, fAdditionalTime );
						
						if ( m_fAddSpectrumTime > 0.f )
							ptrBuffFactorClone->ApplyExternalFactorToFinalizer( BFT_TIME, m_fAddSpectrumTime );

						/// 분광결정 버프가 끝난 후 CoolTime 셋팅을 위해 지속시간 저장
						m_EveElectraSystem.SetSystemOperationTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillTempletLevel ) + fAdditionalTime + m_fAddSpectrumTime );
					}
					else
					{
						if ( m_fAddSpectrumTime > 0.f )
							ptrBuffFactorClone->ApplyExternalFactorToFinalizer( BFT_TIME, m_fAddSpectrumTime );

						/// 분광결정 버프가 끝난 후 CoolTime 셋팅을 위해 지속시간 저장
						m_EveElectraSystem.SetSystemOperationTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillTempletLevel ) + m_fAddSpectrumTime );
					}
	#else // UPGRADE_SKILL_UI
					/// 메모가 있는 경우 3초 증가
					if ( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO13) )
					{
						const float fAdditionalTime = 3.0f;
						ptrBuffFactorClone->ApplyExternalFactorToFinalizer( BFT_TIME, fAdditionalTime );

						/// 분광결정 버프가 끝난 후 CoolTime 셋팅을 위해 지속시간 저장
						m_EveElectraSystem.SetSystemOperationTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME ) + fAdditionalTime );
					}
					else
						m_EveElectraSystem.SetSystemOperationTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME ) );	/// 분광결정 버프가 끝난 후 CoolTime 셋팅을 위해 지속시간 저장
	#endif // UPGRADE_SKILL_UI

					m_EveElectraSystem.SetPlaneFormation( PFT_AMPLIFIER );
					SetBuffFactorToGameUnit( *ptrBuffFactorClone );	/// 버프 적용

					if ( IsMyUnit() )
						g_pX2Game->UpdateSkillSlotUI();

#ifdef SERV_EVE_BATTLE_SERAPH
					if ( true == m_EveElectraSystem.GetEnableHyperOpticalResearch() )
						const_cast<CX2SkillTree::SkillTemplet*>(pSkillTemplet)->m_eActiveSkillUseCondtion = CX2SkillTree::ASUT_ANYTIME;
#endif
				}
			}			
		}
	}
}

/** @function : EndElCrystalSystem
@brief : 분광결정이 끝났을 때 실행되는 함수
*/
void CX2GUEve::EndElCrystalSystem( bool bEnergeticHeartEnd_/* = false */ ) 
{
	/// 분광결정이 끝나면 사우전드스타의 파티클을 원래대로 되돌림
	if( CX2DamageEffect::CEffect* pTSEffect = ( m_pThousandStar != NULL ) ? m_pThousandStar->GetLiveDamageEffect() : NULL )
	{
		g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleThousandStarFormation );
		m_EveElectraSystem.m_hParticleThousandStarFormation = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"eve_thousandsOfStars_model_P01", pTSEffect->GetPos() );
	}

	m_EveElectraSystem.DestroyFormationMarkAndMsgParticle();
	m_EveElectraSystem.DestroyPlaneAndCrystalEffect();

	m_EveElectraSystem.SetPlaneFormation( PFT_AMPLIFIER );	/// 초기화
	m_EveElectraSystem.SetEnableSystem( false );

	if ( IsMyUnit() )
	{
		/// 분광결정은 지속시간이 끝난 후 부터 쿨타임 표시가 되는데,
		/// 분광결정이 끝났을 때, 쿨타임-지속시간 만큼 표시 해줌(ex: 쿨타임 30초, 지속시간 25초 면 분광결정이 끝나고 쿨타임 5초로 셋팅)
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet(CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL);
		if( NULL != pSkillTemplet )
		{
#ifdef SERV_EVE_BATTLE_SERAPH
			if ( true == m_EveElectraSystem.GetEnableHyperOpticalResearch() )
				const_cast<CX2SkillTree::SkillTemplet*>(pSkillTemplet)->m_eActiveSkillUseCondtion = CX2SkillTree::ASUT_GROUND;
#endif
			if( bEnergeticHeartEnd_ == false )
			{
	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
				if ( NULL == GetUnit() )
					return;

		        CX2UserSkillTree& cUserSkillTree =  GetUnit()->AccessUnitData().m_UserSkillTree;

				const int iSkillTempletLevel = max( 1, cUserSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
				float fRemainCoolTime = pSkillTemplet->GetSkillCoolTimeValue( iSkillTempletLevel ) - m_EveElectraSystem.GetSystemOperationTime(); 
	#else // UPGRADE_SKILL_SYSTEM_2013

		        CX2UserSkillTree& cUserSkillTree =  GetUnit()->AccessUnitData().m_UserSkillTree;

				float fRemainCoolTime = pSkillTemplet->m_fSkillCoolTime - m_EveElectraSystem.GetSystemOperationTime(); 
	#endif // UPGRADE_SKILL_SYSTEM_2013
				
				if( fRemainCoolTime < 0.f )
					fRemainCoolTime = 0.f;

				cUserSkillTree.SetSkillCoolTimeLeft( CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL, fRemainCoolTime  );
			}
		}
		
		g_pX2Game->UpdateSkillSlotUI();
	}

	m_EveElectraSystem.SetSystemOperationTime( 0.0f );

#ifdef FIX_SPECTRO_EL_CRYSTAL_ACTIVE_BUG
	SetStartSpectroElCrystal( false );		/// 분광결정이 스킬을 눌러 시작 되었는지, 버프로 시작 되었는지에 대한 여부
#endif FIX_SPECTRO_EL_CRYSTAL_ACTIVE_BUG

}

/** @function : ChangeThousandsOfStarsFormation
@brief : 사우전드스타가 실행중일 때 분광결정이 시작되거나 역장이 변경되면 사우전드 스타의 이펙트가 변경되게 하는 함수
*/
void CX2GUEve::ChangeThousandsOfStarsFormation()
{
    if ( CX2DamageEffect::CEffect* pTSEffect = ( m_pThousandStar != NULL ) ? m_pThousandStar->GetLiveDamageEffect() : NULL )
	{
		g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleThousandStarFormation );

		if( GetEnableElectraSystem() == false )
		{
			m_EveElectraSystem.m_hParticleThousandStarFormation = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"eve_thousandsOfStars_model_P01", pTSEffect->GetPos() );
		}
		else if( m_EveElectraSystem.GetPlaneFormation() == PFT_AMPLIFIER )
		{
			m_EveElectraSystem.m_hParticleThousandStarFormation = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"eve_thousandsOfStars_model_P01_2_red", pTSEffect->GetPos() );
		}
		else if( m_EveElectraSystem.GetPlaneFormation() == PFT_SPECTRUM )
		{
			m_EveElectraSystem.m_hParticleThousandStarFormation = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"eve_thousandsOfStars_model_P01_3_blue",pTSEffect->GetPos() );
		}
#ifdef SERV_EVE_BATTLE_SERAPH
		else if( m_EveElectraSystem.GetPlaneFormation() == PFT_INDUCTION )
		{
			m_EveElectraSystem.m_hParticleThousandStarFormation = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( 
				(CKTDGObject*) this,  L"eve_thousandsOfStars_model_P01_4_green", pTSEffect->GetPos() );
		}
		else if( m_EveElectraSystem.GetPlaneFormation() == PFT_FUSION )
		{
			m_EveElectraSystem.m_hParticleThousandStarFormation = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( 
				(CKTDGObject*) this,  L"eve_thousandsOfStars_model_P01_5_white", pTSEffect->GetPos() );
		}
#endif
	}
}
#ifdef SERV_EVE_BATTLE_SERAPH
#pragma region 테이저 필라
bool CX2GUEve::IsUpSkillSlotTaserPilum()
{
	bool bIsTaserPilumSuccess = false;
	if( m_sTaserPilumData.m_bEnable == true )
	{
		//키가 업된는지 체크.
		switch( m_sTaserPilumData.GetSkillSlotID() )
		{
		case 0: if( m_InputData.pureA == false && m_InputData.oneA == false ) 
					bIsTaserPilumSuccess = true;
			break;
		case 1: if( m_InputData.pureS == false && m_InputData.oneS == false ) 
					bIsTaserPilumSuccess = true;
			break;
		case 2: if( m_InputData.pureD == false && m_InputData.oneD == false ) 
					bIsTaserPilumSuccess = true;
			break;
		case 3: if( m_InputData.pureC == false && m_InputData.oneC == false ) 
					bIsTaserPilumSuccess = true;
			break;
		case 4: if( m_InputData.pureQ == false && m_InputData.oneQ == false ) 
					bIsTaserPilumSuccess = true;
			break;
		case 5: if( m_InputData.pureW == false && m_InputData.oneW == false ) 
					bIsTaserPilumSuccess = true;
			break;
		case 6: if( m_InputData.pureE == false && m_InputData.oneE == false ) 
					bIsTaserPilumSuccess = true;
			break;
		case 7: if( m_InputData.pureR == false && m_InputData.oneR == false ) 
					bIsTaserPilumSuccess = true;
			break;

		default: // 시전시에 데이터 저장이 제대로 이루어 지지 않았을 경우.
			m_sTaserPilumData.Reset( false, &AccessFutureFrameData() );
			break;;
		}
	}

	return bIsTaserPilumSuccess;
}


const CX2UserSkillTree::SkillSlotData* CX2GUEve::GetSkillSlotDataTaserPilum( IN const CX2UserSkillTree& cUserSkillTree_, OUT int& iSkillSlotIndexPressed_ )
{
	//키처리까지 끝나면 데이터 검색

	int iSlotIndex = (m_sTaserPilumData.GetSkillSlotID() > 3) ? m_sTaserPilumData.GetSkillSlotID()-4 : m_sTaserPilumData.GetSkillSlotID();
	bool bSlotB = (m_sTaserPilumData.GetSkillSlotID() > 3) ? true : false;


	const CX2UserSkillTree::SkillSlotData* pSkillSlotData = cUserSkillTree_.GetSkillSlot( iSlotIndex, bSlotB );

	if( CX2SkillTree::SI_NONE == pSkillSlotData->m_eID ||
		CX2SkillTree::SI_A_EBS_TASER_PILUM != pSkillSlotData->m_eID)
	{
		m_sTaserPilumData.Reset( false, &AccessFutureFrameData() );
		return NULL;
	}

	
#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
	const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( pSkillSlotData->m_eID );
#else // UPGRADE_SKILL_SYSTEM_2013
	const int iSkillLevel = cUserSkillTree_.GetSkillLevel( pSkillSlotData->m_eID );

	const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( pSkillSlotData->m_eID, iSkillLevel );
#endif // UPGRADE_SKILL_SYSTEM_2013
	if( NULL == pSkillTemplet )
	{
		m_sTaserPilumData.Reset( false, &AccessFutureFrameData() );
		return NULL;
	}

	// 테이저 필라 정상 사용 완료
	m_sTaserPilumData.Reset( false, &AccessFutureFrameData() );
	iSkillSlotIndexPressed_ = m_sTaserPilumData.GetSkillSlotID();

	return pSkillSlotData;
}

void CX2GUEve::TASER_PILUM_Data::Reset(bool bIsChargeTrue /* = true */, FrameData* pFrameDataFuture /* = NULL  */)
{
	if( bIsChargeTrue == false && pFrameDataFuture != NULL )
	{
		pFrameDataFuture->syncData.nowAction = UAI_TASER_PILUM_CHARGE_FAIL;
	}

	m_bEnable		= false;
	m_bIsSucCharge	= false;

	ResetParticle();

	g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_FullCharge.ogg" );
	g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_Condense_power.ogg" );
}


void CX2GUEve::TASER_PILUM_Data::ResetParticle()
{
	for( int i = 0; i < ARRAY_SIZE( m_ahMajorParticleInstance ); ++i )
	{
		if( m_ahMajorParticleInstance[i] != INVALID_PARTICLE_SEQUENCE_HANDLE )
			g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_ahMajorParticleInstance[i] );
		m_ahMajorParticleInstance[i] = INVALID_PARTICLE_SEQUENCE_HANDLE;
	}
}

void CX2GUEve::ResetTaserPilumCharge()
{
	if( m_sTaserPilumData.m_bEnable == true )
		m_sTaserPilumData.Reset( false, &AccessFutureFrameData() );
}

void CX2GUEve::ENSI_A_EBS_TASER_PILUM_Init()
{
}

void CX2GUEve::ENSI_A_EBS_TASER_PILUM_StartFuture()
{
	CommonStateStartFuture();

	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed.x = 0.f;
	m_PhysicParam.nowSpeed.y = 0.f;
}

void CX2GUEve::ENSI_A_EBS_TASER_PILUM_Start()
{
	CommonStateStart();

	// 차지 시간을 책정 차지랭크 설정.
	// 1. 소모 MP
	// 2. 데미지 배율
	// 3. 크리 배율
	// 에 적용됨.
	if( (m_sTaserPilumData.m_dMaxTime * 0.5) >= m_sTaserPilumData.m_timerElapsedTime.elapsed() )
		m_sTaserPilumData.m_ChargeRank = CR_RANK_1;
	else if( m_sTaserPilumData.m_dMaxTime >= m_sTaserPilumData.m_timerElapsedTime.elapsed() )
		m_sTaserPilumData.m_ChargeRank = CR_RANK_2;
	else if( m_sTaserPilumData.m_dMaxTime < m_sTaserPilumData.m_timerElapsedTime.elapsed() )
		m_sTaserPilumData.m_ChargeRank = CR_RANK_3;
	//최대 예외처리
	else
		m_sTaserPilumData.m_ChargeRank = CR_RANK_1;

	m_fPlaneZAngle	= 0.f;
	
#ifdef FIX_EVE_TASER_PILUM
	m_sTaserPilumTinyData.reset();
	m_sTaserPilumTinyData.m_timerElapsedTime = m_sTaserPilumData.m_timerElapsedTime;
	m_sTaserPilumTinyData.m_ChargeRank		 = m_sTaserPilumData.m_ChargeRank;
#endif // FIX_EVE_TASER_PILUM

}

void CX2GUEve::ENSI_A_EBS_TASER_PILUM_FrameMoveFuture()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 0.66f )
	{			
		m_bDisableGravity = false;
	}

	CommonFrameMoveFuture();
}

void CX2GUEve::ENSI_A_EBS_TASER_PILUM_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.406f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.406f ) == true && EventCheck( 0.406f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( m_fPlaneZAngle, 2.0f, 240.f, 130.f );
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.416f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.416f ) == true && EventCheck( 0.416f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		// MP 소모
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EBS_TASER_PILUM );

		float fMPConsumption = 0.f;
		float fPowerRate = 1.f;
		int iCount = 0;
		wstring wstrDamageEffect = L"";

		if( NULL != pSkillTemplet )
		{
#ifdef FIX_EVE_TASER_PILUM
			switch( m_sTaserPilumTinyData.m_ChargeRank )
#else
			switch( m_sTaserPilumData.m_ChargeRank )
#endif // FIX_EVE_TASER_PILUM
			{
			case CR_RANK_1: 
				{
					wstrDamageEffect	= L"EVE_TASER_PILUM_CHARGE_0";
				}
				break;
			case CR_RANK_2: 
				{
					wstrDamageEffect	= L"EVE_TASER_PILUM_CHARGE_1";
				}
				break;
			case CR_RANK_3: 
				{
					wstrDamageEffect	= L"EVE_TASER_PILUM_CHARGE_2";
				}
				break;
			}

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			if ( NULL == GetUnit() )
				return;
	
			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	
			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨

			fMPConsumption	= pSkillTemplet->GetSkillMPConsumptionValue( iSkillTempletLevel );
		#ifdef FIX_EVE_TASER_PILUM
			fPowerRate		= static_cast<float>( GetPowerRate() * ( min( m_sTaserPilumTinyData.m_timerElapsedTime.elapsed(), 3.f) / 3.f + 1.f ) );
			iCount			= static_cast<int>( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_PIERCING, iSkillTempletLevel ) * 
				min( m_sTaserPilumTinyData.m_timerElapsedTime.elapsed(), 3.f) / 3.f );
			m_sTaserPilumTinyData.m_iAddDamageTime = iCount;
		#else
			fPowerRate		= static_cast<float>( GetPowerRate() * ( min( m_sTaserPilumData.m_timerElapsedTime.elapsed(), 3.f) / 3.f + 1.f ) );
			iCount			= static_cast<int>( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_PIERCING ) * 
				min( m_sTaserPilumData.m_timerElapsedTime.elapsed(), 3.f) / 3.f );
		#endif // FIX_EVE_TASER_PILUM
	#else // UPGRADE_SKILL_UI
		#ifdef FIX_EVE_TASER_PILUM
			fPowerRate		= static_cast<float>( GetPowerRate() * ( min( m_sTaserPilumTinyData.m_timerElapsedTime.elapsed(), 3.f) / 3.f + 1.f ) );
			iCount			= static_cast<int>( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_PIERCING ) * 
				min( m_sTaserPilumTinyData.m_timerElapsedTime.elapsed(), 3.f) / 3.f );
			m_sTaserPilumTinyData.m_iAddDamageTime = iCount;
		#else
			fPowerRate		= static_cast<float>( GetPowerRate() * ( min( m_sTaserPilumData.m_timerElapsedTime.elapsed(), 3.f) / 3.f + 1.f ) );
			iCount			= static_cast<int>( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_PIERCING ) * 
				min( m_sTaserPilumData.m_timerElapsedTime.elapsed(), 3.f) / 3.f );
		#endif // FIX_EVE_TASER_PILUM
	#endif // UPGRADE_SKILL_UI
		}
		else
		{
			fMPConsumption = 20.f;
		}

		if( FlushMp( fMPConsumption ) == true ) 
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Hand" );

			if( true == GetIsRight() )
			{
				vBonePos += GetDirVector() * 70.f;
			}
			else
			{
				vBonePos -= GetDirVector() * 70.f;
			}

			CKTDGParticleSystem::CParticleEventSequence* pSeq = 
				g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this, L"EBS_A_TASER_PILUM_fire_P01", vBonePos );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}

			pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"EBS_A_TASER_PILUM_fire_P02", vBonePos );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}

			pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"EBS_A_TASER_PILUM_fire_P03", vBonePos );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}

			CX2DamageEffect::CEffect* pEffect = NULL;

			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, wstrDamageEffect.c_str(), fPowerRate, vBonePos,
				GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, 1.f, 1.f );

			pEffect->SetDamageTime( pEffect->GetDamageTime() + iCount );
			pEffect->GetDamageData().bReAttack = false;

			if( pEffect != NULL )
				pEffect->SetInheritForceDownRate(true);

			if( NULL != pEffect )
			{
				wstrDamageEffect += L"_FILTERED";

#ifdef SERV_EVE_BATTLE_SERAPH
				m_EveElectraSystem.AddEffectToSystem( pEffect, wstrDamageEffect.c_str(), wstrDamageEffect.c_str(),
					wstrDamageEffect.c_str(), wstrDamageEffect.c_str());
#else
				m_EveElectraSystem.AddEffectToSystem( pEffect, wstrDamageEffect.c_str(), wstrDamageEffect.c_str() );
#endif // SERV_EVE_BATTLE_SERAPH
			}

			PlaySound( L"Eve_FireShot1.ogg" );
		}
		else
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
			CreateNotEnoughMPEffect( vBonePos, 0.f, 0.f, 0.f );
		}
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_A_EBS_TASER_PILUM_EventProcess()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.4f )
	{
		if( m_InputData.pureUp == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
		}
		else if( m_InputData.pureDown == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
		}
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.36f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.36f ) == true && EventCheck( 0.36f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_bDisableGravity = false;
	}

	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_A_EBS_TASER_PILUM_EndFuture()
{
	m_bDisableGravity = false;
	CommonStateEndFuture();
}
#pragma endregion

#pragma region 부스트 대쉬 스타트
void CX2GUEve::ENSI_EBS_BOOST_DASH_START_StartFuture()
{
	m_PhysicParam.nowSpeed.x = 0.0f;

	CommonStateStartFuture();

	if ( false == GetAbsoluteInvisibility() )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInstPlane = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( 
			(CKTDGObject*) this,  L"P_EBS_BoostDash_M01", GetBonePos( L"Bip01_Head" ), GetRotateDegree(), GetRotateDegree() );
		//m_hBoostDashMesh = pMeshInstPlane->GetHandle();
	}
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_START_EndFuture()
{
	m_PhysicParam.nowSpeed.x = GetDashSpeed();

	CommonStateEndFuture();
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_START_EventProcess()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 0.3f )
	{
		StateChange( ENSI_EBS_BOOST_DASH );
	}

	if( false == IsOnSomethingFuture() )
	{
		if( m_iDashJumpCount < 2 + m_iPhotonBoosterAdditionalDashJumpCount && false == m_InputData.pureDown &&
			( m_InputData.pureLeft == true || m_InputData.pureRight == true ) )
		{
			if ( true == m_InputData.pureRight )
			{
				m_eBoostDashState = BDS_RIGHT;
				m_bEnableBoostDash = true;
			}
			else if ( true == m_InputData.pureLeft )
			{
				m_eBoostDashState = BDS_LEFT;
				m_bEnableBoostDash = true;
			}

			StateChangeJumpDashIfPossible();
		}
		else
		{
			StateChange( USI_JUMP_DOWN );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}
	}
	else if( m_InputData.oneZ == true )
	{
		StateChange( ENSI_DASH_COMBO_Z );
	}
	else if( m_InputData.oneX == true )
	{
		StateChange( ENSI_DASH_COMBO_X );
	}
#ifdef SKILL_CANCEL_BY_HYPER_MODE // 김태환
	SKILL_CANCEL_AFTER( 0.01f )
#else // SKILL_CANCEL_BY_HYPER_MODE
	else if( SpecialAttackEventProcess() == true )
	{
	}
#endif //SKILL_CANCEL_BY_HYPER_MODE
	else if( m_InputData.oneUp == true && m_iDashJumpUpCount  < 1   )
	{
		StateChange( USI_DASH_JUMP );
		m_PhysicParam.nowSpeed.y = m_PhysicParam.GetDashJumpSpeed();
	}
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( GetHyperModeStateID() )
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( USI_HYPER_MODE )
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	
	else if( m_InputData.pureRight == false && m_InputData.pureLeft == false )
	{
		StateChange( USI_DASH_END );
	}
	else if( m_InputData.pureRight == true && m_InputData.pureLeft == true )
	{
		StateChange( USI_DASH_END );
	}
	else if( m_InputData.pureRight == true && m_FrameDataFuture.syncData.bIsRight == false )
	{
		StateChange( USI_DASH_END );
	}
	else if( m_InputData.pureLeft == true && m_FrameDataFuture.syncData.bIsRight == true )
	{
		StateChange( USI_DASH_END );
	}
	else if( m_InputData.oneDown == true 
		&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, 
		LINE_RADIUS, 
		&m_FrameDataFuture.unitCondition.landPosition, 
		&m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}	

	CommonEventProcess();
}
#pragma endregion

#pragma region Boost Dash
void CX2GUEve::ENSI_EBS_BOOST_DASH_StartFuture()
{
	CommonStateStartFuture();

	m_iAccumulateAccel = 0;
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_Start()
{
	CommonStateStart();

	m_hBoostDashParticle = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"P_EBS_BoostDash_P01",
		GetBonePos( L"Bip01" ) );
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_FrameMove()
{
	CommonFrameMove();

	CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hBoostDashParticle );
	if( NULL != pSeq )
	{
		if ( false == GetAbsoluteInvisibility() )
		{
			D3DXVECTOR3 vPos = GetBonePos( L"Bip01" );

			pSeq->SetPosition( vPos );
			pSeq->SetShowObject( true );
		}
		else
		{
			pSeq->SetShowObject( false );
		}
	}
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_FrameMoveFuture()
{
	// 왼쪽 또는 오른쪽 방향키를 두번 누른후 떼지 않은 상태면
	if( ( true == m_InputData.pureRight && true == m_BeforeInputData.pureRight ) ||
		( true == m_InputData.pureLeft  && true == m_BeforeInputData.pureLeft  ) )
	{
		switch ( m_iAccumulateAccel )
		{
		case 1:
			m_PhysicParam.nowSpeed.x = GetDashSpeed() + GetDashSpeed() * ( m_fHighPoweredElectricsSpeed + 0.1f );
			break;

		case 2:
			m_PhysicParam.nowSpeed.x = GetDashSpeed() + GetDashSpeed() * ( m_fHighPoweredElectricsSpeed + 0.2f );
			break;

		case 3:
			m_PhysicParam.nowSpeed.x = GetDashSpeed() + GetDashSpeed() * ( m_fHighPoweredElectricsSpeed + 0.3f );
			break;

		default:
			m_PhysicParam.nowSpeed.x = GetDashSpeed() + GetDashSpeed() * m_fHighPoweredElectricsSpeed;
			break;
		}
	}

	CommonFrameMoveFuture();
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_EventProcess()
{
	if( false == IsOnSomethingFuture() )
	{
		if( m_iDashJumpCount < 2 + m_iPhotonBoosterAdditionalDashJumpCount && false == m_InputData.pureDown &&
			( m_InputData.pureLeft == true || m_InputData.pureRight == true ) )
		{
			if ( true == m_InputData.pureRight )
			{
				m_eBoostDashState = BDS_RIGHT;
				m_bEnableBoostDash = true;
			}
			else if ( true == m_InputData.pureLeft )
			{
				m_eBoostDashState = BDS_LEFT;
				m_bEnableBoostDash = true;
			}

			StateChangeJumpDashIfPossible();
		}
		else
		{
			StateChange( USI_JUMP_DOWN );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}
	}
	else if( m_InputData.oneZ == true )
	{
		StateChange( ENSI_DASH_COMBO_Z );
	}
	else if( m_InputData.oneX == true )
	{
		StateChange( ENSI_DASH_COMBO_X );
	}
#ifdef SKILL_CANCEL_BY_HYPER_MODE // 김태환
	SKILL_CANCEL_AFTER( 0.01f )
#else // SKILL_CANCEL_BY_HYPER_MODE
	else if( SpecialAttackEventProcess() == true )
	{
	}
#endif //SKILL_CANCEL_BY_HYPER_MODE
	else if( m_InputData.oneUp == true && m_iDashJumpUpCount  < 1   )
	{
		StateChange( USI_DASH_JUMP );
		m_PhysicParam.nowSpeed.y = m_PhysicParam.GetDashJumpSpeed();
	}
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( GetHyperModeStateID() )
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	ELSE_IF_CAN_HYPER_MODE_THEN_STATE_CHANGE( USI_HYPER_MODE )
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	else if( m_InputData.pureRight == false && m_InputData.pureLeft == false )
	{
		StateChange( USI_DASH_END );
	}
	else if( m_InputData.pureRight == true && m_InputData.pureLeft == true )
	{
		StateChange( USI_DASH_END );
	}
	else if( m_InputData.pureRight == true && m_FrameDataFuture.syncData.bIsRight == false )
	{
		StateChange( USI_DASH_END );
	}
	else if( m_InputData.pureLeft == true && m_FrameDataFuture.syncData.bIsRight == true )
	{
		StateChange( USI_DASH_END );
	}
	else if( m_InputData.oneDown == true 
		&& g_pX2Game->GetWorld()->GetLineMap()->CanDown( m_FrameDataFuture.syncData.position, 
		LINE_RADIUS, 
		&m_FrameDataFuture.unitCondition.landPosition, 
		&m_FrameDataFuture.syncData.lastTouchLineIndex ) == true )
	{
		StateChange( USI_JUMP_DOWN );
		m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
	}

	if ( 1.0f <= m_FrameDataFuture.unitCondition.fStateTime && 0 == m_iAccumulateAccel )
	{
		++m_iAccumulateAccel;

		if ( false == GetAbsoluteInvisibility() )
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInstPlane = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( 
				(CKTDGObject*) this,  L"P_EBS_BoostDash_M01", GetBonePos( L"Bip01_Head" ), GetRotateDegree(), GetRotateDegree() );
			//m_hBoostDashMesh = pMeshInstPlane->GetHandle();
			PlaySound( L"Eve_BoostDash4.ogg" );
		}
	}
	else if ( 2.f <= m_FrameDataFuture.unitCondition.fStateTime && 1 == m_iAccumulateAccel )
	{
		++m_iAccumulateAccel;

		if ( false == GetAbsoluteInvisibility() )
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInstPlane = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( 
				(CKTDGObject*) this,  L"P_EBS_BoostDash_M01", GetBonePos( L"Bip01_Head" ), GetRotateDegree(), GetRotateDegree() );
			//m_hBoostDashMesh = pMeshInstPlane->GetHandle();
			PlaySound( L"Eve_BoostDash4.ogg" );
		}
	}
	else if ( 3.f <= m_FrameDataFuture.unitCondition.fStateTime && 2 == m_iAccumulateAccel )
	{
		++m_iAccumulateAccel;

		if ( false == GetAbsoluteInvisibility() )
		{
			CKTDGXMeshPlayer::CXMeshInstance* pMeshInstPlane = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( 
				(CKTDGObject*) this,  L"P_EBS_BoostDash_M01", GetBonePos( L"Bip01_Head" ), GetRotateDegree(), GetRotateDegree() );
			//m_hBoostDashMesh = pMeshInstPlane->GetHandle();
			PlaySound( L"Eve_BoostDash4.ogg" );
		}
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_End()
{
	CommonStateEnd();

	m_PhysicParam.nowSpeed.x = GetDashSpeed();

	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hBoostDashParticle );
}
#pragma endregion 부스트 대쉬

#pragma region 부스트 대쉬 에어 스타트
void CX2GUEve::ENSI_EBS_BOOST_DASH_AIR_START_StartFuture()
{
	CommonStateStartFuture();

	m_bDownForce		= false;

	m_bDisableGravity	= true;

	++m_iDashJumpCount;
	++m_iJumpFlyCount;

	m_bAfterJumpDash = true;

	m_fCurrDashJumpTime	= 0.4f;

	m_PhysicParam.nowSpeed.x = GetDashSpeed() + GetDashSpeed() * m_fHighPoweredElectricsSpeed;
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_AIR_START_Start()
{
	CommonStateStart();
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_AIR_START_FrameMoveFuture()
{
	m_fCurrDashJumpTime -= m_fElapsedTime;

	const float fValue = m_fCurrDashJumpTime / 0.4f ;
	const float NOW_FLY_SPEED_SCALE = ( s_fDashJumpSpeedScale + m_fHighPoweredElectricsSpeed ) * powf( fValue, 2 ) + s_fDashJumpSpeedLowerBound;

	if( m_fCurrDashJumpTime < 0.f )
	{
		StateChange( USI_JUMP_DOWN );
	}
	else if( m_InputData.pureDown == false && 
		m_InputData.pureRight == true && m_FrameDataNow.syncData.bIsRight == true )
	{
		m_PhysicParam.nowSpeed.x	= GetDashSpeed() * NOW_FLY_SPEED_SCALE;
		m_PhysicParam.nowSpeed.y	= 0.f;
	}
	else if( m_InputData.pureDown == false &&
		m_InputData.pureLeft == true && m_FrameDataNow.syncData.bIsRight == false )
	{
		m_PhysicParam.nowSpeed.x	= GetDashSpeed() * NOW_FLY_SPEED_SCALE;
		m_PhysicParam.nowSpeed.y	= 0.f;
	}
	else
	{
		StateChange( USI_JUMP_DOWN );
	}

	CommonFrameMoveFuture();
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_AIR_START_EventProcess()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 0.3f )
	{
		StateChange( ENSI_EBS_BOOST_DASH_AIR );
	}

	if( true == IsOnSomethingFuture() )
	{
		if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true )
		{
			StateChange( USI_DASH_JUMP );
			m_PhysicParam.nowSpeed.y = m_PhysicParam.GetDashJumpSpeed();
			m_bDownForce = false;
		}
		else if( m_bDownForce == true )
		{
			StateChange( ENSI_DASH_JUMP_POWER_LANDING );
			m_bDownForce = false;
		}
		else
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChangeDashIfPossible();
			}
			else
			{
				StateChange( USI_JUMP_LANDING );		// not dash_jump_landing 
			}
			m_bDownForce = false;
		}
	}
#ifdef WALL_JUMP_TEST
	else if( m_FrameDataFuture.unitCondition.bFootOnWall == true &&
		( true == m_InputData.oneUp || true == m_InputData.oneDoubleUp ) )
	{
		m_bDisableGravity = true;
		StateChange( ENSI_WALL_LANDING );
	}
#endif WALL_JUMP_TEST
	else if( m_iDashJumpUpCount < 1 && m_InputData.pureDown == false && m_InputData.pureUp == true )
	{
		StateChange( USI_DASH_JUMP );
	}
	else if( true == SpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) )
	{
	}
	else if( m_InputData.oneZ == true )
	{
		StateChange( ENSI_DASH_JUMP_COMBO_Z );
	}
	else if( m_InputData.oneX == true && m_fReDashJumpXTime <= 0.0f )
	{
		StateChange( ENSI_DASH_JUMP_COMBO_X );
	}
	else if( m_InputData.pureRight == true )
	{
		if( m_FrameDataFuture.syncData.bIsRight == false )
		{
			if( m_PhysicParam.nowSpeed.y > m_PhysicParam.GetJumpSpeed() )
				m_PhysicParam.nowSpeed.y = m_PhysicParam.GetJumpSpeed();

			if( m_PhysicParam.nowSpeed.y > 0.0f )
				StateChange( USI_JUMP_UP );
			else
				StateChange( USI_JUMP_DOWN );
		}
	}
	else if( m_InputData.pureLeft == true )
	{
		if( m_FrameDataFuture.syncData.bIsRight == true )
		{
			if( m_PhysicParam.nowSpeed.y > m_PhysicParam.GetJumpSpeed() )
				m_PhysicParam.nowSpeed.y = m_PhysicParam.GetJumpSpeed();

			if( m_PhysicParam.nowSpeed.y > 0.0f )
				StateChange( USI_JUMP_UP );
			else
				StateChange( USI_JUMP_DOWN );
		}
	}

	if( m_InputData.oneUp == true && m_PhysicParam.nowSpeed.y <= 0.0f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}

	if( m_InputData.pureDown == true )
	{
		m_bDownForce = true;
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_AIR_START_EndFuture()
{
	CommonStateEndFuture();

	if( m_PhysicParam.nowSpeed.x > GetDashSpeed() )
	{
		m_PhysicParam.nowSpeed.x = GetDashSpeed();
	}

	if ( false == GetAbsoluteInvisibility() )
	{
		CKTDGXMeshPlayer::CXMeshInstance* pMeshInstPlane = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( 
			(CKTDGObject*) this,  L"P_EBS_BoostDash_M01", GetBonePos( L"Bip01_Head" ), GetRotateDegree(), GetRotateDegree() );
		//m_hBoostDashMesh = pMeshInstPlane->GetHandle();
	}

	m_bDisableGravity = false;
}
#pragma endregion

#pragma region 부스트 대쉬 에어
void CX2GUEve::ENSI_EBS_BOOST_DASH_AIR_StartFuture()
{
	CommonStateStartFuture();

	m_bDownForce		= false;
	m_bDisableGravity	= true;

	m_fCurrDashJumpTime	= s_fMaxDashJumpTime;
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_AIR_Start()
{
	CommonStateStart();

	m_hBoostDashParticle = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( (CKTDGObject*) this,  L"P_EBS_BoostDash_P01",
		GetBonePos( L"Bip01" ) );
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_AIR_FrameMove()
{
	CommonFrameMove();

	CKTDGParticleSystem::CParticleEventSequence* pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence( m_hBoostDashParticle );
	if( NULL != pSeq )
	{
		if ( false == GetAbsoluteInvisibility() )
		{
			D3DXVECTOR3 vPos = GetBonePos( L"Bip01" );

			pSeq->SetPosition( vPos );
			pSeq->SetShowObject( true );
		}
		else
		{
			pSeq->SetShowObject( false );
		}
	}
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_AIR_FrameMoveFuture()
{
	m_fCurrDashJumpTime -= m_fElapsedTime;

	const float fValue = m_fCurrDashJumpTime / s_fMaxDashJumpTime ;
	const float NOW_FLY_SPEED_SCALE = ( s_fDashJumpSpeedScale + m_fHighPoweredElectricsSpeed ) * powf( fValue, 2 ) + s_fDashJumpSpeedLowerBound;

	if( m_fCurrDashJumpTime < 0.f )
	{
		StateChange( USI_JUMP_DOWN );
	}
	else if( m_InputData.pureDown == false && 
		m_InputData.pureRight == true && m_FrameDataNow.syncData.bIsRight == true )
	{
		m_PhysicParam.nowSpeed.x	= GetDashSpeed() * NOW_FLY_SPEED_SCALE;
		m_PhysicParam.nowSpeed.y	= 0.f;
	}
	else if( m_InputData.pureDown == false &&
		m_InputData.pureLeft == true && m_FrameDataNow.syncData.bIsRight == false )
	{
		m_PhysicParam.nowSpeed.x	= GetDashSpeed() * NOW_FLY_SPEED_SCALE;
		m_PhysicParam.nowSpeed.y	= 0.f;
	}
	else
	{
		StateChange( USI_JUMP_DOWN );
	}

	CommonFrameMoveFuture();
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_AIR_EventProcess()
{
	if( true == IsOnSomethingFuture() )
	{
		if( m_FrameDataFuture.stateParam.bEventFlagList[0] == true )
		{
			StateChange( USI_DASH_JUMP );
			m_PhysicParam.nowSpeed.y = m_PhysicParam.GetDashJumpSpeed();
			m_bDownForce = false;
		}
		else if( m_bDownForce == true )
		{
			StateChange( ENSI_DASH_JUMP_POWER_LANDING );
			m_bDownForce = false;
		}
		else
		{
			if( m_InputData.pureRight == true || m_InputData.pureLeft == true )
			{
				StateChangeDashIfPossible();
			}
			else
			{
				StateChange( USI_JUMP_LANDING );		// not dash_jump_landing 
			}
			m_bDownForce = false;
		}
	}
#ifdef WALL_JUMP_TEST
	else if( m_FrameDataFuture.unitCondition.bFootOnWall == true &&
		( true == m_InputData.oneUp || true == m_InputData.oneDoubleUp ) )
	{
		m_bDisableGravity = true;
		StateChange( ENSI_WALL_LANDING );
	}
#endif WALL_JUMP_TEST
	else if( m_iDashJumpUpCount < 1 && m_InputData.pureDown == false && m_InputData.pureUp == true )
	{
		StateChange( USI_DASH_JUMP );
	}
	else if( true == SpecialAttackEventProcess( CX2SkillTree::ASUT_AIR ) )
	{
	}
	else if( m_InputData.oneZ == true )
	{
		StateChange( ENSI_DASH_JUMP_COMBO_Z );
	}
	else if( m_InputData.oneX == true && m_fReDashJumpXTime <= 0.0f )
	{
		m_iBoostAttackCount = 0;
		m_bBoostUpAttack = false;

		StateChangeBoostAttackIfPossible();
	}
	else if( m_InputData.pureRight == true )
	{
		if( m_FrameDataFuture.syncData.bIsRight == false )
		{
			if( m_PhysicParam.nowSpeed.y > m_PhysicParam.GetJumpSpeed() )
				m_PhysicParam.nowSpeed.y = m_PhysicParam.GetJumpSpeed();

			if( m_PhysicParam.nowSpeed.y > 0.0f )
				StateChange( USI_JUMP_UP );
			else
				StateChange( USI_JUMP_DOWN );
		}
	}
	else if( m_InputData.pureLeft == true )
	{
		if( m_FrameDataFuture.syncData.bIsRight == true )
		{
			if( m_PhysicParam.nowSpeed.y > m_PhysicParam.GetJumpSpeed() )
				m_PhysicParam.nowSpeed.y = m_PhysicParam.GetJumpSpeed();

			if( m_PhysicParam.nowSpeed.y > 0.0f )
				StateChange( USI_JUMP_UP );
			else
				StateChange( USI_JUMP_DOWN );
		}
	}

	if( m_InputData.oneUp == true && m_PhysicParam.nowSpeed.y <= 0.0f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[0] = true;
	}

	if( m_InputData.pureDown == true )
	{
		m_bDownForce = true;
		m_FrameDataFuture.stateParam.bEventFlagList[0] = false;
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_AIR_EndFuture()
{
	CommonStateEndFuture();

	if( m_PhysicParam.nowSpeed.x > GetDashSpeed() )
	{
		m_PhysicParam.nowSpeed.x = GetDashSpeed();
	}

	m_bDisableGravity = false;
}

void CX2GUEve::ENSI_EBS_BOOST_DASH_AIR_End()
{
	CommonStateEnd();

	g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_hBoostDashParticle );
}
#pragma endregion

#pragma region 대쉬 점프 콤보 X(Push)Z
void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_XZ_Start()
{
	CommonStateStart();

	SetNoDetonation( true );

	m_bDisableGravity = true;
	m_bDashJumpXXLaserEnd = false;
	m_bExceptionPlane = true;
	m_fExceptioncPlaneZAngle = -45.f;
	m_bNotEnoughMPDashJumpXZLaser = false;
	m_fPlaneZAngle = 0.f;
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectElectraLaserDashJumpXZ = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectElectraLaserDashJumpXZ = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

	m_EveElectraSystem.m_fLaserEndOffsetX = 0.f;
	m_EveElectraSystem.m_fLaserEndOffsetY = 0.f;

	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );

	m_EveElectraSystem.m_fEveZAngle = 70.f;
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_XZ_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.3f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.3f ) == true && EventCheck( 0.3f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( m_fPlaneZAngle + m_fExceptioncPlaneZAngle, 1.8f, 150.f, -50.f );
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.333f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.333f ) == true && EventCheck( 0.333f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.m_fPlaneZAngle = m_fPlaneZAngle + m_fExceptioncPlaneZAngle;
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.533f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.533f ) == true && EventCheck( 0.533f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vDamageEffectPos = GetPos();
		vDamageEffectPos.y += 130.f;
		D3DXVECTOR3 vZeroYDirVector = GetDirVector();
		vZeroYDirVector.y = 0.f;
		D3DXVec3Normalize( &vZeroYDirVector, &vZeroYDirVector );

		if( GetIsRight() == false )
		{
			vZeroYDirVector.x = -vZeroYDirVector.x;
			vZeroYDirVector.z = -vZeroYDirVector.z;
		}
		vDamageEffectPos += (130.f * vZeroYDirVector);

		CX2DamageEffect::CEffect* pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_DASHJUMP_COMBO_XZ_LASER", 
			GetPowerRate(), vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        m_hEffectElectraLaserDashJumpXZ = pEffect->GetHandle();
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
		m_EffectElectraLaserDashJumpXZ = pEffect;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffect->GetMainEffect())
		{
			D3DXVECTOR3 vRotateLocalDegree = pMeshInstance->GetRotateLocalDegree();

			vRotateLocalDegree.z += m_fExceptioncPlaneZAngle;

			pMeshInstance->SetRotateLocalDegree( vRotateLocalDegree );

			m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Finger2Nub", vDamageEffectPos, vZeroYDirVector, 6000.f, 0.108f, 0.5f,
				L"EVE_DASHJUMP_COMBO_XZ_LASER_NEXT", L"EVE_DASHJUMP_COMBO_XZ_LASER_NEXT", L"EVE_DASHJUMP_COMBO_XZ_LASER_NEXT", true, 2.f );
		}
	}

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if( CX2DamageEffect::CEffect* pEffectElectraLaserDashJumpXZ = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffectElectraLaserDashJumpXZ ) )
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    if( CX2DamageEffect::CEffect* pEffectElectraLaserDashJumpXZ = g_pX2Game->GetDamageEffect()->IsLiveInstance( m_EffectElectraLaserDashJumpXZ ) ? m_EffectElectraLaserDashJumpXZ : NULL)
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	{
        if ( CKTDGXMeshPlayer::CXMeshInstance* pMeshInstance = pEffectElectraLaserDashJumpXZ->GetMainEffect() )
		{
			if( m_pXSkinAnim->GetNowAnimationTime() >= 0.733f && m_pXSkinAnim->GetNowAnimationTime() < 1.233f )
			{
				D3DXVECTOR3 vRotateLocalDegree = pMeshInstance->GetRotateLocalDegree();
				vRotateLocalDegree.z += ( 70.904f * m_fElapsedTime );
				pMeshInstance->SetRotateLocalDegree( vRotateLocalDegree );
				m_EveElectraSystem.m_fLaserEndOffsetY = 2.f;
			}
			else if ( m_pXSkinAnim->GetNowAnimationTime() >= 1.233f && m_pXSkinAnim->GetNowAnimationTime() < 1.733f )
			{
				D3DXVECTOR3 vRotateLocalDegree = pMeshInstance->GetRotateLocalDegree();
				vRotateLocalDegree.z += ( 0.904f * m_fElapsedTime );
				pMeshInstance->SetRotateLocalDegree( vRotateLocalDegree );
			}
			else
			{
				m_EveElectraSystem.m_fLaserEndOffsetY = 0.f;
			}
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 1.833f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 1.833f ) == true && EventCheck( 1.866f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_bDashJumpXXLaserEnd = true;
		m_bExceptionPlane = false;
		m_EveElectraSystem.m_fEveZAngle = 0.f;
		m_fExceptioncPlaneZAngle = 0.f;
		g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EVE_COMBO_XXZ_END", this );
		m_EveElectraSystem.DeleteLaserFromSystem();
#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
        m_hEffectElectraLaserDashJumpXZ = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	    m_EffectElectraLaserDashJumpXZ = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	}

	if( m_pXSkinAnim->GetNowAnimationTime() > 0.600f && m_pXSkinAnim->GetNowAnimationTime() < 1.866f )
	{
		if( m_bNotEnoughMPDashJumpXZLaser == false && FlushMp( 13.3333f * m_fElapsedTime ) == false )
		{
			m_EveElectraSystem.DeleteLaserFromSystem();
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger2Nub" );
			CreateNotEnoughMPEffect( vBonePos, 0.f, 0.f, 0.f );
			m_bNotEnoughMPDashJumpXZLaser = true;
		}
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_XZ_EventProcess()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.3f )
	{
		if( m_InputData.pureUp == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
		}
		else if( m_InputData.pureDown == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
		}
	}
	
	if( m_InputData.oneZ == true && m_FrameDataFuture.stateParam.bEventFlagList[0] == false )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[1] = true;
	}
	
	if( m_InputData.pureZ == false )
	{
		if( m_pXSkinAnimFuture->GetNowAnimationTime() > 0.9f )
		{
			m_fCanNotAttackTime = 0.1f;
			m_bDisableGravity = false;
			m_PhysicParam.nowSpeed.y = -0.0001f;

			StateChange( ENSI_JUMP_FLY_DOWN );
		}
	}
	
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{	
		m_fCanNotAttackTime = 0.1f;
		m_bDisableGravity = false;

		m_PhysicParam.nowSpeed.y = -0.0001f;

		StateChange( ENSI_JUMP_FLY_DOWN );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_XZ_EndFuture()
{
	m_bDisableGravity = false;

	CommonStateEndFuture();
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_XZ_End()
{
	m_EveElectraSystem.DeleteLaserFromSystem();

#ifdef  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
    m_hEffectElectraLaserDashJumpXZ = INVALID_DAMAGE_EFFECT_HANDLE;
#else   X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE
	m_EffectElectraLaserDashJumpXZ = NULL;
#endif  X2OPTIMIZE_PARTICLE_AND_ETC_HANDLE

	m_EveElectraSystem.m_fLaserEndOffsetX = 0.f;
	m_EveElectraSystem.m_fLaserEndOffsetY = 0.f;

	m_bExceptionPlane = false;
	m_fExceptioncPlaneZAngle = 0.f;
	m_EveElectraSystem.m_fEveZAngle = 0.f;

	m_bDisableGravity = false;

	SetNoDetonation( false );

	CommonStateEnd();
}
#pragma endregion 

#pragma region 이브 부스트 점프 공격
void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZFrontX_Start()
{
	CommonStateStart();

	m_bDisableGravity = true;
	m_bNotEnoughMPDashZX = false;
	++m_iBoostAttackCount;

    CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;
	pMeshInst  = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"P_EBS_BoostDash_M01", GetBonePos( L"Bip01_Head" ),
		GetRotateDegree(), GetRotateDegree() );

	g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Seraph_Boost_Dash_Attack", this );

	m_fBlinkInvisibilityAlpha	= 1.f;
	m_bBlinkInvisibility		= true;

	SetAlphaObject( true );
	m_RenderParam.bAlphaBlend = true;
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZFrontX_FrameMove()
{
	CommonFrameMove();
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZFrontX_EventProcess()
{
	if( m_InputData.oneX == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.13333f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[1] = true;
	}

	if( m_iBoostAttackCount < 3 + m_iAddBoostAttack && true == m_FrameDataFuture.stateParam.bEventFlagList[1] &&
		m_pXSkinAnimFuture->GetNowAnimationTime() > 0.59f && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.833f )
	{
		StateChangeBoostAttackIfPossible();
	}
	else if ( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		m_bDisableGravity = false;
		m_PhysicParam.nowSpeed.y = -0.0001f;

		StateChange( ENSI_JUMP_FLY_DOWN );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZFrontX_EndFuture()
{
	m_bDisableGravity = false;

	CommonStateEndFuture();
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZFrontX_End()
{
	m_bDisableGravity = false;

	CommonStateEnd();

	m_bBlinkInvisibility	= false;

	if( m_bInvisibility == false )
	{
		SetAlphaObject( false );
		m_RenderParam.bAlphaBlend = false;
		m_RenderParam.outLineColor.a	= 1.f;
		m_RenderParam.color.a			= 1.f;
	}
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZUpX_Start()
{
	CommonStateStart();

	m_bDisableGravity = true;
	m_bNotEnoughMPDashZX = false;
	++m_iBoostAttackCount;
	++m_iJumpFlyCount;
	m_bBoostUpAttack = true;

	D3DXVECTOR3 vRot = GetRotateDegree();
	vRot.z += 45.f;

    CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;
	pMeshInst  = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"P_EBS_BoostDash_M01", GetBonePos( L"Bip01_Head" ),
		vRot, vRot );

	CX2EffectSet::Handle hEffect = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Seraph_Boost_Dash_Attack", this );
	if ( CX2EffectSet::EffectSetInstance* pEffect = g_pX2Game->GetEffectSet()->GetEffectSetInstance( hEffect ) )
	{
		if ( true != GetIsRight() )
			vRot.z += 90.f;

		pEffect->SetLocalRotateDegree( vRot );
	}

	m_fBlinkInvisibilityAlpha	= 1.f;
	m_bBlinkInvisibility		= true;

	SetAlphaObject( true );
	m_RenderParam.bAlphaBlend = true;
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZUpX_FrameMove()
{
	CommonFrameMove();
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZUpX_EventProcess()
{
	if( m_InputData.oneX == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.13333f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[1] = true;
	}

	if( m_iBoostAttackCount < 3 + m_iAddBoostAttack && true == m_FrameDataFuture.stateParam.bEventFlagList[1] &&
		m_pXSkinAnimFuture->GetNowAnimationTime() > 0.59f && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.833f )
	{
		StateChangeBoostAttackIfPossible();
	}
	else if ( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		m_bDisableGravity = false;
		m_PhysicParam.nowSpeed.y = -0.0001f;

		StateChange( ENSI_JUMP_FLY_DOWN );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZUpX_EndFuture()
{
	m_bDisableGravity = false;

	CommonStateEndFuture();
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZUpX_End()
{
	m_bDisableGravity = false;

	CommonStateEnd();

	m_bBlinkInvisibility	= false;

	if( m_bInvisibility == false )
	{
		SetAlphaObject( false );
		m_RenderParam.bAlphaBlend = false;
		m_RenderParam.outLineColor.a	= 1.f;
		m_RenderParam.color.a			= 1.f;
	}
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZDownX_Start()
{
	CommonStateStart();

	m_bDisableGravity = true;
	m_bNotEnoughMPDashZX = false;
	++m_iBoostAttackCount;
	++m_iJumpFlyCount;
	m_bBoostUpAttack = false;

	D3DXVECTOR3 vRot = GetRotateDegree();
	vRot.z -= 45.f;

    CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;
	pMeshInst = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this,  L"P_EBS_BoostDash_M01", GetBonePos( L"Bip01_Head" ),
		vRot, vRot );
	CX2EffectSet::Handle hEffect = g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Seraph_Boost_Dash_Attack", this );
	if ( CX2EffectSet::EffectSetInstance* pEffect = g_pX2Game->GetEffectSet()->GetEffectSetInstance( hEffect ) )
	{
		if ( true != GetIsRight() )
			vRot.z -= 90.f;

		pEffect->SetLocalRotateDegree( vRot );
	}

	m_fBlinkInvisibilityAlpha	= 1.f;
	m_bBlinkInvisibility		= true;

	SetAlphaObject( true );
	m_RenderParam.bAlphaBlend = true;
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZDownX_FrameMove()
{
	CommonFrameMove();
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZDownX_EventProcess()
{
	if( m_InputData.oneX == true && m_pXSkinAnimFuture->GetNowAnimationTime() > 0.13333f )
	{
		m_FrameDataFuture.stateParam.bEventFlagList[1] = true;
	}

	if( m_iBoostAttackCount < 3 + m_iAddBoostAttack && true == m_FrameDataFuture.stateParam.bEventFlagList[1] &&
		m_pXSkinAnimFuture->GetNowAnimationTime() > 0.59f && m_pXSkinAnimFuture->GetNowAnimationTime() < 0.833f )
	{
		StateChangeBoostAttackIfPossible();
	}
	else if ( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		m_bDisableGravity = false;
		m_PhysicParam.nowSpeed.y = -0.0001f;

		StateChange( ENSI_JUMP_FLY_DOWN );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZDownX_EndFuture()
{
	m_bDisableGravity = false;

	CommonStateEndFuture();
}

void CX2GUEve::ENSI_EBS_DASH_JUMP_COMBO_ZDownX_End()
{
	m_bDisableGravity = false;

	CommonStateEnd();

	m_bBlinkInvisibility	= false;

	if( m_bInvisibility == false )
	{
		SetAlphaObject( false );
		m_RenderParam.bAlphaBlend = false;
		m_RenderParam.outLineColor.a	= 1.f;
		m_RenderParam.color.a			= 1.f;
	}
}

void CX2GUEve::StateChangeBoostAttackIfPossible()
{
	if( true == FlushMp( 5.0f ) )
	{
		if ( true == m_InputData.pureRight )
		{
			if ( false == m_FrameDataFuture.syncData.bIsRight )
			{
				m_FrameDataFuture.syncData.bIsRight	= !m_FrameDataFuture.syncData.bIsRight;
				m_FrameDataFuture.unitCondition.dirDegree.y	+= 180.0f;
			}
		}
		else if ( true == m_InputData.pureLeft )
		{
			if ( true == m_FrameDataFuture.syncData.bIsRight )
			{
				m_FrameDataFuture.syncData.bIsRight	= !m_FrameDataFuture.syncData.bIsRight;
				m_FrameDataFuture.unitCondition.dirDegree.y	+= 180.0f;
			}
		}

		if ( true == m_InputData.pureUp && false == m_bBoostUpAttack )
		{
			StateChange( ENSI_EBS_DASH_JUMP_COMBO_ZUpX );
		}
		else if ( true == m_InputData.pureDown && m_FrameDataFuture.syncData.position.y > m_FrameDataFuture.unitCondition.landPosition.y + LINE_RADIUS )
		{
			StateChange( ENSI_EBS_DASH_JUMP_COMBO_ZDownX );
		}
		else
		{
			StateChange( ENSI_EBS_DASH_JUMP_COMBO_ZFrontX );
		}
	}
	else
	{
		if( true == IsOnSomethingFuture() )
		{
			StateChange( USI_JUMP_LANDING );
		}
	}
}
#pragma endregion

#pragma region 에너지 니들스
void CX2GUEve::ENSI_EBS_ENERGY_NEEDLES_Init()
{
#ifdef	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	XSkinMeshReadyInBackground( L"EBS_A_TASER_PILUM_laser_attackLine.X" );
	TextureReadyInBackground( L"EBS_A_TASER_PILUM_laser02.tga" );
	TextureReadyInBackground( L"EBS_A_TASER_PILUM_laser02.tga" );
	XMeshReadyInBackground( L"EBS_A_TASER_PILUM_lightning.Y" );
#else	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
	XSkinMeshReady( L"EBS_A_TASER_PILUM_laser_attackLine.X" );
	TextureReady( L"EBS_A_TASER_PILUM_laser02.tga" );
	TextureReady( L"EBS_A_TASER_PILUM_laser02.tga" );
	XMeshReady( L"EBS_A_TASER_PILUM_lightning.Y" );
#endif	X2OPTIMIZE_GAME_CHARACTER_BACKGROUND_LOAD
}

void CX2GUEve::ENSI_EBS_ENERGY_NEEDLES_Start()
{
	CommonStateStart();
}

void CX2GUEve::ENSI_EBS_ENERGY_NEEDLES_FrameMove()
{
	ChangeWorldColorByHyperMode();
	ShowActiveSkillCutInAndLight( L"Dummy1_Rhand", 0.01f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 1.766f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 1.766f ) == true && EventCheck( 1.766f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_SA_EBS_ENERGY_NEEDLES );

		if ( NULL != pSkillTemplet )
		{
			m_EnergyNiddleData.m_bEnable = true;

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			if ( NULL == GetUnit() )
				return;
	
			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	
			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
			m_EnergyNiddleData.m_fMaxTime = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillTempletLevel ) - 0.33f;
			m_EnergyNiddleData.m_fPowerRate = pSkillTemplet->GetSkillPowerRateValue( iSkillTempletLevel );
	#else // UPGRADE_SKILL_UI
			m_EnergyNiddleData.m_fMaxTime = pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME ) - 0.33f;
			m_EnergyNiddleData.m_fPowerRate = pSkillTemplet->m_fPowerRate;
	#endif // UPGRADE_SKILL_UI

			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Hand" );

			if ( true == GetIsRight() )
				vBonePos -= GetDirVector() * 40.f;
			else
				vBonePos += GetDirVector() * 40.f;

			vBonePos.y -= 30.f;

			CX2DamageEffect::CEffect* pEffect = NULL;

			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_ENERGY_NEEDLES", GetPowerRate(), vBonePos,
				GetRotateDegree(), GetRotateDegree() );

			if( NULL != pEffect )
			{
#ifdef SERV_EVE_BATTLE_SERAPH
				m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_ENERGY_NEEDLES_FILTERED", L"EVE_ENERGY_NEEDLES_FILTERED", 
														L"EVE_ENERGY_NEEDLES_FILTERED", L"EVE_ENERGY_NEEDLES_FILTERED" );
#else
				m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_ENERGY_NEEDLES_FILTERED", L"EVE_ENERGY_NEEDLES_FILTERED");
#endif // SERV_EVE_BATTLE_SERAPH

			}
		}
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_EBS_ENERGY_NEEDLES_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_EBS_ENERGY_NEEDLES_End()
{
	CommonStateEnd();
}

void CX2GUEve::ENERGY_NEEDLES_Data::OnFrameMove( IN CX2GUEve* pGUEve, IN float fElapsedTime_ )
{
	if ( true == m_bEnable )
	{
		if ( 0.f < m_fMaxTime )
		{
			if ( 0.f < m_fIntervalTime )
			{
				m_fIntervalTime -= fElapsedTime_;
			}
			else
			{
				D3DXVECTOR3 vBonePos = pGUEve->GetBonePos( L"Bip01" );

				int iRandVal = RandomInt( 0, 5 );

				if ( true == pGUEve->GetIsRight() )
					vBonePos -= pGUEve->GetDirVector() * m_vEffectPos[iRandVal].x;
				else
					vBonePos += pGUEve->GetDirVector() * m_vEffectPos[iRandVal].x;

				vBonePos.y += m_vEffectPos[iRandVal].y;

				CX2DamageEffect::CEffect* pEffect = NULL;

				pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( pGUEve, L"EVE_ENERGY_NEEDLES", m_fPowerRate, vBonePos,
					pGUEve->GetRotateDegree(), pGUEve->GetRotateDegree() );

				if( NULL != pEffect )
				{
#ifdef SERV_EVE_BATTLE_SERAPH
					pGUEve->m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_ENERGY_NEEDLES_FILTERED", L"EVE_ENERGY_NEEDLES_FILTERED", 
																L"EVE_ENERGY_NEEDLES_FILTERED", L"EVE_ENERGY_NEEDLES_FILTERED" );
#else
					pGUEve->m_EveElectraSystem.AddEffectToSystem( pEffect, L"EVE_ENERGY_NEEDLES_FILTERED", L"EVE_ENERGY_NEEDLES_FILTERED");
#endif // SERV_EVE_BATTLE_SERAPH
				}

				m_fIntervalTime = 0.33f;
				m_fMaxTime -= 0.33f;
			}
		}
		else
		{
			m_bEnable = false;
		}
	}
}
#pragma endregion 

#pragma region 에너제틱 하트
void CX2GUEve::ENSI_EBS_ENERGETIC_HEART_Start()
{
	CommonStateStart();

	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_SA_EBS_ENERGETIC_HEART );
	if ( NULL != pSkillTemplet && !pSkillTemplet->m_vecBuffFactorPtr.empty() )
	{
#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
		if ( NULL == GetUnit() )
			return;

		const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
		const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );

		CX2BuffFactorPtr ptrBuffFactorClone = pSkillTemplet->m_vecBuffFactorPtr[0]->GetClonePtr( iSkillTempletLevel );

		if ( NULL != ptrBuffFactorClone )
		{
			ptrBuffFactorClone->SetGameUnitBuffFactor( this );
			
			if ( m_fAddEnergeticHeartTime > 0.f )
				ptrBuffFactorClone->ApplyExternalFactorToFinalizer( BFT_TIME, m_fAddEnergeticHeartTime );

			SetBuffFactorToGameUnit( *ptrBuffFactorClone );
		}
#else //UPGRADE_SKILL_SYSTEM_2013
		SetBuffFactorToGameUnit( pSkillTemplet, 0 );
#endif //UPGRADE_SKILL_SYSTEM_2013
        if( CX2DamageEffect::CEffect* pTSEffect = ( m_pThousandStar != NULL ) ? m_pThousandStar->GetLiveDamageEffect() : NULL )
		{
			g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_EveElectraSystem.m_hParticleThousandStarFormation );

			if( m_EveElectraSystem.GetPlaneFormation() == PFT_FUSION )
			{
				m_EveElectraSystem.m_hParticleThousandStarFormation = g_pX2Game->GetMajorParticle()->CreateSequenceHandle(
					(CKTDGObject*) this,  L"eve_thousandsOfStars_model_P01_5_white", pTSEffect->GetPos() );
			}
		}
	}

}

void CX2GUEve::ENSI_EBS_ENERGETIC_HEART_FrameMove()
{
	ChangeWorldColorByHyperMode();
	ShowActiveSkillCutInAndLight( L"Dummy1_Rhand", 0.01f, 2 );

	CommonFrameMove();
}

void CX2GUEve::ENSI_EBS_ENERGETIC_HEART_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_EBS_ENERGETIC_HEART_End()
{
	CommonStateEnd();
}

void CX2GUEve::EveElectraSystem::SetExceptionSystemTime( float _fVal )
{
	m_fExceptionSystemOperationTime	= _fVal;
	m_fExceptionSystemRemainTime	= _fVal;
}
#pragma endregion

#pragma region 역장 변경 Start 함수 분리
void CX2GUEve::SPECTRO_EL_CRYSTAL_Start()
{
	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet(CX2SkillTree::SI_A_EEL_SPECTRO_EL_CRYSTAL);
	if( NULL != pSkillTemplet )
	{
#ifdef SERV_EVE_BATTLE_SERAPH
		if( true == m_EveElectraSystem.GetEnableSystem() )
		{
			m_EveElectraSystem.ChangePlaneFormation();
			if ( NULL != g_pX2Game && IsMyUnit() )
				g_pX2Game->UpdateSkillSlotUI();
		}
#else
		if( true == m_EveElectraSystem.GetEnableSystem() && 
			true == m_EveElectraSystem.GetEnableSpectrumDynamics() )
		{
			m_EveElectraSystem.ChangePlaneFormation();
			if ( IsMyUnit() )
				g_pX2Game->UpdateSkillSlotUI();
		}
#endif
		else
		{
			if( m_EveElectraSystem.GetEnableSystem() == false )
			{
				m_EveElectraSystem.SetEnableSystem( true );
#ifdef ADDITIONAL_MEMO

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			if ( NULL == GetUnit() )
			return;
	
			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	
			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO13) == true )
				m_EveElectraSystem.SetSystemOperationTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillTempletLevel ) + 3.f );
			else
				m_EveElectraSystem.SetSystemOperationTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillTempletLevel ) );
	#else // UPGRADE_SKILL_UI
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO13) == true )
				m_EveElectraSystem.SetSystemOperationTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME ) + 3.f );
			else
				m_EveElectraSystem.SetSystemOperationTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME ) );
	#endif // UPGRADE_SKILL_UI
#else
				m_EveElectraSystem.SetSystemOperationTime( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME ) );
#endif

				m_EveElectraSystem.SetPlaneFormation( PFT_AMPLIFIER );
				if ( IsMyUnit() )
					g_pX2Game->UpdateSkillSlotUI();

#ifdef SERV_EVE_BATTLE_SERAPH
				if ( true == m_EveElectraSystem.GetEnableHyperOpticalResearch() )
					const_cast<CX2SkillTree::SkillTemplet*>(pSkillTemplet)->m_eActiveSkillUseCondtion = CX2SkillTree::ASUT_ANYTIME;
#endif
			}
		}
	}

	ChangeThousandsOfStarsFormation();
}
#pragma endregion

#endif

#ifdef ADD_FULL_CHARGING_VOICE
#pragma region 공격 스테이트가 아닐 때 사운드 파일 출력하는 함수
void CX2GUEve::PlaySoundAtNoAttackState( const wstring& wstrSoundFileName_ )
{
	/// 공격 스테이트가 아니면 해당 사운드 출력
	switch( GetNowStateID() )
	{
	case USI_WAIT:
	case USI_WALK:
	case USI_JUMP_READY:
	case USI_JUMP_UP:
	case USI_JUMP_DOWN:
	case USI_DASH:
	case USI_DASH_END:
	case USI_DASH_JUMP:
	case USI_DASH_JUMP_LANDING:
	case USI_DAMAGE_GROGGY:
	case ENSI_JUMP_FLY_UP:
	case ENSI_JUMP_FLY_DOWN:
	case ENSI_JUMP_DASH:
	case ENSI_EBS_BOOST_DASH:
	case ENSI_EBS_BOOST_DASH_AIR:
		{
			PlaySound( wstrSoundFileName_.c_str() );
		} break;
	}
}
#pragma endregion 
#endif ADD_FULL_CHARGING_VOICE

#ifdef UPGRADE_SKILL_SYSTEM_2013 //JHKang
#pragma region SI_SA_EN_ILLUSION_RAY
void CX2GUEve::ENSI_A_EN_Illusion_Ray_Init()
{
	XSkinMeshReadyInBackground( L"eve_particleRay_laser.X" );
	TextureReadyInBackground( L"eve_particleRay_circle.dds" );
	TextureReadyInBackground( L"Particle_Blur.dds" );
	TextureReadyInBackground( L"SpreadLight03_Gray.dds" );
	TextureReadyInBackground( L"Ring.dds" );
}


void CX2GUEve::ENSI_A_EN_Illusion_Ray_Start()
{
	CommonStateStart();
	m_fPlaneZAngle	= 0.f;
}

void CX2GUEve::ENSI_A_EN_Illusion_Ray_StartFuture()
{
	CommonStateStartFuture();
	m_bApplyMotionOffset = false;
}

void CX2GUEve::ENSI_A_EN_Illusion_Ray_FrameMoveFuture()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnimFuture->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnimFuture->EventTimer( 0.01f ) == true && EventCheck( 0.01f, true ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_PhysicParam.nowSpeed.x = 0.f;
	}
	CommonFrameMoveFuture();
}

void CX2GUEve::ENSI_A_EN_Illusion_Ray_EventProcess()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.4f )
	{
		if( m_InputData.pureUp == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
		}
		else if( m_InputData.pureDown == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
		}
	}

	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
	WALK_CANCEL_AFTER( m_fWalkCancelAfter )
	DASH_CANCEL_AFTER( m_fDashCancelAfter )

	CommonEventProcess();
}

void CX2GUEve::ENSI_A_EN_Illusion_Ray_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.02f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.02f ) == true && EventCheck( 0.02f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( m_fPlaneZAngle, 1.f, 185.f, 130.f );
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.m_fPlaneZAngle = m_fPlaneZAngle;
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.43333f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.43333f ) == true && EventCheck( 0.43333f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{

		D3DXVECTOR3 vDamageEffectPos = GetPos();
		vDamageEffectPos.y += 110.f;
		D3DXVECTOR3 vZeroYDirVector = GetDirVector();
		vZeroYDirVector.y = 0.f;
		D3DXVec3Normalize( &vZeroYDirVector, &vZeroYDirVector );


		if(GetIsRight() == false)
		{
			vZeroYDirVector.x = -vZeroYDirVector.x;
			vZeroYDirVector.z = -vZeroYDirVector.z;
		}
		vDamageEffectPos += (50.f * vZeroYDirVector);

		CX2DamageEffect::CEffect* pEffect = NULL;
		
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_EPR_ILLUSION_RAY_LASER", GetPowerRate(),
			vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

		m_EveElectraSystem.AddLaserToSystem( pEffect, L"", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.12f, 1.0f, 
			L"EVE_EPR_ILLUSION_RAY_LASER", L"EVE_EPR_ILLUSION_RAY_LASER",
			L"EVE_EPR_ILLUSION_RAY_LASER", false );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_A_EN_Illusion_Ray_End()
{
	CommonStateEnd();
	m_EveElectraSystem.DeleteLaserFromSystem();
}
#pragma endregion 일루전 레이

#pragma region SI_A_EN_TESLA_SHOCK
void CX2GUEve::ENSI_A_EN_Tesla_Shock_Init()
{
	XSkinMeshReadyInBackground( L"SI_A_EEG_METAL_DUST_AURA_Effect.x" );
	TextureReadyInBackground( L"CutTendon_Slash01.tga" );
}
void CX2GUEve::ENSI_A_EN_Tesla_Shock_StateStart()
{
	CommonStateStart();

	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );

	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EN_TESLA_SHOCK );
	if( NULL != pSkillTemplet )
	{
		D3DXVECTOR3 vPos = GetBonePos( L"Bip01_Pelvis" );
		CX2DamageEffect::CEffect* pDamageEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Tesla_Shock",
			GetPowerRate(), vPos, GetRotateDegree(), GetRotateDegree() );

		if ( NULL != pDamageEffect )
		{
			CX2DamageManager::DamageData* pDamageData = &pDamageEffect->GetDamageData();

	#ifdef UPGRADE_SKILL_SYSTEM_2013 // 김태환 - 스킬 시스템 변경
			if ( NULL == GetUnit() )
			return;
	
			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	
			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
			//if ( NULL != pDamageData )
				pDamageData->fForceDownValue = -pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FORCE_DOWN_ABS, iSkillTempletLevel );
	#else // UPGRADE_SKILL_UI
			//if ( NULL != pDamageData )
				pDamageData->fForceDownValue = -pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_FORCE_DOWN_ABS );
	#endif // UPGRADE_SKILL_UI
		}
	}
}

void CX2GUEve::ENSI_A_EN_Tesla_Shock_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	WALK_CANCEL_AFTER( m_fWalkCancelAfter )
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	DASH_CANCEL_AFTER( m_fDashCancelAfter )
	
	CommonEventProcess();
}

void CX2GUEve::ENSI_A_EN_Tesla_Shock_StateEnd()
{
	m_bDisableGravity = false;
	CommonStateEnd();
}
#pragma endregion 테슬라 쇼크

#pragma region SI_SA_EEG_HORNET_STING_SHAPED_CHARGE
void CX2GUEve::ENSI_SA_EEG_Hornet_Sting_Shaped_Charge_Init()
{
	XSkinMeshReadyInBackground( L"EG_SP1a_HornetSting_Bomb.X" );
	XSkinMeshReadyInBackground( L"EG_SP1a_HornetSting_Cannon.X" );
	TextureReadyInBackground( L"Eve_EG_SP1_HornetSting_Piece00.tga" );
}

void CX2GUEve::ENSI_SA_EEG_Hornet_Sting_Shaped_Charge_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.02f, 0 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.06f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.06f ) == true && EventCheck( 0.06f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetPos();
        CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = NULL;
		pMeshInst  = g_pX2Game->GetMajorXMeshPlayer()->CreateInstance( (CKTDGObject*) this, L"Mesh_Eve_EG_SP1a_HornetSting_Cannon", vBonePos,
			GetRotateDegree(), GetRotateDegree() );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 0.47f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 0.47f ) == true && EventCheck( 0.47f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_L_Finger1" );

		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this, L"Flare_EG_SP1a_HornetSting_01", vBonePos );
		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this, L"Expl_EG_SP1a_HornetSting_01", vBonePos );
		g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this, L"Explosion_Eve_EG_Sp1a_HS02", vBonePos );

#ifdef ADD_MEMO_1ST_CLASS //김창한
		CX2DamageEffect::CEffect* pEffect =
#endif //ADD_MEMO_1ST_CLASS
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Hornet_Sting_Shaped_Charge", GetPowerRate(), vBonePos,
			GetRotateDegree(), GetRotateDegree() );

#ifdef ADD_MEMO_1ST_CLASS //김창한
		if( true == GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO16 ) && NULL != pEffect )
		{
			pEffect->SetDamageTime( pEffect->GetDamageTime() + 2 );
		}
#endif //ADD_MEMO_1ST_CLASS

	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EEG_Hornet_Sting_Shaped_Charge_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	WALK_CANCEL_AFTER( m_fWalkCancelAfter )
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	DASH_CANCEL_AFTER( m_fDashCancelAfter )

	CommonEventProcess();
}
#pragma endregion 호넷 스팅 - 쉐이프트 차지

#pragma region 
void CX2GUEve::ENSI_SA_ENS_Atomic_Blaster_SonicGun_Init()
{
	XMeshReadyInBackground( L"Eve_Atomic_Blaster_GunFire01.Y" );
	XSkinMeshReadyInBackground( L"Eve_SI_SA_ENS_Atomic_Blaster_Mesh01.X" );
	XSkinMeshReadyInBackground( L"Eve_SI_SA_ENS_Atomic_Blaster_Mesh02.X" );
}

void CX2GUEve::ENSI_SA_ENS_Atomic_Blaster_SonicGun_Start()
{
	CommonStateStart();

	m_fEffectStartTime = 0.79f;
	m_vSonicGunRotate = GetRotateDegree();
}

void CX2GUEve::ENSI_SA_ENS_Atomic_Blaster_SonicGun_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", 0.01f, 0 );

	D3DXVECTOR3 vUnitPos	= GetPos();
	D3DXVECTOR3 vBonePos	= GetBonePos( L"Bip01_Pelvis" );

	if ( m_fEffectStartTime <= 1.357f
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    && m_pXSkinAnim->EventTimerOneshot( m_fEffectStartTime ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
        && m_pXSkinAnim->EventTimer( m_fEffectStartTime ) == true && EventCheck( m_fEffectStartTime, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		g_pX2Game->GetDamageEffect()->CreateInstance( this, L"EVE_NS_ATOMIC_BLASTER_SONICGUN_DUMMY", GetPowerRate(), vBonePos,
			m_vSonicGunRotate, m_vSonicGunRotate );

		m_fEffectStartTime += 0.072f;
		m_vSonicGunRotate.z += 6.f;
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_ENS_Atomic_Blaster_SonicGun_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	ELSE_IF_ARROW_ZXASDC_PRESSED_AFTER( m_fAttackCancelAfter )
	{
		StateChange( USI_WAIT );
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
	WALK_CANCEL_AFTER( m_fWalkCancelAfter )
	DASH_CANCEL_AFTER( m_fDashCancelAfter )

	CommonEventProcess();
}
#pragma endregion 아토믹 블래스터 - 소닉건


#pragma region SI_SA_SA_EEL_SWEEP_ROLLING_TRI_VULCAN
void CX2GUEve::ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Ready_Init()
{
	XMeshReadyInBackground( L"eve_SA_photonFlare_lightLine.Y" );
	TextureReadyInBackground( L"eve_SA_photonFlare_lightLine.tga" );
	TextureReadyInBackground( L"WhitePoint.tga" );
	TextureReadyInBackground( L"Explosion_Sphere.tga" );
	TextureReadyInBackground( L"AeroTornado04.tga" );
	TextureReadyInBackground( L"Particle_Blur.tga" );
	TextureReadyInBackground( L"WhiteCircle02.tga" );
	TextureReadyInBackground( L"CenterLight_Gray01.tga" );
}
void CX2GUEve::ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Ready_Start()
{
	CommonStateStart();
	m_fPlaneZAngle = 0.f;
}

void CX2GUEve::ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Ready_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy1_Rhand", 0.01f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( 0.f, 7.0f, 140.f, 130.f, L"EveProtoPuritySweepParadePlane" );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Ready_EventProcess()
{
	if( m_InputData.pureUp == true )
	{
		m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
	}
	else if( m_InputData.pureDown == true )
	{
		m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
	}
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		StateChange( ENSI_SA_EEN_SWEEP_ROLLING_TRI_VULCAN_FIRE );
	}
	CommonEventProcess();
}

//////// FIRE ///////////
void CX2GUEve::ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Fire_Start()
{
	CommonStateStart();
	
	m_fEffectStartTime = 0.0;
	m_FrameDataNow.stateParam.bSuperArmorNotRed = false;
}

void CX2GUEve::ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Fire_FrameMove()
{	
	D3DXVECTOR3 vDamageEffectPos = GetBonePos( L"Bip01_R_Hand" );

	if(GetIsRight() == true)
		vDamageEffectPos += ( 50.f * GetDirVector() );
	else
		vDamageEffectPos -= ( 50.f * GetDirVector() );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.001f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.001f ) == true && EventCheck( 0.001f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		CX2DamageEffect::CEffect* pEffect = NULL;
		
#ifdef ADD_MEMO_1ST_CLASS //김창한
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO22 ) == true )
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Triangle_Vulcan_Bullet_MEMO", GetPowerRate(),
				vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
		else
#endif //ADD_MEMO_1ST_CLASS
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Triangle_Vulcan_Bullet", GetPowerRate(),
			vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

		if( NULL != pEffect )
			m_EveElectraSystem.AddEffectToSystem( pEffect );

		m_fEffectStartTime += 0.2f;
	}
	else if ( EventTimer( m_fEffectStartTime, false ) == true )
	{
		if ( m_fEffectStartTime > 3.0 )
		{
			if ( GetNowMp() < 10.f )
			{
#ifdef ALWAYS_SCREEN_SHOT_TEST
				if( g_pInstanceData != NULL && g_pInstanceData->GetScreenShotTest() == true)
				{
					return;
				}
#endif ALWAYS_SCREEN_SHOT_TEST
				g_pX2Game->GetInfoTextManager().PushText( XUF_DODUM_20_BOLD, GET_STRING( STR_ID_2549 ), D3DXCOLOR(1,1,1,1), D3DXCOLOR(0,0,0,1), DT_CENTER, 1.f, 1.f );
				StateChange( ENSI_SA_EEN_SWEEP_ROLLING_TRI_VULCAN_END );
				return;
			}
			else
			{
				UpNowMp( - 10.f );
			}
		}

		CX2DamageEffect::CEffect* pEffect = NULL;

#ifdef ADD_MEMO_1ST_CLASS //김창한
		if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO22 ) == true )
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Triangle_Vulcan_Bullet_MEMO", GetPowerRate(),
			vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
		else
#endif //ADD_MEMO_1ST_CLASS
		pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Triangle_Vulcan_Bullet", GetPowerRate(),
			vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );
		
		if( NULL != pEffect )
			m_EveElectraSystem.AddEffectToSystem( pEffect );

		m_fEffectStartTime += 0.2f;
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Fire_EventProcess()
{
	if( m_InputData.pureUp == true )
	{
		m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
	}
	else if( m_InputData.pureDown == true )
	{
		m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
	}

	if( ( m_eSpecialAttackKeyPressed == SAKP_A && m_InputData.pureA != true || m_eSpecialAttackKeyPressed == SAKP_S && m_InputData.pureS != true
		|| m_eSpecialAttackKeyPressed == SAKP_D && m_InputData.pureD != true || m_eSpecialAttackKeyPressed == SAKP_C && m_InputData.pureC != true 
		|| m_eSpecialAttackKeyPressed == SAKP_Q && m_InputData.pureQ != true || m_eSpecialAttackKeyPressed == SAKP_W && m_InputData.pureW != true 
		|| m_eSpecialAttackKeyPressed == SAKP_E && m_InputData.pureE != true || m_eSpecialAttackKeyPressed == SAKP_R && m_InputData.pureR != true )
		&& m_fEffectStartTime >= 3.0f )
	{
		StateChange( ENSI_SA_EEN_SWEEP_ROLLING_TRI_VULCAN_END );
	}
	else if( EventTimer( 4.9f, true ) == true )
	{
		StateChange( ENSI_SA_EEN_SWEEP_ROLLING_TRI_VULCAN_END );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_Fire_End()
{
	CommonStateEnd();
	m_FrameDataNow.stateParam.bSuperArmorNotRed = true;
}

void CX2GUEve::ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_End_Start()
{
	CommonStateStart();
}

void CX2GUEve::ENSI_SA_EEL_Sweep_Rolling_Tri_Vulcan_End_EventProcess()
{
	if( EventTimer( 1.0f, true ) == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	WALK_CANCEL_AFTER( m_fWalkCancelAfter )
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	DASH_CANCEL_AFTER( m_fDashCancelAfter )

	CommonEventProcess();
}
#pragma endregion 스위프 롤링 - 트라이 발칸

#pragma region SI_SA_EAT_HEAVENS_FIST_SWEEPER
void CX2GUEve::ENSI_SA_EAT_Heavens_Fist_Sweeper_Init()
{		
	XSkinMeshReadyInBackground( L"SI_SA_EAT_HEAVENS_FIST_Effect_King_Hand.X" );
	XSkinMeshReadyInBackground( L"SI_SA_EAT_HEAVENS_FIST_Effect_Light01.X" );
	XSkinMeshReadyInBackground( L"SI_SA_EAT_HEAVENS_FIST_Effect_Light02.X" );
	XSkinMeshReadyInBackground( L"SI_SA_EAT_HEAVENS_FIST_Effect_Bottom_Light.X" );
	XSkinMeshReadyInBackground( L"SI_SA_EAT_HEAVENS_FIST_Effect_Hole.X" );
}

void CX2GUEve::ENSI_SA_EAT_Heavens_Fist_Sweeper_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Bip01_Spine1", 0.01f, 2 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//여왕의 지배력 파워수치를 이펙트 셋에 전달.
		float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();

		if( g_pX2Game != NULL && g_pX2Game->GetEffectSet() != NULL )
		{
			CX2EffectSet::Handle hFist = INVALID_EFFECTSET_HANDLE;
			//CX2EffectSet::Handle hFistEffect = INVALID_EFFECTSET_HANDLE;
			D3DXVECTOR3 vPos = GetPos();

			if ( GetIsRight() )
			{
				vPos += GetDirVector() * 300.f;
				D3DXVECTOR3 vScale = GetVec3ScaleByUnit();
				//#ifdef ADD_MEMO_1ST_CLASS //김창한   - Effectset_SA_EAT_HEAVENS_FIST_SWEEPER_Nodamage 이펙트셋이 존재하지 않음. ??? 일단 주석 처리
				/*hFistEffect = g_pX2Game->GetEffectSet()->PlayEffectSet( L"Effectset_SA_EAT_HEAVENS_FIST_SWEEPER_Nodamage",
					(CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned, -1.f, GetVec3ScaleByUnit(), true,
					vPos, GetRotateDegree(), GetDirVector() );*/

#ifdef ADD_MEMO_1ST_CLASS //김창한
				if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO21 ) == true )
					hFist = g_pX2Game->GetEffectSet()->PlayEffectSet( L"Effectset_SA_EAT_HEAVENS_FIST_SWEEPER_Right_MEMO",
					(CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned, -1.f, GetVec3ScaleByUnit(), true,
					vPos, GetRotateDegree(), GetDirVector() );
				else
#endif //ADD_MEMO_1ST_CLASS
				hFist = g_pX2Game->GetEffectSet()->PlayEffectSet( L"Effectset_SA_EAT_HEAVENS_FIST_SWEEPER_Right",
					(CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned, -1.f, GetVec3ScaleByUnit(), true,
					vPos, GetRotateDegree(), GetDirVector() );
			}
 			else
			{
				vPos -= GetDirVector() * 300.f;
				//#ifdef ADD_MEMO_1ST_CLASS //김창한   - Effectset_SA_EAT_HEAVENS_FIST_SWEEPER_Nodamage 이펙트셋이 존재하지 않음. ??? 일단 주석 처리
				/*hFistEffect = g_pX2Game->GetEffectSet()->PlayEffectSet( L"Effectset_SA_EAT_HEAVENS_FIST_SWEEPER_Nodamage",
					(CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned, -1.f, GetVec3ScaleByUnit(), true,
					vPos, GetRotateDegree() + D3DXVECTOR3( 0, 0, 180 ), GetDirVector() );*/

#ifdef ADD_MEMO_1ST_CLASS //김창한
				if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO21 ) == true )
					hFist = g_pX2Game->GetEffectSet()->PlayEffectSet( L"Effectset_SA_EAT_HEAVENS_FIST_SWEEPER_MEMO",
					(CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned, -1.f, GetVec3ScaleByUnit(), true,
					vPos, GetRotateDegree() + D3DXVECTOR3( 0, 180, 0 ), GetDirVector() );
				else
#endif //ADD_MEMO_1ST_CLASS
				hFist = g_pX2Game->GetEffectSet()->PlayEffectSet( L"Effectset_SA_EAT_HEAVENS_FIST_SWEEPER",
 					(CX2GameUnit*)this, NULL, false, GetPowerRate() * fStatAtkRateOfSummoned, -1.f, GetVec3ScaleByUnit(), true,
 					vPos, GetRotateDegree() + D3DXVECTOR3( 0, 180, 0 ), GetDirVector() );
			}
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( 1.241f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( 1.241f ) == true && EventCheck( 1.241f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		UpDownCrashCamera( 80.f, 1.0f );
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EAT_Heavens_Fist_Sweeper_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	WALK_CANCEL_AFTER( m_fWalkCancelAfter )
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	DASH_CANCEL_AFTER( m_fDashCancelAfter )

	CommonEventProcess();
}
#pragma endregion 헤븐즈 피스트 - 스위퍼

#pragma region SI_SA_ENS_ASSUALT_SPEAR
void CX2GUEve::ENSI_SA_ENS_Assualt_Spear_Init()
{
	XSkinMeshReadyInBackground( L"Sp2a_Spear_Fly.X" );
}

void CX2GUEve::ENSI_SA_ENS_Assualt_Spear_FrameMove()
{
	ChangeWorldColorByHyperMode();
	ShowActiveSkillCutInAndLight( L"Bip01_L_Finger11", 0.01f, 2 );
		
	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_ENS_Assualt_Spear_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	WALK_CANCEL_AFTER( m_fWalkCancelAfter )
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	DASH_CANCEL_AFTER( m_fDashCancelAfter )
	
	CommonEventProcess();
}
#pragma endregion 어설트 스피어 - 네메시스

#pragma region ENSI_A_EEP_SPIT_FIRE_GRENADE
void CX2GUEve::ENSI_A_EEP_Spit_Fire_Grenade_Init()
{
	XSkinMeshReadyInBackground( L"Eve_EP_SI_SA_Spit_Fire_Mesh01.X" );
	XSkinMeshReadyInBackground( L"Eve_EP_SI_SA_Spit_Fire_Mesh02.X" );
	XMeshReadyInBackground( L"Wind_Liner02.Y" );
	TextureReadyInBackground( L"GuideArrow02.tga" );
	TextureReadyInBackground( L"ColorBallGray.tga" );
}

void CX2GUEve::ENSI_A_EEP_Spit_Fire_Grenade_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.1f ) == true && EventCheck( 0.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		//여왕의 지배력 파워수치를 이펙트 셋에 전달.
		float fStatAtkRateOfSummoned = GetStatAtkRateOfSummoned();

		if( g_pX2Game != NULL && g_pX2Game->GetEffectSet() != NULL )
		{
			bool bHyper = false;
			if ( GetRemainHyperModeTime() > 0.f )
				bHyper = true;

			g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_EEP_Spit_Fire_Grenade", (CX2GameUnit*)this, NULL, bHyper,
				GetPowerRate() * fStatAtkRateOfSummoned );
		}
	}
	CommonFrameMove();
}
void CX2GUEve::ENSI_A_EEP_Spit_Fire_Grenade_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	WALK_CANCEL_AFTER( m_fWalkCancelAfter )
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	DASH_CANCEL_AFTER( m_fDashCancelAfter )

	CommonEventProcess();
}
#pragma endregion 스핏 파이어 - 그레네이드

#pragma region SI_A_EBS_KUGELBLITZ
bool CX2GUEve::IsUpSkillSlotKugelBlitz()
{
	bool bIsKugelBlitzSuccess = false;
	if( m_sKugelBlitz_Data.m_bEnable == true )
	{
		//키가 업된는지 체크.
		switch( m_sKugelBlitz_Data.GetSkillSlotID() )
		{
		case 0: if( m_InputData.pureA == false && m_InputData.oneA == false ) 
					bIsKugelBlitzSuccess = true;
			break;
		case 1: if( m_InputData.pureS == false && m_InputData.oneS == false ) 
					bIsKugelBlitzSuccess = true;
			break;
		case 2: if( m_InputData.pureD == false && m_InputData.oneD == false ) 
					bIsKugelBlitzSuccess = true;
			break;
		case 3: if( m_InputData.pureC == false && m_InputData.oneC == false ) 
					bIsKugelBlitzSuccess = true;
			break;
		case 4: if( m_InputData.pureQ == false && m_InputData.oneQ == false ) 
					bIsKugelBlitzSuccess = true;
			break;
		case 5: if( m_InputData.pureW == false && m_InputData.oneW == false ) 
					bIsKugelBlitzSuccess = true;
			break;
		case 6: if( m_InputData.pureE == false && m_InputData.oneE == false ) 
					bIsKugelBlitzSuccess = true;
			break;
		case 7: if( m_InputData.pureR == false && m_InputData.oneR == false ) 
					bIsKugelBlitzSuccess = true;
			break;

		default: // 시전시에 데이터 저장이 제대로 이루어 지지 않았을 경우.
			m_sKugelBlitz_Data.Reset( false, &AccessFutureFrameData() );
			break;;
		}
	}

	return bIsKugelBlitzSuccess;
}


const CX2UserSkillTree::SkillSlotData* CX2GUEve::GetSkillSlotDataKugelBlitz( IN const CX2UserSkillTree& cUserSkillTree_, OUT int& iSkillSlotIndexPressed_ )
{
	//키처리까지 끝나면 데이터 검색

	int iSlotIndex = ( m_sKugelBlitz_Data.GetSkillSlotID() > 3 ) ? m_sKugelBlitz_Data.GetSkillSlotID()-4 : m_sKugelBlitz_Data.GetSkillSlotID();
	bool bSlotB = ( m_sKugelBlitz_Data.GetSkillSlotID() > 3 ) ? true : false;


	const CX2UserSkillTree::SkillSlotData* pSkillSlotData = cUserSkillTree_.GetSkillSlot( iSlotIndex, bSlotB );

	if( CX2SkillTree::SI_NONE == pSkillSlotData->m_eID || CX2SkillTree::SI_A_EBS_KUGELBLITZ != pSkillSlotData->m_eID)
	{
		m_sKugelBlitz_Data.Reset( false, &AccessFutureFrameData() );
		return NULL;
	}

	const CX2SkillTree::SkillTemplet* pSkillTemplet = g_pData->GetSkillTree()->GetSkillTemplet( pSkillSlotData->m_eID );

	if( NULL == pSkillTemplet )
	{
		m_sKugelBlitz_Data.Reset( false, &AccessFutureFrameData() );
		return NULL;
	}
		
	m_sKugelBlitz_Data.Reset( false, &AccessFutureFrameData() );
	iSkillSlotIndexPressed_ = m_sKugelBlitz_Data.GetSkillSlotID();

	return pSkillSlotData;
}

void CX2GUEve::SKugelBlitz_Data::Reset(bool bIsChargeTrue /* = true */, FrameData* pFrameDataFuture /* = NULL  */)
{
	if( bIsChargeTrue == false && pFrameDataFuture != NULL )
	{
		pFrameDataFuture->syncData.nowAction = UAI_KUGELBLITZ_CHARGE_FAIL;
	}

	m_bEnable		= false;
	m_bIsSucCharge	= false;

	ResetParticle();

	g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_FullCharge.ogg" );
	g_pKTDXApp->GetDeviceManager()->StopSound( L"Eve_MEB_Condense_power.ogg" );
}

void CX2GUEve::SKugelBlitz_Data::ResetParticle()
{
	for( int i = 0; i < ARRAY_SIZE( m_ahMajorParticleInstance ); ++i )
	{
		if( m_ahMajorParticleInstance[i] != INVALID_PARTICLE_SEQUENCE_HANDLE )
			g_pX2Game->GetMajorParticle()->DestroyInstanceHandle( m_ahMajorParticleInstance[i] );
		m_ahMajorParticleInstance[i] = INVALID_PARTICLE_SEQUENCE_HANDLE;
	}
}

void CX2GUEve::ResetKugelBlitzCharge()
{
	if( m_sKugelBlitz_Data.m_bEnable == true )
		m_sKugelBlitz_Data.Reset( false, &AccessFutureFrameData() );
}

void CX2GUEve::ENSI_A_EBS_Kugelblitz_StartFuture()
{
	CommonStateStartFuture();

	m_bDisableGravity = true;
	m_PhysicParam.nowSpeed.x = 0.f;
	m_PhysicParam.nowSpeed.y = 0.f;
}

void CX2GUEve::ENSI_A_EBS_Kugelblitz_Start()
{
	CommonStateStart();

	if( (m_sKugelBlitz_Data.m_dMaxTime * 0.5) >= m_sKugelBlitz_Data.m_timerElapsedTime.elapsed() )
		m_sKugelBlitz_Data.m_ChargeRank = CR_RANK_1;
	else if( m_sKugelBlitz_Data.m_dMaxTime >= m_sKugelBlitz_Data.m_timerElapsedTime.elapsed() )
		m_sKugelBlitz_Data.m_ChargeRank = CR_RANK_2;
	else if( m_sKugelBlitz_Data.m_dMaxTime < m_sKugelBlitz_Data.m_timerElapsedTime.elapsed() )
		m_sKugelBlitz_Data.m_ChargeRank = CR_RANK_3;
	else
		m_sKugelBlitz_Data.m_ChargeRank = CR_RANK_1;

	m_fPlaneZAngle	= 0.f;
	m_sKugelBlitz_TinyData.reset();
	m_sKugelBlitz_TinyData.m_timerElapsedTime = m_sKugelBlitz_Data.m_timerElapsedTime;
	m_sKugelBlitz_TinyData.m_ChargeRank = m_sKugelBlitz_Data.m_ChargeRank;
}

void CX2GUEve::ENSI_A_EBS_Kugelblitz_FrameMoveFuture()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 0.66f )
	{			
		m_bDisableGravity = false;
	}

	CommonFrameMoveFuture();
}

void CX2GUEve::ENSI_A_EBS_Kugelblitz_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.406f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.406f ) == true && EventCheck( 0.406f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( m_fPlaneZAngle, 2.0f, 240.f, 130.f );
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.416f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.416f ) == true && EventCheck( 0.416f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		// MP 소모
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_A_EBS_KUGELBLITZ );

		float fMPConsumption = 0.f;
		float fPowerRate = 1.f;
		float fScale = 0.f;
		int iCount = 0;
		wstring wstrDamageEffect = L"";

		if( NULL != pSkillTemplet )
		{
			if ( NULL == GetUnit() )
				return;
	
			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;
	
			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨
	
			switch( m_sKugelBlitz_TinyData.m_ChargeRank )
			{
			case CR_RANK_1: 
				{
					wstrDamageEffect	= L"Damage_KugelBlitz_Charge";
					fScale				= 1.5f;
				} break;
			case CR_RANK_2: 
				{
					wstrDamageEffect	= L"Damage_KugelBlitz_Charge";
					fScale				= 1.5f + ((pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_SIZE, iSkillTempletLevel ) - 1) / 2.f );
				} break;
			case CR_RANK_3: 
				{
					wstrDamageEffect	= L"Damage_KugelBlitz_Charge";
					fScale				= 1.5f + pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_SIZE, iSkillTempletLevel );
				} break;
			}

			fMPConsumption	= pSkillTemplet->GetSkillMPConsumptionValue( iSkillTempletLevel );
			fPowerRate		= static_cast<float>( GetPowerRate() * ( min( m_sKugelBlitz_TinyData.m_timerElapsedTime.elapsed(), 3.f) / 3.f + 1.f ) );
			iCount			= static_cast<int>( pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_PROJECTILE_PIERCING, iSkillTempletLevel ) * 
							  min( m_sKugelBlitz_TinyData.m_timerElapsedTime.elapsed(), 3.f) / 3.f );
			m_sKugelBlitz_TinyData.m_iAddDamageTime = iCount;
		}
		else
		{
			fMPConsumption = 20.f;
		}

		if( FlushMp( fMPConsumption ) == true ) 
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Bip01_R_Hand" );

			if( true == GetIsRight() )
			{
				vBonePos += GetDirVector() * 70.f;
			}
			else
			{
				vBonePos -= GetDirVector() * 70.f;
			}

			CKTDGParticleSystem::CParticleEventSequence* pSeq = 
				g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this, L"EBS_A_TASER_PILUM_fire_P01", vBonePos );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}

			pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"EBS_A_TASER_PILUM_fire_P02", vBonePos );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}

			pSeq = g_pX2Game->GetMajorParticle()->CreateSequence( (CKTDGObject*) this,  L"EBS_A_TASER_PILUM_fire_P03", vBonePos );
			if( NULL != pSeq )
			{
				pSeq->SetAddRotate( GetRotateDegree() );
				pSeq->SetAxisAngle( GetRotateDegree() );
			}

			CX2DamageEffect::CEffect* pEffect = NULL;

			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, wstrDamageEffect.c_str(), fPowerRate, vBonePos,
				GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y, false, -1.f, 1.f, 1.f );

			pEffect->SetDamageTime( pEffect->GetDamageTime() + iCount );
			pEffect->GetDamageData().bReAttack = true;

			if( pEffect != NULL )
			{
				pEffect->SetScale( fScale, fScale, fScale );
				pEffect->SetInheritForceDownRate(true);
			}

			if( NULL != pEffect )
			{
				wstrDamageEffect += L"_FILTERED";

				m_EveElectraSystem.AddEffectToSystem( pEffect, wstrDamageEffect.c_str(), wstrDamageEffect.c_str(),
					wstrDamageEffect.c_str(), wstrDamageEffect.c_str());
			}

			PlaySound( L"Eve_FireShot1.ogg" );
		}
		else
		{
			D3DXVECTOR3 vBonePos = GetBonePos( L"Dummy2_Lhand" );
			CreateNotEnoughMPEffect( vBonePos, 0.f, 0.f, 0.f );
		}
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_A_EBS_Kugelblitz_EventProcess()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.4f )
	{
		if( m_InputData.pureUp == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
		}
		else if( m_InputData.pureDown == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
		}
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.36f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.36f ) == true && EventCheck( 0.36f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_bDisableGravity = false;
	}

	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

void CX2GUEve::ENSI_A_EBS_Kugelblitz_EndFuture()
{
	m_bDisableGravity = false;
	CommonStateEndFuture();
}
#pragma endregion 쿠글블릿츠

#pragma region SI_SA_EEL_LINEAR_DIVIDER
void CX2GUEve::ENSI_SA_EEL_LINEAR_DIVIDER_Init()
{
}
void CX2GUEve::ENSI_SA_EEL_LINEAR_DIVIDER_Start()
{
	CommonStateStart();
	m_fPlaneZAngle	= 0.f;
}

void CX2GUEve::ENSI_SA_EEL_LINEAR_DIVIDER_StartFuture()
{
	CommonStateStartFuture();
	m_bApplyMotionOffset = false;
}

void CX2GUEve::ENSI_SA_EEL_LINEAR_DIVIDER_FrameMoveFuture()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnimFuture->EventTimerOneshot( 0.01f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnimFuture->EventTimer( 0.01f ) == true && EventCheck( 0.01f, true ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_PhysicParam.nowSpeed.x = 0.f;
	}

	CommonFrameMoveFuture();
}

void CX2GUEve::ENSI_SA_EEL_LINEAR_DIVIDER_FrameMove()
{
	ChangeWorldColorByHyperMode();

	ShowActiveSkillCutInAndLight( L"Dummy1_Rhand", 0.01f, 0 );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.02f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.02f ) == true && EventCheck( 0.02f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.CreatePlane( 0.f, 3.0f, 110.f, 130.f );
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.4f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		m_EveElectraSystem.m_fPlaneZAngle = m_fPlaneZAngle;
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.5f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.5f ) == true && EventCheck( 0.5f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if( m_fPlaneZAngle > 0 && m_EveElectraSystem.GetEnablePlane() == true )
			m_EveElectraSystem.CreateGigaPlane( m_fPlaneZAngle, 2.5f, 110.f + 120.f, 130.f + 69.24f );
		else if( m_fPlaneZAngle < 0 && m_EveElectraSystem.GetEnablePlane() == true )
			m_EveElectraSystem.CreateGigaPlane( m_fPlaneZAngle, 2.5f, 110.f + 120.f, 130.f - 69.24f );
		else
			m_EveElectraSystem.CreateGigaPlane( m_fPlaneZAngle, 2.5f, 110.f + 139.56f, 130.f );
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.9f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.9f ) == true && EventCheck( 0.9f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		D3DXVECTOR3 vDamageEffectPos = GetPos();
		vDamageEffectPos.y += 130.f;
		D3DXVECTOR3 vZeroYDirVector = GetDirVector();
		vZeroYDirVector.y = 0.f;
		D3DXVec3Normalize( &vZeroYDirVector, &vZeroYDirVector );
		
		if(GetIsRight() == false)
		{
			vZeroYDirVector.x = -vZeroYDirVector.x;
			vZeroYDirVector.z = -vZeroYDirVector.z;
		}
		vDamageEffectPos += (100.f * vZeroYDirVector);

		CX2DamageEffect::CEffect* pEffect = NULL;
		CX2DamageEffect::CEffect* pEffect_Reverse = NULL;

		if( GetRemainHyperModeTime() > 0.f )
		{
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Linear_Divider_Hyper", GetPowerRate(),
				vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

			float fDistance = 7000.f;
#ifdef ADD_MEMO_1ST_CLASS //김창한
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO24 ) == true )
				fDistance *= 1.3f;
#endif //ADD_MEMO_1ST_CLASS

			m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, fDistance, 0.3f, 0.7f, 
				L"DamageEffect_Linear_Divider_Hyper_Next", L"DamageEffect_Linear_Divider_Hyper_Next",
				L"DamageEffect_Linear_Divider_Hyper_Next", false );

			pEffect_Reverse = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Linear_Divider_Hyper_Reverse", GetPowerRate(),
				vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

			vZeroYDirVector.y = -vZeroYDirVector.y;
			m_EveElectraSystem.AddLaserToSystem( pEffect_Reverse, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, fDistance, 0.3f, 0.7f, 
				L"DamageEffect_Linear_Divider_Hyper_Next_Reverse", L"DamageEffect_Linear_Divider_Hyper_Next_Reverse",
				L"DamageEffect_Linear_Divider_Hyper_Next_Reverse", false );
		}
		else
		{
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Linear_Divider", GetPowerRate(),
				vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

			float fDistance = 7000.f;
#ifdef ADD_MEMO_1ST_CLASS //김창한
			if( GetEqippedSkillMemo( CX2SkillTree::SMI_EVE_MEMO24 ) == true )
				fDistance *= 1.3f;
#endif //ADD_MEMO_1ST_CLASS

			m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, fDistance, 0.3f, 0.8f, 
				L"DamageEffect_Linear_Divider_Next", L"DamageEffect_Linear_Divider_Next",
				L"DamageEffect_Linear_Divider_Next", false );

			pEffect_Reverse = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DamageEffect_Linear_Divider_Reverse", GetPowerRate(),
				vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

			m_EveElectraSystem.AddLaserToSystem( pEffect_Reverse, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, fDistance, 0.3f, 0.8f, 
				L"DamageEffect_Linear_Divider_Next_Reverse", L"DamageEffect_Linear_Divider_Next_Reverse",
				L"DamageEffect_Linear_Divider_Next_Reverse", false );
		}
	}

	CommonFrameMove();
}

void CX2GUEve::ENSI_SA_EEL_LINEAR_DIVIDER_EventProcess()
{
	if( m_pXSkinAnimFuture->GetNowAnimationTime() < 0.4f )
	{
		if( m_InputData.pureUp == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_UP;
		}
		else if( m_InputData.pureDown == true )
		{
			m_FrameDataFuture.syncData.nowAction = UAI_ELECTRA_PLANE_ANGLE_DOWN;
		}
	}

	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
	WALK_CANCEL_AFTER( m_fWalkCancelAfter )
	DASH_CANCEL_AFTER( m_fDashCancelAfter )
	
	CommonEventProcess();
}

void CX2GUEve::ENSI_SA_EEL_LINEAR_DIVIDER_End()
{
	CommonStateEnd();
	m_EveElectraSystem.DeleteLaserFromSystem();
}
#pragma endregion 드레드 쇼크

#endif //UPGRADE_SKILL_SYSTEM_2013

#ifdef FINALITY_SKILL_SYSTEM //김창한
//엠프레스, 링크 오버차지 일루전 
void CX2GUEve::ENSI_HA_EEP_LINK_OVERCHARGE_ILLUSION_Init()
{
	XSkinMeshReadyInBackground(L"CHARGING BOOSTER.X");
	TextureReadyInBackground(L"Eve_Sp1a_SumonCircle01.dds");
	TextureReadyInBackground(L"Explosion_Sphere.dds");
}
void CX2GUEve::ENSI_HA_EEP_LINK_OVERCHARGE_ILLUSION_Start()
{
	CommonStateStart();
}
void CX2GUEve::ENSI_HA_EEP_LINK_OVERCHARGE_ILLUSION_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.8f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.8f ) == true && EventCheck( 0.8f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet(CX2SkillTree::SI_HA_EEP_LINK_OVERCHARGE_ILLUSION );
		if( NULL != pSkillTemplet )
		{
			if ( NULL == GetUnit() )
				return;

			const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

			const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨

			m_fFerdinandLifeTime = static_cast<float>(pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_EFFECTIVE_TIME, iSkillTempletLevel ));
			m_fFerdinandLifeTime = max( 0, m_fFerdinandLifeTime );

			if( m_fFerdinandLifeTime > 0.f )
			{		
				SetActiveLinkOverChargeIllusion(true);
				m_timerFerdinandSummoned.restart();

				if( true == g_pX2Game->IsHost() )
				{
					D3DXVECTOR3 vPos = GetPos();
					if( true == GetIsRight() )
					{
						vPos += GetDirVector() * 300.f;
					}
					else
					{
						vPos -= GetDirVector() * 300.f;
					}
					
					int iHyperMode = GetHyperModeUsed()? 1 : 0;
					g_pX2Game->CreateNPCReq( CX2UnitManager::NUI_SI_HA_FERDINAND, iHyperMode, true, vPos, 
						GetIsRight(), 0.f, true, -1, (CX2Room::TEAM_NUM) GetTeam(), CX2NPCAI::NAT_ALLY, GetUnitUID(), false, CX2Room::TN_NONE, CX2GUNPC::NCT_CHANGESTAGE_REMAIN  );
				}
			}
			else
			{
				SetActiveLinkOverChargeIllusion( false );
				if ( IsMyUnit() )
					g_pX2Game->UpdateSkillSlotUI();
			}
		}
	}

	CommonFrameMove();
}
void CX2GUEve::ENSI_HA_EEP_LINK_OVERCHARGE_ILLUSION_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}
void CX2GUEve::ENSI_HA_EEP_LINK_OVERCHARGE_ILLUSION_End()
{
	if ( IsMyUnit() )
		g_pX2Game->UpdateSkillSlotUI();		/// 스킬 아이콘 갱신

	CommonStateEnd();
}
void CX2GUEve::ResetLinkOverChargeIllusion()
{
	if( true == IsMyUnit() )
	{	
		m_fFerdinandLifeTime = -1;
		m_iFerdinandNPCUID = -1;

		SetActiveLinkOverChargeIllusion( false );	/// 엠프레스 궁극기 - 링크 오버차지 썬더볼트 활성화 해제
		g_pX2Game->UpdateSkillSlotUI();				/// 스킬 아이콘 갱신

		const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet( CX2SkillTree::SI_HA_EEP_LINK_OVERCHARGE_ILLUSION );
		if( NULL != pSkillTemplet )
		{
			CX2UserSkillTree& cUserSkillTree =  GetUnit()->AccessUnitData().m_UserSkillTree;
			const int iSkillTempletLevel = max( 1, cUserSkillTree.GetSkillLevel( pSkillTemplet->m_eID ) );	/// 스킬 레벨

			const float CoolTime = pSkillTemplet->GetSkillCoolTimeValue( iSkillTempletLevel ) - static_cast<float>( m_timerFerdinandSummoned.elapsed() );

			cUserSkillTree.SetSkillCoolTimeLeft( CX2SkillTree::SI_HA_EEP_LINK_OVERCHARGE_ILLUSION, CoolTime );
		}
	}
}



// 네메시스, 루나틱 스커드
void CX2GUEve::ENSI_HA_ENS_LUNATIC_SCUD_Init()
{
	TextureReadyInBackground(L"Arme_Ring2.dds");
	TextureReadyInBackground(L"ColorBallGray.dds");
	TextureReadyInBackground(L"Inspector_State_Shield.tga");
	TextureReadyInBackground(L"WhitePoint.dds");
	TextureReadyInBackground(L"AeroTornado04.dds");
	TextureReadyInBackground(L"ColorBallBlue.dds");
	TextureReadyInBackground(L"Condense_Pulse01.dds");
	XSkinMeshReadyInBackground(L"HA_ENS_Lunatic_Scud_Weapon01.X");
	TextureReadyInBackground(L"Lire_Kick_Impact01.dds");
	XSkinMeshReadyInBackground(L"Lire_SI_SA_Gungnir_Mesh03.X");
	TextureReadyInBackground(L"Particle_Blur.dds");
	XSkinMeshReadyInBackground(L"aisha_active_energySpurt_circle.X");
	XSkinMeshReadyInBackground(L"EG_SP1a_HornetSting_Bomb.X");
	TextureReadyInBackground(L"Arme01_Frost_Ring_LV2_effect_01.dds");
	TextureReadyInBackground(L"eve_thousandsOfStars_gearLight.dds");
	TextureReadyInBackground(L"EEP_servant_call_slash_02.tga");
	TextureReadyInBackground(L"WhitePointSmall.dds");
	TextureReadyInBackground(L"Star.dds");
	TextureReadyInBackground(L"SlashLight.dds");
	XSkinMeshReadyInBackground(L"HA_ENS_Lunatic_Scud_Weapon02.X");
	TextureReadyInBackground(L"Lightning_Piercing01.dds");
	TextureReadyInBackground(L"Mesh_Raven_Event_AC_Upbody21_Effect.tga");
	TextureReadyInBackground(L"Particle_Frozen01.tga");
	TextureReadyInBackground(L"CenterLight_Gray01.dds");
	TextureReadyInBackground(L"Fire_Flame01.Tga");
	TextureReadyInBackground(L"GuideArrow01.dds");
	XSkinMeshReadyInBackground(L"HA_ENS_Lunatic_Scud_Weapon03.X");
	TextureReadyInBackground(L"Nasod_King_Laser03.dds");
	TextureReadyInBackground(L"Whitecircle02.dds");
	TextureReadyInBackground(L"smoke02.dds");
	TextureReadyInBackground(L"Arme_Critical2.dds");
	TextureReadyInBackground(L"GroundShockWave02.dds");
	XSkinMeshReadyInBackground(L"HA_ENS_Lunatic_Scud_Weapon04.X");
	TextureReadyInBackground(L"IceHit_Impact01.dds");
	TextureReadyInBackground(L"Smoke.dds");
	TextureReadyInBackground(L"eve_SA_sweepParade_middle.DDS");
	XSkinMeshReadyInBackground(L"HA_ENS_Lunatic_Scud_Weapon05.X");
	TextureReadyInBackground(L"AeroTornado07.dds");
	TextureReadyInBackground(L"Condense_Pulse02.dds");
	TextureReadyInBackground(L"Pet_unicorn_lightning_After.DDS");
	TextureReadyInBackground(L"RVC_SA_DeadlyRaid_spark.dds");
	TextureReadyInBackground(L"SpreadLight01.dds");
	TextureReadyInBackground(L"Steam_BP.DDS");
	TextureReadyInBackground(L"White_Pulse01.dds");
	TextureReadyInBackground(L"ran_StartB_light_P.dds");
	TextureReadyInBackground(L"trockBome_0_MagicAttackA_pieceCircle.dds");
	XSkinMeshReadyInBackground(L"DummyAttackBox_50x50x50");
}
void CX2GUEve::ENSI_HA_ENS_LUNATIC_SCUD_EventProcess()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}

	CommonEventProcess();
}

#endif //FINALITY_SKILL_SYSTEM

#ifdef FINALITY_SKILL_SYSTEM // 김종훈, 궁극기 시스템

// 배틀 세라프, 사이킥 아틸러리 
void CX2GUEve::ENSI_HA_EBS_PSYCHIC_ARTILLERY_Init()
{
	TextureReadyInBackground(L"AeroTornado04.dds");
	TextureReadyInBackground(L"Arme_Critical2.dds");
	TextureReadyInBackground(L"Arme_Ring2.dds");
	TextureReadyInBackground(L"CenterLight_Gray01.dds");
	TextureReadyInBackground(L"Colorballgray.dds");
	TextureReadyInBackground(L"Condense_Light01.dds");
	TextureReadyInBackground(L"Condense_Pulse02.dds");
	XSkinMeshReadyInBackground(L"Dullahan_Special_Laser_Mesh01.X");
	TextureReadyInBackground(L"Explosion_Fire01.dds");
	XSkinMeshReadyInBackground(L"HA_EBS_Dragon_Slave_M01.X");
	TextureReadyInBackground(L"Inspector_State_Shield.tga");
	XSkinMeshReadyInBackground(L"Lire_SI_SA_Gungnir_Mesh03.X");
	XSkinMeshReadyInBackground(L"Lire_SI_SA_Gungnir_Mesh05.X");
	XSkinMeshReadyInBackground(L"NEPHILIM_AttackB_02.X");
	TextureReadyInBackground(L"Particle_Blur.DDS");
	TextureReadyInBackground(L"Particle_Blur.dds");
	XSkinMeshReadyInBackground(L"Taranvash_SpecialAttackA_Mesh01.X");
	TextureReadyInBackground(L"WhitePoint.dds");
	TextureReadyInBackground(L"WhitePointSmall.dds");
	TextureReadyInBackground(L"White_Pulse01.dds");
	XSkinMeshReadyInBackground(L"aisha_active_energySpurt_circle.X");
	TextureReadyInBackground(L"eve_thousandsOfStars_gearLight.DDS");
}

void CX2GUEve::ENSI_HA_EBS_PSYCHIC_ARTILLERY_FrameMove()
{
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 0.4f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 0.4f ) == true && EventCheck( 0.8f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		// 역장 각도 초기화 ( 궁극기는 각도가 꺽이지 않는다. )
		m_EveElectraSystem.m_fPlaneZAngle = 0.f;
		// 1페이즈 역장 생성
		m_EveElectraSystem.CreateGigaPlane( 0.f, 2.5f, 110.f + 139.56f, 130.f, 1.f );
	}
	
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 1.2f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 1.2f ) == true && EventCheck( 1.2f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		// 1페이즈 레이저 그룹 발사
		D3DXVECTOR3 vDamageEffectPos = GetPos();
		vDamageEffectPos.y += 100.f;
		D3DXVECTOR3 vZeroYDirVector = GetDirVector();
		vZeroYDirVector.y = 0.f;
		D3DXVec3Normalize( &vZeroYDirVector, &vZeroYDirVector );


		if(GetIsRight() == false)
		{
			vZeroYDirVector.x = -vZeroYDirVector.x;
			vZeroYDirVector.z = -vZeroYDirVector.z;
		}
		vDamageEffectPos += (100.f * vZeroYDirVector);

		CX2DamageEffect::CEffect* pEffect = NULL;

		{
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DAMAGE_EFFECT_HA_EBS_Psychic_Artillery_Laser_Phase1_Before_Plane", GetPowerRate(),
				vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

			m_EveElectraSystem.AddLaserToSystem( pEffect, L"", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.3f, 1.0f, 
				L"DAMAGE_EFFECT_HA_EBS_Psychic_Artillery_Laser_Phase1_1", L"DAMAGE_EFFECT_HA_EBS_Psychic_Artillery_Laser_Phase1_1",
				L"DAMAGE_EFFECT_HA_EBS_Psychic_Artillery_Laser_Phase1_1", false );

		}
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 2.6f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 2.6f ) == true && EventCheck( 2.6f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 2.7f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 2.7f ) == true && EventCheck( 3.0f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		// 1페이즈 역장 제거 
		m_EveElectraSystem.DestroyGigaPlaneAndCrystalEffect();
		// 2페이즈 역장 생성
		m_EveElectraSystem.CreateGigaPlane( 0.f, 2.5f, 110.f + 139.56f - 90.f, 260.f, 2.f );
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 3.1f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 3.1f ) == true && EventCheck( 3.1f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		// 2페이즈 레이저 그룹 발사
		D3DXVECTOR3 vDamageEffectPos = GetBonePos( L"Bip01_L_Hand");
		D3DXVECTOR3 vZeroYDirVector = GetDirVector();
		vZeroYDirVector.y = 0.f;
		D3DXVec3Normalize( &vZeroYDirVector, &vZeroYDirVector );


		if(GetIsRight() == false)
		{
			vZeroYDirVector.x = -vZeroYDirVector.x;
			vZeroYDirVector.z = -vZeroYDirVector.z;
		}
		vDamageEffectPos -= (100.f * vZeroYDirVector);

		CX2DamageEffect::CEffect* pEffect = NULL;

		{
			pEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DAMAGE_EFFECT_HA_EBS_Psychic_Artillery_Laser_Phase2_Before_Plane", GetPowerRate(),
				vDamageEffectPos, GetRotateDegree(), GetRotateDegree() );

			m_EveElectraSystem.AddLaserToSystem( pEffect, L"Bip01_L_Hand", vDamageEffectPos, vZeroYDirVector, 10000.f, 0.3f, 1.0f, 
				L"DAMAGE_EFFECT_HA_EBS_Psychic_Artillery_Laser_Phase2_1", L"DAMAGE_EFFECT_HA_EBS_Psychic_Artillery_Laser_Phase2_1",
				L"DAMAGE_EFFECT_HA_EBS_Psychic_Artillery_Laser_Phase2_1", false );

		}
	}

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( 5.545f ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( 5.545f ) == true && EventCheck( 5.545f, false ) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		// 2페이즈 역장 제거
		m_EveElectraSystem.DestroyGigaPlaneAndCrystalEffect();
	}
	CommonFrameMove();	
}

void CX2GUEve::ENSI_HA_EBS_PSYCHIC_ARTILLERY_EventProcess()
{

	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
			StateChange( USI_JUMP_DOWN );
		else
			StateChange( USI_WAIT );
	}
	SKILL_CANCEL_AFTER( m_fSkillCancelAfter )
	BWALK_CANCEL_AFTER( m_fBWalkCancelAfter )
	WALK_CANCEL_AFTER( m_fWalkCancelAfter )
	DASH_CANCEL_AFTER( m_fDashCancelAfter )

	CommonEventProcess();
}

#endif // FINALITY_SKILL_SYSTEM // 김종훈, 궁극기 시스템


/*virtual*/ void CX2GUEve::ShowActiveSkillCutInAndLightByScript( float fTimeToShow_, bool bOnlyLight_ )
{
	ShowActiveSkillCutInAndLight( L"Dummy2_Lhand", fTimeToShow_, m_iSkillCutInSetSubIndex, bOnlyLight_ );
}

#ifdef MODIFY_RIDING_PET_AWAKE
void CX2GUEve::RidingHyperModeFrameMove()
{
	CommonHyperModeFrameMove(0.f, 0.1f, true);
}
void CX2GUEve::CommonHyperModeFrameMove( float fTime1_, float fTime2_, bool bSound_ /*= false*/  )
{
	g_pX2Game->GetWorld()->SetWorldColor( 0xff222222 );
	//g_pX2Game->GetWorld()->FadeWorldColor( g_pX2Game->GetWorld()->GetOriginColor(), 1.0f );

#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    if( m_pXSkinAnim->EventTimerOneshot( fTime1_ ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	if( m_pXSkinAnim->EventTimer( fTime1_ ) == true && EventCheck(fTime1_, false) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{		
		if( false == GetAbsoluteInvisibility() )
		{
			CKTDGParticleSystem::CParticleEventSequence* pSeqHyperModeChangeLine	= g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_HYPER_MODE_CHANGE_LINE ) );
			CKTDGParticleSystem::CParticleEventSequence* pSeqHyperModeChangeCenter	= g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_HYPER_MODE_CHANGE_CENTER ) );

			D3DXVECTOR3 pos = GetBonePos( L"Dummy1_Rhand" );
			if( pSeqHyperModeChangeLine != NULL )
			{
				pSeqHyperModeChangeLine->SetPosition( pos );
				pSeqHyperModeChangeLine->SetEmitRate( 40.0f, 80.0f );
				pSeqHyperModeChangeLine->SetTriggerCount( 10 );

				pSeqHyperModeChangeLine->SetBlackHolePosition( pos );
				pSeqHyperModeChangeLine->UseLookPoint( true );
				pSeqHyperModeChangeLine->SetLookPoint( pos );
			}
			if( pSeqHyperModeChangeCenter != NULL )
			{
				pSeqHyperModeChangeCenter->SetPosition( pos );
				pSeqHyperModeChangeCenter->SetEmitRate( 20.0f, 40.0f );
				pSeqHyperModeChangeCenter->SetTriggerCount( 10 );
			}
		}
	}
#ifdef  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
    else if( m_pXSkinAnim->EventTimerOneshot( fTime2_ ) )
#else   X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	else if( m_pXSkinAnim->EventTimer( fTime2_ ) == true && EventCheck(fTime2_, false) == true )
#endif  X2OPTIMIZE_NPC_ADAPTIVE_FRAME_MOVE
	{
		if( false == GetAbsoluteInvisibility() )
		{
			CKTDGParticleSystem::CParticleEventSequence* pSeqGroundShockWave	= g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_GROUND_SHOCK_WAVE ) );
			D3DXVECTOR3 pos = GetBonePos( L"Dummy1_Rhand" );
			if( pSeqGroundShockWave != NULL )
			{
				D3DXVECTOR3 posl = m_FrameDataNow.unitCondition.landPosition;
				posl.y += 5.0f;
				pSeqGroundShockWave->SetPosition( posl );
				pSeqGroundShockWave->SetEmitRate( 5.0f, 10.0f );
				pSeqGroundShockWave->SetTriggerCount( 3 );
			}

			CKTDGParticleSystem::CParticleEventSequence* pSeqWhiteShockWave		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_WHITE_SHOCK_WAVE ) );
			if( pSeqWhiteShockWave != NULL )
			{
				pSeqWhiteShockWave->SetPosition( pos );
				pSeqWhiteShockWave->SetEmitRate( 10.0f, 10.0f );
				pSeqWhiteShockWave->SetTriggerCount( 1 );
			}

			CKTDGParticleSystem::CParticleEventSequence* pSeqImpactTick 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_IMPACT_TICK ) );
			if( pSeqImpactTick != NULL )
			{
				pSeqImpactTick->SetPosition( pos );
				pSeqImpactTick->SetEmitRate( 200.0f, 200.0f );
				pSeqImpactTick->SetTriggerCount( 30 );
				pSeqImpactTick->SetLandPosition( m_FrameDataNow.unitCondition.landPosition.y );
			}
		}

		if ( GetShowSmallGageAndName() )
		{
			CKTDGParticleSystem::CParticleEventSequence* pSeqSTR_ToKang 		= g_pX2Game->GetMinorParticle()->GetInstanceSequence( GetHandleCommonMinorParticleByEnum( COMMON_MINOR_PII_STR_TOKANG ) );
			D3DXVECTOR2 projPos = g_pKTDXApp->GetProj3DPos( m_FrameDataNow.syncData.position );
			if( pSeqSTR_ToKang != NULL )
			{
				pSeqSTR_ToKang->SetPosition( D3DXVECTOR3( projPos.x, projPos.y, 0.0f ) );
				pSeqSTR_ToKang->SetEmitRate( 100.0f, 100.0f );
				pSeqSTR_ToKang->SetTriggerCount( 1 );
			}

			UpDownCrashCamera( 30.0f, 0.4f );
			g_pKTDXApp->GetDGManager()->ClearScreen();
		}

		//SetBoostPower( 30 );


		CKTDGParticleSystem::CParticleEventSequence* pSeq_RFoot = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostRFoot );
		CKTDGParticleSystem::CParticleEventSequence* pSeq_LFoot = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostLFoot );
		CKTDGParticleSystem::CParticleEventSequence* pSeq_RArm = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostRArm );
		CKTDGParticleSystem::CParticleEventSequence* pSeq_LArm = g_pX2Game->GetMinorParticle()->GetInstanceSequence( m_hHyperBoostLArm );




		if( pSeq_RFoot != NULL )
		{
			pSeq_RFoot->SetPosition( GetBonePos( L"Bip01_R_Foot" ) );
			pSeq_RFoot->SetEmitRate( 30, 40 );
		}
		if( pSeq_LFoot != NULL )
		{
			pSeq_LFoot->SetPosition( GetBonePos( L"Bip01_L_Foot" ) );
			pSeq_LFoot->SetEmitRate( 30, 40 );
		}
		if( pSeq_RArm != NULL )
		{
			pSeq_RArm->SetPosition( GetBonePos( L"Bip01_R_UpperArm" ) );
			pSeq_RArm->SetEmitRate( 30, 40 );
		}
		if( pSeq_LArm != NULL )
		{
			pSeq_LArm->SetPosition( GetBonePos( L"Bip01_L_UpperArm" ) );
			pSeq_LArm->SetEmitRate( 30, 40 );
		}

		if( pSeq_RFoot		!= NULL
			&& pSeq_LFoot	!= NULL
			&& pSeq_RArm 	!= NULL
			&& pSeq_LArm 	!= NULL )
		{
			pSeq_RFoot->SetTrace( true );
			pSeq_LFoot->SetTrace( true );
			pSeq_RArm->SetTrace( true );
			pSeq_LArm->SetTrace( true );


			if( true == GetAbsoluteInvisibility() )
			{
				pSeq_RFoot->SetShowObject( false );
				pSeq_LFoot->SetShowObject( false );
				pSeq_RArm->SetShowObject( false );
				pSeq_LArm->SetShowObject( false );
			}
			else
			{
				pSeq_RFoot->SetShowObject( true );
				pSeq_LFoot->SetShowObject( true );
				pSeq_RArm->SetShowObject( true );
				pSeq_LArm->SetShowObject( true );
			}
		}

		ApplyHyperModeBuff();

		if( true == bSound_ )
		{
			PlaySound( L"Energy.ogg" );
			PlaySound( L"Break.ogg" );
			PlaySound( L"Change.ogg" );
		}
	}
	CommonFrameMove();
}
#endif // MODIFY_RIDING_PET_AWAKE

#ifdef FIX_EVE_ELCRYSTAL_BUG
/** @function : OnFrameMove_EndElCrystalSystem
	@brief : 역장 버프 종료 시 처리해줘야 하는 동작			 
			 역장에 반응하는 스킬이 있을 때, 바로 제거 하지 않고, 스킬 종료 후 제거시키기 위한 함수
*/
void CX2GUEve::OnFrameMove_EndElCrystalSystem()
{
	if( true == m_bIsCheckEndElCrystal )
	{
		switch( m_eReserveEndElCrystalBuffID ) 
		{
		case BTI_BUFF_AMPLIFICATION_PLACE:
			{
				if ( PFT_AMPLIFIER == m_EveElectraSystem.GetPlaneFormation() )
					EndElCrystalSystem();
			} break;

		case BTI_BUFF_SPECTRUM_PLACE:
			{
				if ( PFT_SPECTRUM == m_EveElectraSystem.GetPlaneFormation() )
					EndElCrystalSystem();
			} break;

		case BTI_BUFF_INDUCTION_PLACE:
			{
				if ( PFT_INDUCTION == m_EveElectraSystem.GetPlaneFormation() )
					EndElCrystalSystem();
			} break;

#ifdef SERV_EVE_BATTLE_SERAPH		/// 초광학 연구
		case BTI_BUFF_SI_SA_EBS_ENERGETIC_HEART:
			{
				if ( PFT_FUSION == m_EveElectraSystem.GetPlaneFormation() )
				{
					m_EveElectraSystem.SetEnableExceptionSystem( false );
					const BUFF_TEMPLET_ID eBuffTempletID = 
						m_EveElectraSystem.GetBuffTempletIdByPlaneFormation( m_EveElectraSystem.m_ePrevSpectro );

					if ( BTI_NONE != eBuffTempletID )
					{
						if ( HaveThisBuff( eBuffTempletID ) )	/// 이전의 분광결정이 아직 끝나지 않았으면
						{		
							m_EveElectraSystem.SetPlaneFormation( m_EveElectraSystem.m_ePrevSpectro );

							if ( IsMyUnit() )
								g_pX2Game->UpdateSkillSlotUI();
						}
						else	/// 이전의 분광결정이 끝났으면
						{
							EndElCrystalSystem( true );
						}
					}
					else	/// 에너제틱 하트 이전에 진행 중인 역장이 없으면
					{
						EndElCrystalSystem( true );
					}

					g_pX2Game->GetEffectSet()->PlayEffectSet( L"EffectSet_Seraph_Energetic_Heart_End", this );
				}
				m_iAddBoostAttack = 0;
			} break;
#endif //SERV_EVE_BATTLE_SERAPH

		default:
			break;
		}

		m_eReserveEndElCrystalBuffID = BTI_NONE;
		m_bIsCheckEndElCrystal = false;
	}
}
#endif // FIX_EVE_ELCRYSTAL_BUG

#ifdef FIX_SHOOTING_MEGABALL_AT_JUMP_LINE_MAP
/*virtual*/void CX2GUEve::InitInpuDataProcess()
{
	// #특정 키는 제외하고 초기화 시키는 함수.
	auto InitInputDataExceptMegaBallKey = []( OUT InputData& sInputData_, OUT bool& bInputDataPureKey_)
	{
		if( true == bInputDataPureKey_ )
		{
			sInputData_.Init();
			bInputDataPureKey_ = true;
		}
		else
		{
			sInputData_.Init();
		}
	};

	if( m_fCanNotInputTimeZXArrow > 0.f )
	{
		m_InputData.Init_ZXArrowOnly();
	}

	if( true == IsCanNotIntput() )
	{
		// # 메가 일렉트론볼 충전중에는, 충전 키 유지시켜 주기
		if( m_sMegaElectronBallData.m_bEnable == true )
		{
			switch( m_sMegaElectronBallData.GetSkillSlotID() )
			{
			case 0: InitInputDataExceptMegaBallKey( m_InputData, m_InputData.pureA ); break;
			case 1: InitInputDataExceptMegaBallKey( m_InputData, m_InputData.pureS ); break;
			case 2: InitInputDataExceptMegaBallKey( m_InputData, m_InputData.pureD ); break;
			case 3: InitInputDataExceptMegaBallKey( m_InputData, m_InputData.pureC ); break;
			case 4: InitInputDataExceptMegaBallKey( m_InputData, m_InputData.pureQ ); break;
			case 5: InitInputDataExceptMegaBallKey( m_InputData, m_InputData.pureW ); break;
			case 6: InitInputDataExceptMegaBallKey( m_InputData, m_InputData.pureE ); break;
			case 7: InitInputDataExceptMegaBallKey( m_InputData, m_InputData.pureR ); break;
			default:
				break;
			}
		}
		else
		{
			m_InputData.Init();
		}
	}
}
#endif // FIX_SHOOTING_MEGABALL_AT_JUMP_LINE_MAP

#ifdef ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어

bool CX2GUEve::CanParryingState ()
{
	// Parrying 할 수 있는 상태인가?
	if( m_FrameDataNow.unitCondition.bFootOnLine == false )
		return false;

	switch( GetNowStateID() )
	{
	case CX2GUUser::USI_JUMP_UP:		
	case CX2GUUser::USI_JUMP_DOWN:
	case CX2GUUser::USI_DASH_JUMP:
		return false;
	default:
		break;
	}
	if(	GetNowStateID() >= CX2GUUser::USI_DAMAGE_GROGGY && GetNowStateID() <= CX2GUUser::USI_DAMAGE_GRAPPLED_FRONT )
		return false;

//	switch( GetNowStateID() )
//	{
//	case CX2GURaven::RSI_COMBO_ZZZX:
//	case CX2GURaven::RBM_COMBO_ZZZXZ:
//	case CX2GURaven::RBM_COMBO_ZZZX_EXPLOSION:
// 		return false;
// 	default:
// 		break;
// 	}

	return true;
}
void CX2GUEve::AddManeuverGauge ( float fVal_ )
{
	// 기동 게이지를 추가한다.
	m_fManeuverGauge = m_fManeuverGauge + fVal_;
	if( m_fManeuverGauge > 100.f )
		m_fManeuverGauge = 100.f;
	else if( m_fManeuverGauge < 0.f )
		m_fManeuverGauge = 0.f;

}
void CX2GUEve::DoParrying()
{
	if( m_pManeuverCore == NULL )
		return;
//	PlaySound(L"Raven_NasodCore_Trans_Parry.ogg");

	m_fManeuverGauge -= 30.f;
	if( m_fManeuverGauge < 0.f )
		m_fManeuverGauge = 0.f;		

	--m_iManeuverCoreLv;
	if( m_iManeuverCoreLv < 0 )
		m_iManeuverCoreLv = 0;

	ChangeManeuverCoreState( MCS_PARRYING );
}

void CX2GUEve::ENSI_PARRYING_StartFuture ()
{
	CommonStateStartFuture();
}
void CX2GUEve::ENSI_PARRYING_Start ()
{
	CommonStateStart();

	//	To do...			
	// 	int iRand = GetRandomInt(0) % 2;
	// 	if( iRand == 0 )
	// 	{
	// 		m_pXSkinAnim.get()->ChangeAnim( L"GuardSmallFront", false );		
	// 	}
	m_bCanParrying = true;
	// 패링동작
	DoParrying();
}

void CX2GUEve::ENSI_PARRYING_EventProcess ()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
		{
			StateChange( USI_JUMP_DOWN );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}
		else
		{
			StateChange( USI_WAIT );
		}
	}
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	// 이브 추가 시스템 수정 사항, 패링 점멸 조건 중 Z 키 입력을 제거 
	else if ( true == m_InputData.oneX )	
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	else if ( true == m_InputData.oneZ || true == m_InputData.oneX )
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	{
		StateChange( ENSI_PARRYING_BLINK );
	}
#ifdef SKILL_CANCEL_BY_HYPER_MODE // 김태환
	SKILL_CANCEL_AFTER( 0.3f )
#else // SKILL_CANCEL_BY_HYPER_MODE
	else if( m_pXSkinAnimFuture->GetNowAnimationTime() >= 0.3f ) 
	{
		if( SpecialAttackEventProcess() == true )
		{
		}
	}
#endif //SKILL_CANCEL_BY_HYPER_MODE
	
	CommonEventProcess();
}

void CX2GUEve::ENSI_PARRYING_StateEnd ()
{
	CommonStateEnd();
	m_bCanParrying = false;
	RestoreManeuverCore();
}
void CX2GUEve::ENSI_PARRYING_BLINK_Init ()
{
	

}

void CX2GUEve::ENSI_PARRYING_BLINK_Start ()
{
	CommonStateStart();
	m_fPhotonBlinkBackSpeedX = 0.f;
	m_fPhotonBlinkDummyLifeTime = 0.f;
	const CX2SkillTree::SkillTemplet* pSkillTemplet = GetEquippedActiveSkillTemplet(CX2SkillTree::SI_A_EN_PHOTON_BLINK);

	if( NULL != pSkillTemplet )
	{
		if ( NULL == GetUnit() )
			return;

		const CX2UserSkillTree& userSkillTree = GetUnit()->GetUnitData().m_UserSkillTree;

		// const int iSkillTempletLevel = max( 1, userSkillTree.GetSkillLevel( CX2SkillTree::SI_A_EN_PHOTON_BLINK ) );	/// 스킬 레벨
		const int iSkillTempletLevel = 1;		// 모든 내용을 1 레벨 기준으로만 가져온다.

		m_fPhotonBlinkBackSpeedX	= pSkillTemplet->GetSkillAbilityValue( CX2SkillTree::SA_TELEPORT_RANGE_ABS, iSkillTempletLevel );
	}

	m_fBlinkInvisibilityAlpha	= 1.f;
	m_bBlinkInvisibility		= true;

	SetAlphaObject( true );
	m_RenderParam.bAlphaBlend = true;
}

void CX2GUEve::ENSI_PARRYING_BLINK_StartFuture ()
{
	CommonStateStartFuture();
	m_bDisableGravity = true;
}


void CX2GUEve::ENSI_PARRYING_BLINK_FrameMoveFuture ()
{
	CommonFrameMoveFuture ();
	if( m_pXSkinAnimFuture->EventTimerOneshot( 0.1f ) )
	{
		m_PhysicParam.nowSpeed.x = -m_fPhotonBlinkBackSpeedX;
	}
	if( m_pXSkinAnimFuture->EventTimerOneshot( 0.4f ) )
	{
		m_PhysicParam.nowSpeed.x = -300.f;
	}
}

void CX2GUEve::ENSI_PARRYING_BLINK_FrameMove()
{
	if( m_pXSkinAnim->GetNowAnimationTime() > 0.03f && m_pXSkinAnim->GetNowAnimationTime() < 0.3f)
	{
		m_fBlinkInvisibilityAlpha -= m_fElapsedTime * 10.f;
		if( m_fBlinkInvisibilityAlpha < 0.f )
			m_fBlinkInvisibilityAlpha = 0.f;
	}
	else if( m_pXSkinAnim->GetNowAnimationTime() > 0.3f && m_pXSkinAnim->GetNowAnimationTime() < 0.8f )
	{
		m_fBlinkInvisibilityAlpha += m_fElapsedTime * 5.f;
		if( m_fBlinkInvisibilityAlpha > 1.f )
			m_fBlinkInvisibilityAlpha = 1.f;
	}
	CommonFrameMove();
}



void CX2GUEve::ENSI_PARRYING_BLINK_EventProcess ()
{
	if( m_pXSkinAnimFuture->IsAnimationEnd() == true )
	{
		if( false == IsOnSomethingFuture() )
		{
			StateChange( USI_JUMP_DOWN );
			m_FrameDataFuture.syncData.position.y -= LINE_RADIUS * 1.5f;
		}
		else
		{
			StateChange( USI_WAIT );
		}
	}
	CommonEventProcess();
}

void CX2GUEve::ENSI_PARRYING_BLINK_EndFuture()
{
	CommonStateEndFuture();
	m_bDisableGravity = false;
	m_PhysicParam.nowSpeed		= D3DXVECTOR2( 0, 0 );
	m_PhysicParam.passiveSpeed	= D3DXVECTOR2( -1, -1 );
}

void CX2GUEve::ENSI_PARRYING_BLINK_End()
{
	CommonStateEnd();

	m_bBlinkInvisibility			= false;

	if( m_bInvisibility == false )
	{
		SetAlphaObject( false );
		m_RenderParam.bAlphaBlend = false;
		m_RenderParam.outLineColor.a	= 1.f;
		m_RenderParam.color.a			= 1.f;
	}
}

CX2GUEve::ManeuverCoreData::ManeuverCoreData()
{
	m_vOffsetRotate = D3DXVECTOR3(0, 20.f, 0);
	m_vOffsetPos = D3DXVECTOR3( 0, 0, 0 );
	m_hEffect = INVALID_DAMAGE_EFFECT_HANDLE;
	m_eManeuverCoreState = MCS_NONE;
}

CX2GUEve::ManeuverCoreData::~ManeuverCoreData()
{
	if( NULL != g_pX2Game->GetDamageEffect() && INVALID_DAMAGE_EFFECT_HANDLE != m_hEffect )
		g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_hEffect );
}


void CX2GUEve::ClearManeuverCore ( bool bClearManeuverGauge /* = false */ )
{
	if ( true == bClearManeuverGauge )
	{
		m_fManeuverGauge = 0.f;
		m_iManeuverCoreLv = 0;
	}

	m_bCanParrying  = false;		
	m_fManeuverCoreStateTime = 0.f;
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	if( NULL != g_pX2Game->GetDamageEffect() )
	{ 
		if( NULL != m_pManeuverCoreParryingEffect )
			g_pX2Game->GetDamageEffect()->DestroyInstance( m_pManeuverCoreParryingEffect );
	}	
#else  // FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	if( NULL != g_pX2Game->GetEffectSet() )
	{ 
		if( INVALID_EFFECTSET_HANDLE != m_hManeuverCoreParryingEffect )
			g_pX2Game->GetEffectSet()->DestroyInstanceHandle( m_hManeuverCoreParryingEffect );
	}	
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	// 각성 공격 ( 레이저 ) 같은 경우, Clear 로 초기화 되지 않습니다.
	// 공격 중 각성이 풀렸을 때, 마저 공격하기 위함 입니다.
	// 해당 부분은 코어가 생성될 때, 초기화 됩니다. )

	//if( NULL != g_pX2Game->GetDamageEffect() && NULL != m_pManeuverCoreAttackDamageEffect )
	//	g_pX2Game->GetDamageEffect()->DestroyInstance( m_pManeuverCoreAttackDamageEffect );
	

	m_bManeuverCoreAttackLockOnNpc = false;
	m_iManeuverCoreAttackLockOnUid = 0;
	SAFE_DELETE ( m_pManeuverCore );
}	

void CX2GUEve::RestoreManeuverCore ( )
{
	if( NULL != m_pManeuverCore && NULL != g_pX2Game->GetDamageEffect() )
	{ 
		if( INVALID_DAMAGE_EFFECT_HANDLE != m_pManeuverCore->m_hEffect )
			g_pX2Game->GetDamageEffect()->DestroyInstanceHandle( m_pManeuverCore->m_hEffect );
	}

#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	if( NULL != g_pX2Game->GetDamageEffect() )
	{ 
		if( NULL != m_pManeuverCoreParryingEffect )
			g_pX2Game->GetDamageEffect()->DestroyInstance( m_pManeuverCoreParryingEffect );
	}
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	if( NULL != g_pX2Game->GetEffectSet() )
	{ 
		if( INVALID_EFFECTSET_HANDLE != m_hManeuverCoreParryingEffect )
			g_pX2Game->GetEffectSet()->DestroyInstanceHandle( m_hManeuverCoreParryingEffect );
	}
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	CreateManeuverCore(false);
	m_fManeuverCoreStateTime = 0;
	m_bManeuverCoreAttackLockOnNpc = false;
	m_iManeuverCoreAttackLockOnUid = 0;
}


void CX2GUEve::CreateManeuverCore ( bool bShowCreateEffect /* = true */ )
{
	// 코어 생성은 항상 Wait 상태 일 때만 이루어 져야 합니다.

	// 각성 공격 ( 레이저 ) 같은 경우, Clear 로 초기화 되지 않습니다.
	// 공격 중 각성이 풀렸을 때, 마저 공격하기 위함 입니다.
	// 해당 부분은 코어가 생성될 때, 초기화 됩니다.
	if( NULL != g_pX2Game->GetDamageEffect() && NULL != m_pManeuverCoreAttackDamageEffect )
		g_pX2Game->GetDamageEffect()->DestroyInstance( m_pManeuverCoreAttackDamageEffect );

	// 클로킹 상태에서 같은 팀원이 아니라면 생성을 막는다.
	if ( NULL != g_pX2Game->GetMyUnit() )
	{
		if ( true == m_bInvisibility && g_pX2Game->GetMyUnit()->GetTeam() != GetTeam() )
		{
			ClearManeuverCore();
			return ;
		}
	}
	
	// 코어 레벨이 0 이하라면 생성을 막는다.
	if( m_iManeuverCoreLv <= 0 )
	{
		ClearManeuverCore();
		return;
	}

	SAFE_DELETE ( m_pManeuverCore );
	m_pManeuverCore = new ManeuverCoreData;	
	D3DXVECTOR3 vOffsetPos = D3DXVECTOR3 ( 0.f, 0.f, 0.f );
	vOffsetPos = _CONST_EVE_::MANEUVER_CORE_WAIT_STATE_POSITION_OFFSET;
	
	// 오른쪽을 보고 있을 때는 Offset 값의 X 축을 변경한다.
	if( true == GetIsRight() )
		vOffsetPos.x *= -1;

	// 이펙트가 존재 하지 않을 시 생성하고 Offset 을 캐릭터가 바라보고 있는 방향에서 뒤에 생성하게끔 설정
	CX2DamageEffect::CEffect *pManeuverCore = NULL;
	wstring wstrManeuverCoreDamageEffectName = L"";

	switch ( GetManeuverCoreLevel() )
	{
	case 1 :
		if ( true == IsFullHyperMode () )
			wstrManeuverCoreDamageEffectName = L"DAMAGE_EFFECT_EVE_MANEUVER_CORE_DUMMY_LEVEL_1_HYPER";	
		else
			wstrManeuverCoreDamageEffectName = L"DAMAGE_EFFECT_EVE_MANEUVER_CORE_DUMMY_LEVEL_1";	

		break;
	case 2 :
		if ( true == IsFullHyperMode () )
			wstrManeuverCoreDamageEffectName = L"DAMAGE_EFFECT_EVE_MANEUVER_CORE_DUMMY_LEVEL_2_HYPER";	
		else
			wstrManeuverCoreDamageEffectName = L"DAMAGE_EFFECT_EVE_MANEUVER_CORE_DUMMY_LEVEL_2";	

		break;
	case 3 :
		if ( true == IsFullHyperMode () )
			wstrManeuverCoreDamageEffectName = L"DAMAGE_EFFECT_EVE_MANEUVER_CORE_DUMMY_LEVEL_3_HYPER";	
		else
			wstrManeuverCoreDamageEffectName = L"DAMAGE_EFFECT_EVE_MANEUVER_CORE_DUMMY_LEVEL_3";	
		break;
	}

	pManeuverCore = g_pX2Game->GetDamageEffect()->CreateInstance( static_cast<CX2GameUnit*> (this), wstrManeuverCoreDamageEffectName.c_str(), GetPowerRate(), GetPos() + vOffsetPos, 
		GetRotateDegree(), GetRotateDegree(), m_FrameDataNow.unitCondition.landPosition.y );


	if( pManeuverCore == NULL )
	{
		ClearManeuverCore();
		return;
	}

	m_pManeuverCore->m_hEffect = pManeuverCore->GetHandle();

	if ( true == bShowCreateEffect )
	{
		CKTDGXMeshPlayer::CXMeshInstance*  pManeuverCoreMeshInstance = GetManeuverCoreMeshInstance();
		if( NULL != pManeuverCoreMeshInstance )
		{
			D3DXVECTOR3 vEffectPos = pManeuverCoreMeshInstance->GetPos();

			if ( true == IsFullHyperMode() )			
				g_pX2Game->GetEffectSet()->PlayEffectSetWithCustomPos_LUA( "EffectSet_Eve_ManeuverCore_Beed_Up_Hyper", (CX2GameUnit*)this, vEffectPos, GetRotateDegree() );
			else
				g_pX2Game->GetEffectSet()->PlayEffectSetWithCustomPos_LUA( "EffectSet_Eve_ManeuverCore_Beed_Up", (CX2GameUnit*)this, vEffectPos, GetRotateDegree() );
			PlaySound( L"Eve_Ensi_WaitStart01.ogg" );
		}
	}



	ChangeManeuverCoreState( MCS_WAIT );
}


void CX2GUEve::OnFrameMove_ManeuverCore ()
{
	// 아래 로직은 OnFrameMove 에서 항상 처리 합니다.

	// 기동 게이지가 변조됐다면 해킹 유저로 리포트 한다.
	if ( false == m_fManeuverGauge.Verify() )
	{
		if( g_pData->GetMyUser()->GetUserData().hackingUserType != CX2User::HUT_AGREE_HACK_USER )
			g_pData->GetServerProtocol()->SendID( EGS_REPORT_HACK_USER_NOT );
	}

	// 기동 코어의 이펙트 셋의 포지션을 잡아준다. ( 기동 코어 위치가 아닌 이펙트 셋의 포지션! ) 
	SetManeuverCoreEffectSetPosition();

	// 3각성 시 항상 처리 해야 할 것 
	if( GetHyperModeCount() == 3 )
	{
		// 각성 구슬에 Effect 를 추가한다.
		CKTDGParticleSystem::CParticleEventSequence* pSeq = NULL;

		if( m_hSeqHyperBall == INVALID_PARTICLE_SEQUENCE_HANDLE )
		{
			D3DXVECTOR3 vHyperBallPos = D3DXVECTOR3(72.f * g_pKTDXApp->GetResolutionScaleX(), 80.f *g_pKTDXApp->GetResolutionScaleY(), 0.f);

			m_hSeqHyperBall = g_pX2Game->GetMajorParticle()->CreateSequenceHandle( static_cast<CKTDGObject*> ( this ),  L"Eve_PowerUp_UI_01", vHyperBallPos );
			if( g_pX2Game->GetMajorParticle()->GetInstanceSequence(m_hSeqHyperBall ) != NULL )
			{
				pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence(m_hSeqHyperBall );
				pSeq->SetOverUI( true );
			}					
		}
		else
		{
			pSeq = g_pX2Game->GetMajorParticle()->GetInstanceSequence(m_hSeqHyperBall);
			if( pSeq != NULL )
			{
				D3DXVECTOR3 vHyperBallPos = D3DXVECTOR3(72.f * g_pKTDXApp->GetResolutionScaleX(), 80.f *g_pKTDXApp->GetResolutionScaleY(), 0.f);
				pSeq->SetPosition( vHyperBallPos );
			}				
		}

		if( pSeq != NULL )
		{
			if( g_pKTDXApp->GetDGManager()->GetDialogManager()->GetHideDialog() == true )
				pSeq->SetShowObject(false);
			else
				pSeq->SetShowObject(true);
		}
	}
	// 3 각성이 아니면 3각성 파티클을 제거한다.
	else
	{
		if( m_hSeqHyperBall != INVALID_PARTICLE_SEQUENCE_HANDLE )
		{
			g_pX2Game->GetMajorParticle()->DestroyInstanceHandle(m_hSeqHyperBall);
		}	
	}		



	// 해당 로직부터는 각성 시간이 존재할 때 ( 즉, 각성 했을 때 ) 만 수행 합니다.
	if( GetRemainHyperModeTime() > 0.f )
	{
		// 기동 코어의 레벨이 변경되면 새로 생성한다. ( 신규 생성도 포함 )
		if( false == GetParrying() && false == IsAttackManeuverCore () )
		{		
			int iNowManeuverCoreLv = 0;
			if( IsMyUnit() == true )
				iNowManeuverCoreLv = static_cast<int> (m_fManeuverGauge / 30.f);
			
			else
				iNowManeuverCoreLv = m_FrameDataNow.syncData.m_CannonBallCount;			

			// 나소드볼 유지관리
			// 기동 코어의 레벨이 변경되면 새로 생성한다. ( 신규 생성도 포함 )
			if( m_iManeuverCoreLv != iNowManeuverCoreLv )
			{
				m_iManeuverCoreLv = iNowManeuverCoreLv;
				if( m_iManeuverCoreLv > ::_CONST_EVE_::MANEUVER_CORE_MAX_LEVEL )
					m_iManeuverCoreLv = ::_CONST_EVE_::MANEUVER_CORE_MAX_LEVEL;

				CreateManeuverCore();
			}
			// 위 과정을 거치고도 코어가 없다면 다시 생성한다. Ex. 난입 유저, 사내에서 이펙트셋 다시 로드 등..
			if ( INVALID_DAMAGE_EFFECT_HANDLE == GetManeuverCoreEffectHandle() && iNowManeuverCoreLv > 0 )
			{
				CreateManeuverCore ();
			}
		}		


		if ( NULL != m_pManeuverCore && INVALID_DAMAGE_EFFECT_HANDLE != m_pManeuverCore->m_hEffect )
		{
			// 코어가 존재할 때 해야 할 처리, 각 State 에 맞게 처리를 해준다.
			CX2DamageEffect::CEffectHandle hManeuverCoreEffect = GetManeuverCoreEffectHandle();
			if ( INVALID_DAMAGE_EFFECT_HANDLE != hManeuverCoreEffect )
			{
				// 기동 코어 이동
				MoveManeuverCoreByState( m_pManeuverCore->m_eManeuverCoreState );
				RotateManeuverCoreByState ( m_pManeuverCore->m_eManeuverCoreState );
				switch ( m_pManeuverCore->m_eManeuverCoreState )
				{

					// 대기 중
				case MCS_WAIT :
					break;

					// 공격 준비 중
				case MCS_BEFORE_ATTACK :
					m_fManeuverCoreStateTime += m_fElapsedTime;

					if( m_fManeuverCoreStateTime <= _CONST_EVE_::MANEUVER_CORE_BEFORE_ATTACK_TIME )
					{	// MANEUVER_CORE_BEFORE_ATTACK_TIME 시간 동안 서서히 나타나도록 한다.
						CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = GetManeuverCoreMeshInstance();
						if ( NULL != pMeshInst ) 
						{
							float fAlphaValue = m_fManeuverCoreStateTime / _CONST_EVE_::MANEUVER_CORE_BEFORE_ATTACK_TIME;
							if ( m_fManeuverCoreStateTime <= _CONST_EVE_::MANEUVER_CORE_BEFORE_ATTACK_TIME )
							{
								pMeshInst->SetMeshAlphaColor(fAlphaValue);
							}							
						}
					}
					else 
					{	// MCS_BEFORE_ATTACK 상태의 시간이 모두 끝났다.
						// 공격 상태로 전환한다.
						ChangeManeuverCoreState( MCS_ATTACK );							
					}
					break;

					// 공격 중
				case MCS_ATTACK :
					m_fManeuverCoreStateTime += m_fElapsedTime;				
					if( m_fManeuverCoreStateTime >= _CONST_EVE_::MANEUVER_CORE_ATTACK_TIME )
					{
						ChangeManeuverCoreState( MCS_AFTER_ATTACK );
					}

					break;

					// 공격 완료
				case MCS_AFTER_ATTACK :
					m_fManeuverCoreStateTime += m_fElapsedTime;					

					if( m_fManeuverCoreStateTime <= _CONST_EVE_::MANEUVER_CORE_AFTER_ATTACK_TIME )
					{
						// MANEUVER_CORE_AFTER_ATTACK_TIME 만큼의 시간이 안되면 다음 상태로 넘어가지 않습니다.
						if ( NULL != GetManeuverCoreMeshInstance() )
						{
							float fAlphaValue = m_fManeuverCoreStateTime / _CONST_EVE_::MANEUVER_CORE_AFTER_ATTACK_TIME;

							// Fade-Out
							if ( m_fManeuverCoreStateTime <= _CONST_EVE_::MANEUVER_CORE_AFTER_ATTACK_TIME )
							{
								GetManeuverCoreMeshInstance()->SetMeshAlphaColor(1-fAlphaValue);
							}							
						}
					}
					else 
					{
						// 연출이 끝났으면 삭제
						if( IsMyUnit() == true )
						{
							m_fManeuverGauge = m_fManeuverGauge - (GetManeuverCoreLevelByGauge() * 30.f);
						}
						RestoreManeuverCore ();
						ChangeManeuverCoreState( MCS_WAIT );
						
					}
					break;		

					// Parrying 상태 일 때
				case MCS_PARRYING :
					{	

						m_fManeuverCoreStateTime += m_fElapsedTime;
						
						// Parrying 시의 Effect 는 캐릭터 크기와 비례한다.
						const PROTECT_VECTOR3 &vScale = GetScaleByUnit();
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
						if ( NULL != m_pManeuverCoreParryingEffect )
						{
							m_pManeuverCoreParryingEffect->SetScale ( vScale.GetVector3() );
						}
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
						CX2EffectSet::EffectSetInstance* pEffectInstance = g_pX2Game->GetEffectSet()->GetEffectSetInstance ( m_hManeuverCoreParryingEffect );
						if ( NULL != pEffectInstance )
						{
							pEffectInstance->SetEffectScale( vScale.GetVector3() );
						}
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
						
						// 위치는 현재 유저의 위치 + y축 150
						CKTDGXMeshPlayer::CXMeshInstance* pManeuverEffectMeshInstance = GetManeuverCoreMeshInstance();
						if ( NULL != pManeuverEffectMeshInstance )
						{
							float fOffsetY = vScale.y * 150.f;
							pManeuverEffectMeshInstance->SetPos( GetPos() + D3DXVECTOR3( 0.f, fOffsetY, 0.f ) );		
						}

						// Parrying 시간이 끝났다면 Parrying 상태 해제 
						if( m_fManeuverCoreStateTime >= _CONST_EVE_::MANEUVER_CORE_PARRYING_TIME )
						{
							m_bCanParrying = false;
							ChangeManeuverCoreState ( MCS_WAIT );
						}
					}
					break;

				case MCS_NONE :
				default :
					ASSERT ( !L"Wrong State Maneuver Core ! ");
					break;
				}
			}
		}
	}
	else
	{
		if ( NULL != m_pManeuverCore )
		{
			ClearManeuverCore();
		}
	}
}

void CX2GUEve::AttackManeuverCore ()
{
	// 기동 코어의 공격을 활성화 한다.
	if ( m_pManeuverCore == NULL )
		return;

	CX2DamageEffect::CEffectHandle hManeuverCore = GetManeuverCoreEffectHandle();
	CX2GameUnitoPtr pTargetUnit = GetManeuverCoreTargetGameUnit();
	
	if ( INVALID_DAMAGE_EFFECT_HANDLE != hManeuverCore && null != pTargetUnit && pTargetUnit->GetNowHp() > 0.f )
	{
		if ( NULL != g_pX2Game->GetEffectSet() && NULL != g_pX2Game->GetDamageEffect() )
		{	
			CX2DamageEffect::CEffect* pEffect = NULL;
			CKTDGXMeshPlayer::CXMeshInstance* pManeuverCoreEffectMeshInstance = GetManeuverCoreMeshInstance();

			// 데미지 이펙트를 발사한다.
			if ( NULL != pManeuverCoreEffectMeshInstance )
			{
				if ( true == IsFullHyperMode() )
				{
					// 연출용 이펙트
					g_pX2Game->GetEffectSet()->PlayEffectSetWithCustomPos_LUA( "EffectSet_Eve_QueenCore_Before_Attack_Hyper", static_cast<CX2GameUnit*> ( this ), 
						pManeuverCoreEffectMeshInstance->GetPos(), pManeuverCoreEffectMeshInstance->GetRotateDegree()  );

					// 공격 레이저
					CX2DamageEffect::CEffect * pManeuverCoreInstance = GetManeuverCoreEffect();
					pEffect = m_pManeuverCoreAttackDamageEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DAMAGE_EFFECT_EVE_MANEUVER_CORE_ATTACK_HYPER", pManeuverCoreInstance->GetPowerRate(),
						pManeuverCoreEffectMeshInstance->GetPos(), m_pManeuverCore->GetManeuverCoreRotateExceptOffset(), m_pManeuverCore->GetManeuverCoreRotateExceptOffset() );							

					// Index 를 1 로 설정하면 Hyper 데미지 이펙트
					m_pManeuverCoreAttackDamageEffect->SetIndex( UMGAT_HYPER );

					PlaySound( L"Eve_Ensi_Attack01.ogg" );
				}
				else
				{
					// 연출용 이펙트
					g_pX2Game->GetEffectSet()->PlayEffectSetWithCustomPos_LUA( "EffectSet_Eve_QueenCore_Before_Attack", static_cast<CX2GameUnit*> ( this ), 
						pManeuverCoreEffectMeshInstance->GetPos(), pManeuverCoreEffectMeshInstance->GetRotateDegree() );
						
					// 공격 레이저
					CX2DamageEffect::CEffect * pManeuverCoreInstance = GetManeuverCoreEffect();
					pEffect = m_pManeuverCoreAttackDamageEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DAMAGE_EFFECT_EVE_MANEUVER_CORE_ATTACK", pManeuverCoreInstance->GetPowerRate(),
						pManeuverCoreEffectMeshInstance->GetPos(), m_pManeuverCore->GetManeuverCoreRotateExceptOffset(), m_pManeuverCore->GetManeuverCoreRotateExceptOffset() );

					// Index 를 1 로 설정하면 그냥 데미지 이펙트
					m_pManeuverCoreAttackDamageEffect->SetIndex( UMGAT_NORMAL );

					PlaySound( L"Eve_Ensi_Attack02.ogg" );
				}
			}
					
			// 데미지 이펙트의 크기를 조절한다.
			if ( NULL != pEffect && NULL != pEffect->GetMainEffect() )
			{
				ChangePowerRateManeuverCore( pEffect );

				switch ( GetManeuverCoreLevel() )
				{
				case 1 :
					pEffect->GetMainEffect()->SetScale( D3DXVECTOR3 ( 1.f, 1.f, 1.f ) );
					break;
				case 2 :
					pEffect->GetMainEffect()->SetScale( D3DXVECTOR3 ( 1.f, 1.25f, 1.25f ) );
					break;
				case 3 :
					pEffect->GetMainEffect()->SetScale( D3DXVECTOR3 ( 1.f, 1.5f, 1.5f ) );
					break;
				}
			}
		}				
	}
	// 정상적으로 타켓팅 할 수 없는 상태 일 때
	else
	{
		RestoreManeuverCore();
		ChangeManeuverCoreState( MCS_WAIT );
	}		
}


void CX2GUEve::ChangePowerRateManeuverCore(CX2DamageEffect::CEffect* pEffect)
{
	// 기동 공격의 데미지 수치 변경
	float fPhysic = 1.f;
	float fMagic = 1.f;
	float fManeuverCorePowerRate = 1.f;
	switch( m_iManeuverCoreLv )
	{
	case 1:
		fManeuverCorePowerRate = 3.3f;
		break;
	case 2:
		fManeuverCorePowerRate = 6.6f;
		break;
	case 3:
		fManeuverCorePowerRate = 9.9f;
		break;
	default:
		RestoreManeuverCore();
		if ( NULL != m_pManeuverCore )
		{
			ChangeManeuverCoreState( MCS_NONE );
		}

		return;
	}	

	if ( m_pManeuverCore == NULL )
		return;

	pEffect->GetDamageData().damage.fPhysic = fPhysic * fManeuverCorePowerRate / _CONST_EVE_::MANEUVER_CORE_LASER_ATTACK_HIT_VALUE;
	pEffect->GetDamageData().damage.fMagic = fMagic * fManeuverCorePowerRate / _CONST_EVE_::MANEUVER_CORE_LASER_ATTACK_HIT_VALUE;
}

void CX2GUEve::SetManeuverCoreTargetUnit ( CX2GameUnit::GAME_UNIT_TYPE eGameUnitType_, UidType uidType_, MANEUVER_CORE_ATTACK_TYPE eManeuverCoreAttackType_ )
{
	// 기동 코어의 공격 타켓을 설정한다.
	// 기동 코어의 경우 공격 타입이 2가지 로 
	// 각각 타입을 잡아준다.
	// AT_SPECIAL 일 경우 USE_MANEUVER_GAGE 공격 타켓
	// 그 외의 공격이면서 3각성일 경우 FULL_HYPER_MODE 공격 타켓
	switch ( eManeuverCoreAttackType_ )
	{
	case MCAT_USE_MANEUVER_GAGE :
	{
		if( CX2GameUnit::GUT_USER == eGameUnitType_ )
		{
			m_bManeuverCoreAttackLockOnNpc = false;
		}
		else if( CX2GameUnit::GUT_NPC == eGameUnitType_ )
		{
			m_bManeuverCoreAttackLockOnNpc = true;
		}
		m_iManeuverCoreAttackLockOnUid = uidType_;
	}
	break;

	default :
		ASSERT ( !L"Can Not FInd Maneuver Core Attack Type !" );
	}
}
void CX2GUEve::ClearManeuverCoreEffect ()
{
	// 기동 코어의 이펙트들을 제거한다.
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	if ( NULL != g_pX2Game->GetDamageEffect() && NULL != m_pManeuverCoreParryingEffect )
	{
		g_pX2Game->GetDamageEffect()->DestroyInstance( m_pManeuverCoreParryingEffect );
	}
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	if ( m_hManeuverCoreParryingEffect != INVALID_EFFECTSET_HANDLE )
	{
		g_pX2Game->GetEffectSet()->DestroyInstanceHandle( m_hManeuverCoreParryingEffect );
	}
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
}
void CX2GUEve::ChangeManeuverCoreState ( MANEUVER_CORE_STATE eState_ )
{
	// 기동 코어의 상태를 변경시키고 변경 할 때 처리해야 할 것을 여기서 해준다.
	// 각 코어의 상태가 변경할 떄 나타나는 이펙트도 여기서 할당한다.

	if ( NULL != m_pManeuverCore )
	{
		m_pManeuverCore->m_eManeuverCoreState = eState_;
		ClearManeuverCoreEffect ();

		switch ( eState_ )
		{	
		case MCS_NONE :
			break;

		case MCS_WAIT :
			if ( NULL != GetManeuverCoreMeshInstance() )
			{
				GetManeuverCoreMeshInstance()->ChangeAnim(L"Wait", CKTDGXSkinAnim::XAP_LOOP, 1.f);
			}
			break;

		case MCS_BEFORE_ATTACK :
			if ( NULL != GetManeuverCoreMeshInstance() )
			{
				if( m_iManeuverCoreAttackLockOnUid > 0 )
				{
					// 타켓이 있는 경우, 해당 타켓으로 이동하고 없는 경우 이동하지 않는다.
					CX2GameUnitoPtr pGameUnit = GetManeuverCoreTargetGameUnit();

					if ( null != pGameUnit )
					{	
						// 메시의 애니메이션을 공격으로 변경해준다.
						if ( NULL != GetManeuverCoreMeshInstance() )
							GetManeuverCoreMeshInstance()->ChangeAnim(L"Attack02", CKTDGXSkinAnim::XAP_ONE_WAIT, 1.f);	
					}
					else
					{
						// 타켓이 없을 때는 초기화
						m_bManeuverCoreAttackLockOnNpc = false;
						m_iManeuverCoreAttackLockOnUid = 0;		
					}
				}
			}
			break;

		case MCS_ATTACK :
			{
				if ( NULL != m_pManeuverCoreAttackDamageEffect && NULL != g_pX2Game->GetDamageEffect() )
				{
					g_pX2Game->GetDamageEffect()->DestroyInstance( m_pManeuverCoreAttackDamageEffect );
				}
				AttackManeuverCore();
				m_fManeuverCoreAttackParticleCreateCoolTime = 0.f;
			}
			break;

		case MCS_AFTER_ATTACK :
			{
				if ( NULL != m_pManeuverCoreAttackDamageEffect && NULL != g_pX2Game->GetDamageEffect() )
				{
					g_pX2Game->GetDamageEffect()->DestroyInstance( m_pManeuverCoreAttackDamageEffect );
				}
				m_fManeuverCoreAttackParticleCreateCoolTime = 0.f;
			}
			break;
	
		case MCS_PARRYING :
			{
				if ( NULL != GetManeuverCoreMeshInstance() )
					GetManeuverCoreMeshInstance()->SetMeshAlphaColor(0.f);


				if ( NULL != g_pX2Game->GetEffectSet() )
				{
					const PROTECT_VECTOR3 &vScale = GetScaleByUnit();
					float fOffsetY = vScale.y * 150.f;
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
					if( true == IsFullHyperMode() )
						m_pManeuverCoreParryingEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DAMAGE_EFFECT_Eve_QueenCore_Defence_Hyper", GetPowerRate(), GetPos(), GetRotateDegree(), GetRotateDegree() );
					else
						m_pManeuverCoreParryingEffect = g_pX2Game->GetDamageEffect()->CreateInstance( this, L"DAMAGE_EFFECT_Eve_QueenCore_Defence", GetPowerRate(), GetPos(), GetRotateDegree(), GetRotateDegree() );
#else // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항

					if( true == IsFullHyperMode() )
						m_hManeuverCoreParryingEffect = g_pX2Game->GetEffectSet()->PlayEffectSetWithCustomPos_LUA( "EffectSet_Eve_QueenCore_Defence_Hyper", static_cast<CX2GameUnit*> ( this ), GetPos() + D3DXVECTOR3 ( 0, fOffsetY, 0 ), GetRotateDegree() );
					else
						m_hManeuverCoreParryingEffect = g_pX2Game->GetEffectSet()->PlayEffectSetWithCustomPos_LUA( "EffectSet_Eve_QueenCore_Defence", static_cast<CX2GameUnit*> ( this ), GetPos() + D3DXVECTOR3 ( 0, fOffsetY, 0 ), GetRotateDegree() );


#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
	}
			}
			break;

		default :
			break;
		}
		m_fManeuverCoreStateTime = 0.f;
	}
	else
	{
		ASSERT ( !L"Can Find Maneuver Core Pointer !"  );
	}
}


/* virtual */ void CX2GUEve::SetAttackManeuverCore ( CX2DamageManager::DamageData & pDamageData )
{
	if ( NULL != m_pManeuverCore )
	{
		// 기동 코어가 공격 가능 상태인지 확인한다.
		// 타켓의 HP 가 0 보다 크며 기동 게이지가 1 이상이며
		// 코어 상태가 Wait 일 때 		
		if ( GetCanAttackManeuverCore ( pDamageData.optrDefenderGameUnit.GetObservable() ) )
		{
			// 기동 코어를 공격 상태로 변환한다.
			if( CX2DamageManager::AT_UNIT == pDamageData.defenderType )
			{
				if( null != pDamageData.optrDefenderGameUnit )
				{				
					// MCAT_USE_MANEUVER_GAGE 와 MCAT_USE_MANEUVER_GAGE_HYPER 는 동일한 타켓 행동을 합니다.
					SetManeuverCoreTargetUnit ( pDamageData.optrDefenderGameUnit->GetGameUnitType(), pDamageData.optrDefenderGameUnit->GetUnitUID(), MCAT_USE_MANEUVER_GAGE );
				}
			}		
			ChangeManeuverCoreState ( MCS_BEFORE_ATTACK );
		}
	}
}
void CX2GUEve::SetManeuverCoreEffectSetPosition ()
{	
	// 기동 코어의 이펙트 좌표들을 설정한다.
	
	if ( NULL != g_pX2Game->GetDamageEffect() && NULL != g_pX2Game->GetEffectSet() )
	{
		// Parrying 상태의 Effect 처리
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
		if ( NULL != m_pManeuverCoreParryingEffect )
		{			
			// 변경된 위치에 EffectSet 을 붙여준다.
			m_pManeuverCoreParryingEffect->SetPos ( GetPos() + D3DXVECTOR3 ( 0, 100.f, 0 )  );
		}
#else  // FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
		if ( INVALID_EFFECTSET_HANDLE != m_hManeuverCoreParryingEffect )
		{			
			// 변경된 위치에 EffectSet 을 붙여준다.
			CX2EffectSet::EffectSetInstance* pEffectInstance = g_pX2Game->GetEffectSet()->GetEffectSetInstance ( m_hManeuverCoreParryingEffect );
			if ( NULL != pEffectInstance )
			{
				pEffectInstance->SetPos ( GetPos() + D3DXVECTOR3 ( 0, 100.f, 0 ) );
			}
		}
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항

		// 기동 게이지 소모하는 공격의 데미지 이펙트 인스턴스 핸들 처리
		if ( NULL != m_pManeuverCoreAttackDamageEffect )
		{
			m_fManeuverCoreAttackParticleCreateCoolTime += GetElapsedTime();		// 이펙트 출력을 위해 시간 증감

			// 유지되는 동안 타켓을 향한다. 레이저 형태의 공격이라 이 방법이 최선인 것으로 판단됩니다. - kimjh
			CKTDGXMeshPlayer::CXMeshInstance* pManeuverCoreAttackMesh = m_pManeuverCoreAttackDamageEffect->GetMainEffect();
			if ( NULL != pManeuverCoreAttackMesh )
			{
				CX2GameUnitoPtr pTargetUnit = GetManeuverCoreTargetGameUnit();

				if ( null != pTargetUnit && pTargetUnit->GetNowHp() > 0.f )
				{
					// 타켓의 중점과의 거리를 계산하여 방향 벡터를 얻어온다.
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
					D3DXVECTOR3 vTargetPos_ = GetManeuverCoreTargetPosUsingCollisionData();
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
					D3DXVECTOR3 vTargetPos_ = pTargetUnit->GetPos();
					vTargetPos_.y += _CONST_EVE_::MANEUVER_CORE_ATTACK_STATE_POSITION_OFFSET.y;
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
					D3DXVECTOR3 vMeshPos = pManeuverCoreAttackMesh->GetPos ();
					D3DXVECTOR3 vOriginPos = vTargetPos_ - vMeshPos;
					D3DXVECTOR3 vResultPos = GetDirVecToDegree ( vOriginPos );

					pManeuverCoreAttackMesh->SetRotateDegree( vResultPos );
					pManeuverCoreAttackMesh->SetMoveAxisAngleDegree( vResultPos );
				}
			}
/*			
			// 매 MANEUVER_CORE_3RD_WAKE_UP_DAMAGE_EFFECT_MAKE_COOL_TIME 시간마다 아래 루프에 진입합니다.
			// 연출용 파티을 레이저 앞 머리에 뿌려주는 구문
			if ( _CONST_EVE_::MANEUVER_CORE_3RD_WAKE_UP_DAMAGE_EFFECT_MAKE_COOL_TIME <= m_fManeuverCoreAttackParticleCreateCoolTime )
			{	
				m_fManeuverCoreAttackParticleCreateCoolTime = 0.f;
				// 아래 구문은 하이퍼 이펙트 일 때만 진입합니다.
				if ( UMGAT_HYPER == m_pManeuverCoreAttackDamageEffect->GetIndex () )
				{
					if ( NULL != m_pManeuverCoreAttackDamageEffect->GetMainEffect() )
					{
						D3DXVECTOR3 vLaserHeadPos = m_pManeuverCoreAttackDamageEffect->GetMainEffect()->GetBonePos( L"Dummy02");

						g_pX2Game->GetMajorParticle()->CreateSequenceHandle( static_cast<CKTDGObject*> ( this ),  L"EVE_Attack_Hyper01", vLaserHeadPos, -1.f, -1.f, -1, 5 ); 
					}
				}
			}
*/
		}
	}
}

CKTDGXMeshPlayer::CXMeshInstance* CX2GUEve::GetManeuverCoreMeshInstance ()
{
	// 기동 코어의 데미지 이펙트 인스턴스의 메인 메쉬를 얻어온다.
	// ( 좌표를 받아오는 용도 )
	if ( INVALID_DAMAGE_EFFECT_HANDLE != GetManeuverCoreEffectHandle () )
	{
		CX2DamageEffect::CEffectHandle hManeuverEffect = GetManeuverCoreEffectHandle();
		if ( hManeuverEffect != INVALID_DAMAGE_EFFECT_HANDLE )
		{
			if ( NULL != g_pX2Game->GetDamageEffect() )
			{
				CX2DamageEffect::CEffect * pManeuverInstance = g_pX2Game->GetDamageEffect()->GetInstance ( hManeuverEffect );
				if ( NULL != pManeuverInstance )
				{
					return pManeuverInstance->GetMainEffect();
				}
			}
		}
	}
	return NULL;
}

CX2DamageEffect::CEffect * CX2GUEve::GetManeuverCoreEffect()
{
	if ( NULL != m_pManeuverCore && INVALID_DAMAGE_EFFECT_HANDLE != m_pManeuverCore->m_hEffect )
	{
		if ( NULL != g_pX2Game->GetDamageEffect() )
		{
			CX2DamageEffect::CEffect * pManeuverCoreInstance = g_pX2Game->GetDamageEffect()->GetInstance ( m_pManeuverCore->m_hEffect );
			return pManeuverCoreInstance;			
		}
	}	
	return NULL;
}

CX2DamageEffect::CEffectHandle CX2GUEve::GetManeuverCoreEffectHandle()
{
	// 기동 코어의 데미지 이펙트 인스턴스를 얻어온다.
	if ( NULL != m_pManeuverCore && INVALID_DAMAGE_EFFECT_HANDLE != m_pManeuverCore->m_hEffect )
	{
		return m_pManeuverCore->m_hEffect;
	}	
	return INVALID_DAMAGE_EFFECT_HANDLE;
}

void CX2GUEve::MoveManeuverCoreByState ( MANEUVER_CORE_STATE eState )
{
	// 기동 코어의 이동을 상태에 따라 설정한다.
	CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = GetManeuverCoreMeshInstance();
	if( NULL != pMeshInst )
	{
		D3DXVECTOR3 vDirVec = GetDirVector();
		D3DXVECTOR3 vZVec = GetZVector();
		D3DXVec3Normalize( &vDirVec, &vDirVec );										

		// 아래 3가지 요소는 꼭 추가 해주시기 바랍니다.
		D3DXVECTOR3	vTargetPos			= D3DXVECTOR3 ( 0.f, 0.f, 0.f );	// 가야 할 타켓 위치
		D3DXVECTOR3	vOffsetPos			= D3DXVECTOR3 ( 0.f, 0.f, 0.f );	// 가야 할 타켓 위치의 Offset
		float		fCoeff				= 0.f;								// 보간 수치 ( 0 ~ 1 )

		switch ( eState )
		{
		case MCS_WAIT :
			// 기동 코어의 평소 위치를 잡아준다.
			vTargetPos = GetPos ();
			fCoeff = 0.05f;

			vOffsetPos = _CONST_EVE_::MANEUVER_CORE_WAIT_STATE_POSITION_OFFSET;

			// 오른쪽을 보고 있을 때는 Offset 값의 X 축을 변경한다.
			if( true == GetIsRight() )
				vOffsetPos.x *= -1;

			// 해당 Offset 값은 캐릭터의 Scale 에 따라 증감합니다.

			vOffsetPos.x *= GetScaleByUnit().x;
			vOffsetPos.y *= GetScaleByUnit().x;
			vOffsetPos.z *= GetScaleByUnit().x;
			break;
		
		case MCS_BEFORE_ATTACK :			
			{
				// 기동 코어의 공격 위치를 잡아준다.
				vTargetPos = GetPos ();
				fCoeff = 1.f;

				vOffsetPos = _CONST_EVE_::MANEUVER_CORE_ATTACK_STATE_POSITION_OFFSET;
	
				// 오른쪽을 보고 있을 때는 Offset 값의 X 축을 변경한다.
				if( true == GetIsRight() )
					vOffsetPos.x *= -1;

				vOffsetPos.x *= GetScaleByUnit().x;
				vOffsetPos.y *= GetScaleByUnit().x;
				vOffsetPos.z *= GetScaleByUnit().x;

	#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
				// 이브의 코어 타켓 위치가 이브의 위치 보다 크고 이브의 높이 보다 작을 때 ( 즉 발사각이 얼마 차이 나지 않을 때 )
				// 이브의 코어 y 축을 Target 위치로 변경하여 일직선으로 발사가 유지되도록 한다.
				D3DXVECTOR3 vTargetBonePos = GetManeuverCoreTargetPosUsingCollisionData ();
				if ( vTargetPos.y <= vTargetBonePos.y && vTargetBonePos.y <= GetPos().y + ( GetUnitHeight(false) * GetScaleByUnit().y ) )
				{
					vOffsetPos.y = vTargetBonePos.y - vTargetPos.y;
				}
	#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항
			}

			break;

		default :
			return ;
		}

		// 타켓 위치에서 Offset 값을 더함
		vTargetPos		+= vOffsetPos.x * vDirVec;
		vTargetPos.y	+= vOffsetPos.y;
		vTargetPos		+= vOffsetPos.z * vZVec;

		vTargetPos = vTargetPos * fCoeff + pMeshInst->GetPos() * ( 1.f-fCoeff );
		pMeshInst->SetPos( vTargetPos );
	}
}

void CX2GUEve::RotateManeuverCoreByState ( MANEUVER_CORE_STATE eState )
{
	// 기동 코어의 회전 값을 상태에 따라 설정한다.
	CKTDGXMeshPlayer::CXMeshInstance* pMeshInst = GetManeuverCoreMeshInstance();

	// 아래 1가지 요소는 필요 시 추가해주시기 바랍니다.
	D3DXVECTOR3 vOffsetRot = D3DXVECTOR3 ( 0.f, 0.f, 0.f );	// 회전 값 Offset

	if( NULL != pMeshInst )
	{
		switch ( eState )
		{
			case MCS_WAIT :
			case MCS_PARRYING :	
				// 대기 및 패링 일 때는 이브의 Bip01_Spine1 본 위치를 바라본다.
				// 좌우에 따라 20, -20 씩 Offset 값을 더한다.
				// ( 코어가 잘 보이게 하기 위해 )
				if ( true == GetIsRight() )
					vOffsetRot = D3DXVECTOR3 ( 0.f, 20.f, 0.f );
				else
					vOffsetRot = D3DXVECTOR3 ( 0.f, -20.f, 0.f );
				
				SetManeuverCoreRotateToTargetPos ( GetBonePos ( L"Bip01_Spine1"), vOffsetRot );
				break;

			case MCS_BEFORE_ATTACK :	
			case MCS_ATTACK :	
			case MCS_AFTER_ATTACK :	
			{
				// 공격 상태 일 때는 타켓의 위치를 받아온다.
				if ( NULL != GetManeuverCoreMeshInstance() )
				{
					CX2GameUnitoPtr pTargetUnit = GetManeuverCoreTargetGameUnit();

					if ( null != pTargetUnit && pTargetUnit->GetNowHp() > 0.f )
					{
#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
						D3DXVECTOR3 vTargetPos = GetManeuverCoreTargetPosUsingCollisionData ();
#else  // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항							
 						D3DXVECTOR3 vTargetPos = pTargetUnit->GetPos ();
 						vTargetPos.y += _CONST_EVE_::MANEUVER_CORE_ATTACK_STATE_POSITION_OFFSET.y;
#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항							
						SetManeuverCoreRotateToTargetPos ( vTargetPos, vOffsetRot );
					}
				}
			}
			break;

			default :
				return ;
		}	
	}
}

void CX2GUEve::FindAndSetManeuverCoreTargetGameUnit ( UidType iGameUnitUID_, bool bIsNPC_ )
{
	// 기동 코어의 타켓을 찾는다.
	if( true == bIsNPC_ )
		SetManeuverCoreTargetGameUnit( CX2GameUnitoPtr ( g_pX2Game->GetNPCUnitByUID( static_cast<int> ( iGameUnitUID_ ) ) ) );
	else
		SetManeuverCoreTargetGameUnit( CX2GameUnitoPtr ( g_pX2Game->GetUserUnitByUID( iGameUnitUID_ ) ) );	
}

CX2GameUnitoPtr CX2GUEve::GetManeuverCoreTargetGameUnit ()
{
	// 기동 코어의 타켓을 얻어온다.
	FindAndSetManeuverCoreTargetGameUnit( m_iManeuverCoreAttackLockOnUid, m_bManeuverCoreAttackLockOnNpc );
	return m_pManeuverCoreTargetGameUnit;
}

void CX2GUEve::SetManeuverCoreTargetGameUnit ( CX2GameUnitoPtr pTargetUnit_ )
{
	// 기동 코어의 타켓을 설정한다.
	m_pManeuverCoreTargetGameUnit = CX2GameUnitoPtr(pTargetUnit_);
}

void CX2GUEve::SetManeuverCoreRotateToTargetPos ( D3DXVECTOR3 vTargetPos_, D3DXVECTOR3 vOffsetRot_ )
{
	// 기동 코어가 타켓을 바라보도록 한다.	
	D3DXVECTOR3 vManeuverCorePos = m_pManeuverCore->GetManeuverCorePosition( );
	D3DXVECTOR3 vOriginPos = vTargetPos_ - vManeuverCorePos;
	D3DXVECTOR3 vResultPos = GetDirVecToDegree ( vOriginPos ) + vOffsetRot_;
 
	if ( NULL != GetManeuverCoreMeshInstance() )
	{
		GetManeuverCoreMeshInstance()->SetRotateDegree( vResultPos );
		GetManeuverCoreMeshInstance()->SetMoveAxisAngleDegree( vResultPos );
	}
}

D3DXVECTOR3 CX2GUEve::ManeuverCoreData::GetManeuverCorePosition ()
{
	if ( NULL != g_pX2Game->GetDamageEffect() )
	{
		CX2DamageEffect::CEffect* pManeuverCoreEffect = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffect );
		CKTDGXMeshPlayer::CXMeshInstance*  pManeuverCoreMeshInstance = ( pManeuverCoreEffect != NULL ) ? pManeuverCoreEffect->GetMainEffect() : NULL;
		if ( NULL != pManeuverCoreMeshInstance )	
		{
			return pManeuverCoreMeshInstance->GetPos();					 
		}
	}
	return D3DXVECTOR3 ( 0.f, 0.f, 0.f );
}
D3DXVECTOR3 CX2GUEve::ManeuverCoreData::GetManeuverCoreRotateExceptOffset ()
{
	if ( NULL != g_pX2Game->GetDamageEffect() )
	{
		CX2DamageEffect::CEffect* pManeuverCoreEffect = g_pX2Game->GetDamageEffect()->GetInstance( m_hEffect );
		CKTDGXMeshPlayer::CXMeshInstance*  pManeuverCoreMeshInstance = ( pManeuverCoreEffect != NULL ) ? pManeuverCoreEffect->GetMainEffect() : NULL;
		if ( NULL != pManeuverCoreMeshInstance )	
		{
			return pManeuverCoreMeshInstance->GetRotateDegree() - m_vOffsetRotate;
		}
	}
	return D3DXVECTOR3(0,0,0);
}

#ifdef FIX_ADD_EVE_SYSTEM_2014		// 김종훈, 2014 - 이브 추가 시스템 수정 사항
wstring CX2GUEve::GetBoneNameNearestImpactPoint ( const D3DXVECTOR3 & vImpactPoint ) 
{
	// 이브의 코어가 타켓으로 잡은 유닛의 타격이 일어난 좌표에서 가장 가까운 본 이름을 반환, 
	wstring wstrTargetUnitBoneName = L"";
	if ( null != GetManeuverCoreTargetGameUnit() )
	{
		CX2GameUnitoPtr pTargetUnit = GetManeuverCoreTargetGameUnit();
		const CKTDXCollision::CollisionDataListSet& AttackListSet = GetManeuverCoreTargetGameUnit()->GetCollisionListSet();
		if ( false == AttackListSet.empty () )
		{
			bool    bInit = false;
			const CKTDXCollision::CollisionDataList* collisionDataList = *AttackListSet.begin();	
			if ( NULL != collisionDataList && false == collisionDataList->empty() )
			{
				CKTDXCollision::CollisionData* collisionData = *collisionDataList->begin();
				if ( NULL != collisionData )
				{
					D3DXVECTOR3 vTargetPos = collisionData->GetPointStart();
					BOOST_FOREACH( const CKTDXCollision::CollisionDataList* collisionDataList, AttackListSet )
					{
						BOOST_FOREACH( CKTDXCollision::CollisionData* collisionData, *collisionDataList )
						{
							D3DXVECTOR3 vCollPos = collisionData->GetPointStart();
							if ( bInit == false )
							{
								bInit = true;
								wstrTargetUnitBoneName = collisionData->m_Name;
								vTargetPos = vCollPos;
								continue;
							}

							float fDist = GetDistance( vImpactPoint, vCollPos );
							float fOldDist = GetDistance( vImpactPoint, vTargetPos );

							if ( fDist <= fOldDist )
							{
								wstrTargetUnitBoneName = collisionData->m_Name;
								vTargetPos = vCollPos;
							}
						}
					}

					if ( bInit == false )
					{
						wstrTargetUnitBoneName = L"";
					}
				}
			}
		}
	}
	return wstrTargetUnitBoneName;
}

D3DXVECTOR3 CX2GUEve::GetManeuverCoreTargetPosUsingCollisionData ()
{
	// 이브 수정 사항, 엘트리온과 같이 더미 몬스터를 사용하는 경우를 위한 예외 처리,
	// 해당 유닛의 충돌 박스를 검사하여 가장 가까운 충돌 박스를 반환한다.

	if ( null != GetManeuverCoreTargetGameUnit() )
	{
		CX2GameUnitoPtr pTargetUnit = GetManeuverCoreTargetGameUnit();
		const CKTDXCollision::CollisionDataListSet& AttackListSet = GetManeuverCoreTargetGameUnit()->GetCollisionListSet();
		if ( false == AttackListSet.empty() )
		{
			const CKTDXCollision::CollisionDataList* collisionDataList = *AttackListSet.begin();
			if ( NULL != collisionDataList && false == collisionDataList->empty() )
			{
				CKTDXCollision::CollisionData* collisionData = *collisionDataList->begin();
				if ( NULL != collisionData )
				{
					BOOST_FOREACH( const CKTDXCollision::CollisionDataList* collisionDataList, AttackListSet )
					{
						BOOST_FOREACH( CKTDXCollision::CollisionData* collisionData, *collisionDataList )
						{
							if ( collisionData->m_Name == m_wstrManeuverCoreTargetBoneName )
								return collisionData->GetPointStart();
						}
					}
				}
			}		
		}
		return pTargetUnit->GetPos( false );
	}
	return D3DXVECTOR3(0,0,0);
}

/*virtual*/ const int CX2GUEve::GetHyperModeStateID()
{
	if ( 3 <= m_FrameDataFuture.syncData.m_HyperModeCount )
		return static_cast<int>( ENSI_BERSERK_MODE );
	else
		return static_cast<int>( USI_HYPER_MODE );
}


#endif // FIX_ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템 수정 사항

#endif // ADD_EVE_SYSTEM_2014	// 김종훈, 2014 - 이브 추가 시스템, 나소드 코어


