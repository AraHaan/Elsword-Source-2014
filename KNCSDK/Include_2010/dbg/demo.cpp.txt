

#include <iostream>
#include "dbg.hpp"

using namespace dbg;

// struct to check logging capabilities.
struct vector
{
    float x, y, z;

    friend std::ostream& operator << ( std::ostream& o, vector& v )
    {
        o<< "("<< v.x<< ","<< v.y<< ","<< v.z<< ")";
        return o;
    }
};

// Function used in rpofiling section
void some_wacky_useless_function()
{
    for( int i = 0; i < 99999; ++i )
    {
        double f = 54.547/i*24524+24542-94856-756/0.0000004563416*.00000000004596;
        int g = (int)f;
        f = g << i;
    }
}

void main()
{
    profiler::init_profiler();

    int* p;

    p = new int[10]; // memory leak

    p = new int;

    delete p;


    float* pp = new float[5];

    // delete pp; // should be delete []. memory manager will break on this

    // float[5] is leaked...

    // Random vars to log.
    int i1 = 33;
    int i2 = 44;
    float f1 = 8.0945f;
    double d1 = 4.6366;
    char c1 = 'a';
    vector v1 = { 3.5, 4.5, 5.5 };

    cout<< "Test some random text"<< endl;
    cerr<< "Test an error followed by a line break"<< lbreak;
    cwarn<< tab<< "test a tab and a warning followed by and end or paragraph"<< endp;
    clog<< "Just logging normally"<< endl;

    clog<< endl<< "testing assert without a break point"<< endl;

    cassert( i1 == i2 );

    cassert(0)(i1)(i2)(v1)(f1)(d1).msg("some message");

    clog<< endp<< "Profiling some for loops"<< endp;

    profiler::start( "main" );
    {
        profiler::start( "block 1" );
        for( int i = 0; i < 3; ++i )
        {
            profiler::start( "in for loop 1" );
            some_wacky_useless_function();
            profiler::end();
        }
        profiler::end();
    }

    {
        profiler::start( "block 2" );
        for( int i = 0; i < 5; ++i )
        {
            profiler::start( "in for loop 1" );
            some_wacky_useless_function();
            profiler::end();
        }
        for( int i = 0; i < 2; ++i )
        {
            profiler::start( "in for loop 2" );
            some_wacky_useless_function();
            profiler::end();
        }
        profiler::end();
    }
    profiler::end();
    
    profiler::kill_profiler( "profile_info.html" );

    clog<< "testing assert with a breakpoint (ie: .fatal() )"<< endl;


    cassert(0)(v1)(c1)(d1).msg("program end").fatal();



}